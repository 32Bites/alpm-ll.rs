/* automatically generated by rust-bindgen 0.60.1 */

pub type __int64_t = ::std::os::raw::c_long;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __off_t = ::std::os::raw::c_long;
pub type mode_t = __mode_t;
pub type off_t = __off_t;
pub type va_list = __builtin_va_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct archive {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct archive_entry {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __alpm_list_t {
    pub data: *mut ::std::os::raw::c_void,
    pub prev: *mut __alpm_list_t,
    pub next: *mut __alpm_list_t,
}
#[test]
fn bindgen_test_layout___alpm_list_t() {
    assert_eq!(
        ::std::mem::size_of::<__alpm_list_t>(),
        24usize,
        concat!("Size of: ", stringify!(__alpm_list_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__alpm_list_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__alpm_list_t))
    );
    fn test_field_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__alpm_list_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__alpm_list_t),
                "::",
                stringify!(data)
            )
        );
    }
    test_field_data();
    fn test_field_prev() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__alpm_list_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).prev) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(__alpm_list_t),
                "::",
                stringify!(prev)
            )
        );
    }
    test_field_prev();
    fn test_field_next() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__alpm_list_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(__alpm_list_t),
                "::",
                stringify!(next)
            )
        );
    }
    test_field_next();
}
pub type alpm_list_t = __alpm_list_t;
pub type alpm_list_fn_free =
    ::std::option::Option<unsafe extern "C" fn(item: *mut ::std::os::raw::c_void)>;
pub type alpm_list_fn_cmp = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " The libalpm context handle."]
#[doc = ""]
#[doc = " This struct represents an instance of libalpm."]
#[doc = " @ingroup libalpm_handle"]
pub type alpm_handle_t = u8;
#[doc = " A database."]
#[doc = ""]
#[doc = " A database is a container that stores metadata about packages."]
#[doc = ""]
#[doc = " A database can be located on the local filesystem or on a remote server."]
#[doc = ""]
#[doc = " To use a database, it must first be registered via \\link alpm_register_syncdb \\endlink."]
#[doc = " If the database is already present in dbpath then it will be usable. Otherwise,"]
#[doc = " the database needs to be downloaded using \\link alpm_db_update \\endlink. Even if the"]
#[doc = " source of the database is the local filesystem."]
#[doc = ""]
#[doc = " After this, the database can be used to query packages and groups. Any packages or groups"]
#[doc = " from the database will continue to be owned by the database and do not need to be freed by"]
#[doc = " the user. They will be freed when the database is unregistered."]
#[doc = ""]
#[doc = " Databases are automatically unregistered when the \\link alpm_handle_t \\endlink is released."]
#[doc = " @ingroup libalpm_databases"]
pub type alpm_db_t = u8;
#[doc = " A package."]
#[doc = ""]
#[doc = " A package can be loaded from disk via \\link alpm_pkg_load \\endlink or retrieved from a database."]
#[doc = " Packages from databases are automatically freed when the database is unregistered. Packages loaded"]
#[doc = " from a file must be freed manually."]
#[doc = ""]
#[doc = " Packages can then be queried for metadata or added to a \\link alpm_trans_t transaction \\endlink"]
#[doc = " to be added or removed from the system."]
#[doc = " @ingroup libalpm_packages"]
pub type alpm_pkg_t = u8;
#[doc = " Transaction structure used internally by libalpm"]
#[doc = " @ingroup libalpm_trans"]
pub type alpm_trans_t = u8;
#[doc = " The time type used by libalpm. Represents a unix time stamp"]
#[doc = " @ingroup libalpm_misc"]
pub type alpm_time_t = i64;
#[doc = " File in a package"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _alpm_file_t {
    #[doc = " Name of the file"]
    pub name: *mut ::std::os::raw::c_char,
    #[doc = " Size of the file"]
    pub size: off_t,
    #[doc = " The file's permissions"]
    pub mode: mode_t,
}
#[test]
fn bindgen_test_layout__alpm_file_t() {
    assert_eq!(
        ::std::mem::size_of::<_alpm_file_t>(),
        24usize,
        concat!("Size of: ", stringify!(_alpm_file_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_alpm_file_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_alpm_file_t))
    );
    fn test_field_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_file_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_file_t),
                "::",
                stringify!(name)
            )
        );
    }
    test_field_name();
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_file_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_file_t),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
    fn test_field_mode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_file_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mode) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_file_t),
                "::",
                stringify!(mode)
            )
        );
    }
    test_field_mode();
}
#[doc = " File in a package"]
pub type alpm_file_t = _alpm_file_t;
#[doc = " Package filelist container"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _alpm_filelist_t {
    #[doc = " Amount of files in the array"]
    pub count: usize,
    #[doc = " An array of files"]
    pub files: *mut alpm_file_t,
}
#[test]
fn bindgen_test_layout__alpm_filelist_t() {
    assert_eq!(
        ::std::mem::size_of::<_alpm_filelist_t>(),
        16usize,
        concat!("Size of: ", stringify!(_alpm_filelist_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_alpm_filelist_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_alpm_filelist_t))
    );
    fn test_field_count() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_filelist_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_filelist_t),
                "::",
                stringify!(count)
            )
        );
    }
    test_field_count();
    fn test_field_files() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_filelist_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).files) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_filelist_t),
                "::",
                stringify!(files)
            )
        );
    }
    test_field_files();
}
#[doc = " Package filelist container"]
pub type alpm_filelist_t = _alpm_filelist_t;
#[doc = " Local package or package file backup entry"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _alpm_backup_t {
    #[doc = " Name of the file (without .pacsave extension)"]
    pub name: *mut ::std::os::raw::c_char,
    #[doc = " Hash of the filename (used internally)"]
    pub hash: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__alpm_backup_t() {
    assert_eq!(
        ::std::mem::size_of::<_alpm_backup_t>(),
        16usize,
        concat!("Size of: ", stringify!(_alpm_backup_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_alpm_backup_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_alpm_backup_t))
    );
    fn test_field_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_backup_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_backup_t),
                "::",
                stringify!(name)
            )
        );
    }
    test_field_name();
    fn test_field_hash() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_backup_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).hash) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_backup_t),
                "::",
                stringify!(hash)
            )
        );
    }
    test_field_hash();
}
#[doc = " Local package or package file backup entry"]
pub type alpm_backup_t = _alpm_backup_t;
#[doc = " Package group"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _alpm_group_t {
    #[doc = " group name"]
    pub name: *mut ::std::os::raw::c_char,
    #[doc = " list of alpm_pkg_t packages"]
    pub packages: *mut alpm_list_t,
}
#[test]
fn bindgen_test_layout__alpm_group_t() {
    assert_eq!(
        ::std::mem::size_of::<_alpm_group_t>(),
        16usize,
        concat!("Size of: ", stringify!(_alpm_group_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_alpm_group_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_alpm_group_t))
    );
    fn test_field_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_group_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_group_t),
                "::",
                stringify!(name)
            )
        );
    }
    test_field_name();
    fn test_field_packages() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_group_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).packages) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_group_t),
                "::",
                stringify!(packages)
            )
        );
    }
    test_field_packages();
}
#[doc = " Package group"]
pub type alpm_group_t = _alpm_group_t;
#[repr(u32)]
#[doc = " libalpm's error type"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _alpm_errno_t {
    #[doc = " No error"]
    ALPM_ERR_OK = 0,
    #[doc = " Failed to allocate memory"]
    ALPM_ERR_MEMORY = 1,
    #[doc = " A system error occurred"]
    ALPM_ERR_SYSTEM = 2,
    #[doc = " Permmision denied"]
    ALPM_ERR_BADPERMS = 3,
    #[doc = " Should be a file"]
    ALPM_ERR_NOT_A_FILE = 4,
    #[doc = " Should be a directory"]
    ALPM_ERR_NOT_A_DIR = 5,
    #[doc = " Function was called with invalid arguments"]
    ALPM_ERR_WRONG_ARGS = 6,
    #[doc = " Insufficient disk space"]
    ALPM_ERR_DISK_SPACE = 7,
    #[doc = " Handle should be null"]
    ALPM_ERR_HANDLE_NULL = 8,
    #[doc = " Handle should not be null"]
    ALPM_ERR_HANDLE_NOT_NULL = 9,
    #[doc = " Failed to acquire lock"]
    ALPM_ERR_HANDLE_LOCK = 10,
    #[doc = " Failed to open database"]
    ALPM_ERR_DB_OPEN = 11,
    #[doc = " Failed to create database"]
    ALPM_ERR_DB_CREATE = 12,
    #[doc = " Database should not be null"]
    ALPM_ERR_DB_NULL = 13,
    #[doc = " Database should be null"]
    ALPM_ERR_DB_NOT_NULL = 14,
    #[doc = " The database could not be found"]
    ALPM_ERR_DB_NOT_FOUND = 15,
    #[doc = " Database is invalid"]
    ALPM_ERR_DB_INVALID = 16,
    #[doc = " Database has an invalid signature"]
    ALPM_ERR_DB_INVALID_SIG = 17,
    #[doc = " The localdb is in a newer/older format than libalpm expects"]
    ALPM_ERR_DB_VERSION = 18,
    #[doc = " Failed to write to the database"]
    ALPM_ERR_DB_WRITE = 19,
    #[doc = " Failed to remove entry from database"]
    ALPM_ERR_DB_REMOVE = 20,
    #[doc = " Server URL is in an invalid format"]
    ALPM_ERR_SERVER_BAD_URL = 21,
    #[doc = " The database has no configured servers"]
    ALPM_ERR_SERVER_NONE = 22,
    #[doc = " A transaction is already initialized"]
    ALPM_ERR_TRANS_NOT_NULL = 23,
    #[doc = " A transaction has not been initialized"]
    ALPM_ERR_TRANS_NULL = 24,
    #[doc = " Duplicate target in transaction"]
    ALPM_ERR_TRANS_DUP_TARGET = 25,
    #[doc = " Duplicate filename in transaction"]
    ALPM_ERR_TRANS_DUP_FILENAME = 26,
    #[doc = " A transaction has not been initialized"]
    ALPM_ERR_TRANS_NOT_INITIALIZED = 27,
    #[doc = " Transaction has not been prepared"]
    ALPM_ERR_TRANS_NOT_PREPARED = 28,
    #[doc = " Transaction was aborted"]
    ALPM_ERR_TRANS_ABORT = 29,
    #[doc = " Failed to interrupt transaction"]
    ALPM_ERR_TRANS_TYPE = 30,
    #[doc = " Tried to commit transaction without locking the database"]
    ALPM_ERR_TRANS_NOT_LOCKED = 31,
    #[doc = " A hook failed to run"]
    ALPM_ERR_TRANS_HOOK_FAILED = 32,
    #[doc = " Package not found"]
    ALPM_ERR_PKG_NOT_FOUND = 33,
    #[doc = " Package is in ignorepkg"]
    ALPM_ERR_PKG_IGNORED = 34,
    #[doc = " Package is invalid"]
    ALPM_ERR_PKG_INVALID = 35,
    #[doc = " Package has an invalid checksum"]
    ALPM_ERR_PKG_INVALID_CHECKSUM = 36,
    #[doc = " Package has an invalid signature"]
    ALPM_ERR_PKG_INVALID_SIG = 37,
    #[doc = " Package does not have a signature"]
    ALPM_ERR_PKG_MISSING_SIG = 38,
    #[doc = " Cannot open the package file"]
    ALPM_ERR_PKG_OPEN = 39,
    #[doc = " Failed to remove package files"]
    ALPM_ERR_PKG_CANT_REMOVE = 40,
    #[doc = " Package has an invalid name"]
    ALPM_ERR_PKG_INVALID_NAME = 41,
    #[doc = " Package has an invalid architecture"]
    ALPM_ERR_PKG_INVALID_ARCH = 42,
    #[doc = " Signatures are missing"]
    ALPM_ERR_SIG_MISSING = 43,
    #[doc = " Signatures are invalid"]
    ALPM_ERR_SIG_INVALID = 44,
    #[doc = " Dependencies could not be satisfied"]
    ALPM_ERR_UNSATISFIED_DEPS = 45,
    #[doc = " Conflicting dependencies"]
    ALPM_ERR_CONFLICTING_DEPS = 46,
    #[doc = " Files conflict"]
    ALPM_ERR_FILE_CONFLICTS = 47,
    #[doc = " Download failed"]
    ALPM_ERR_RETRIEVE = 48,
    #[doc = " Invalid Regex"]
    ALPM_ERR_INVALID_REGEX = 49,
    #[doc = " Error in libarchive"]
    ALPM_ERR_LIBARCHIVE = 50,
    #[doc = " Error in libcurl"]
    ALPM_ERR_LIBCURL = 51,
    #[doc = " Error in external download program"]
    ALPM_ERR_EXTERNAL_DOWNLOAD = 52,
    #[doc = " Error in gpgme"]
    ALPM_ERR_GPGME = 53,
    #[doc = " Missing compile-time features"]
    ALPM_ERR_MISSING_CAPABILITY_SIGNATURES = 54,
}
#[doc = " libalpm's error type"]
pub use self::_alpm_errno_t as alpm_errno_t;
pub mod _alpm_siglevel_t {
    #[doc = " PGP signature verification options"]
    pub type Type = ::std::os::raw::c_uint;
    #[doc = " Packages require a signature"]
    pub const ALPM_SIG_PACKAGE: Type = 1;
    #[doc = " Packages do not require a signature,"]
    #[doc = " but check packages that do have signatures"]
    pub const ALPM_SIG_PACKAGE_OPTIONAL: Type = 2;
    #[doc = " Packages do not require a signature,"]
    #[doc = " but check packages that do have signatures"]
    pub const ALPM_SIG_PACKAGE_MARGINAL_OK: Type = 4;
    #[doc = " Allow packages with signatures that are unknown trust"]
    pub const ALPM_SIG_PACKAGE_UNKNOWN_OK: Type = 8;
    #[doc = " Databases require a signature"]
    pub const ALPM_SIG_DATABASE: Type = 1024;
    #[doc = " Databases do not require a signature,"]
    #[doc = " but check databases that do have signatures"]
    pub const ALPM_SIG_DATABASE_OPTIONAL: Type = 2048;
    #[doc = " Allow databases with signatures that are marginal trust"]
    pub const ALPM_SIG_DATABASE_MARGINAL_OK: Type = 4096;
    #[doc = " Allow databases with signatures that are unknown trust"]
    pub const ALPM_SIG_DATABASE_UNKNOWN_OK: Type = 8192;
    #[doc = " The Default siglevel"]
    pub const ALPM_SIG_USE_DEFAULT: Type = 1073741824;
}
#[doc = " PGP signature verification options"]
pub use self::_alpm_siglevel_t::Type as alpm_siglevel_t;
#[repr(u32)]
#[doc = " PGP signature verification status return codes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _alpm_sigstatus_t {
    #[doc = " Signature is valid"]
    ALPM_SIGSTATUS_VALID = 0,
    #[doc = " The key has expired"]
    ALPM_SIGSTATUS_KEY_EXPIRED = 1,
    #[doc = " The signature has expired"]
    ALPM_SIGSTATUS_SIG_EXPIRED = 2,
    #[doc = " The key is not in the keyring"]
    ALPM_SIGSTATUS_KEY_UNKNOWN = 3,
    #[doc = " The key has been disabled"]
    ALPM_SIGSTATUS_KEY_DISABLED = 4,
    #[doc = " The signature is invalid"]
    ALPM_SIGSTATUS_INVALID = 5,
}
#[doc = " PGP signature verification status return codes"]
pub use self::_alpm_sigstatus_t as alpm_sigstatus_t;
#[repr(u32)]
#[doc = " The trust level of a PGP key"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _alpm_sigvalidity_t {
    #[doc = " The signature is fully trusted"]
    ALPM_SIGVALIDITY_FULL = 0,
    #[doc = " The signature is marginally trusted"]
    ALPM_SIGVALIDITY_MARGINAL = 1,
    #[doc = " The signature is never trusted"]
    ALPM_SIGVALIDITY_NEVER = 2,
    #[doc = " The signature has unknown trust"]
    ALPM_SIGVALIDITY_UNKNOWN = 3,
}
#[doc = " The trust level of a PGP key"]
pub use self::_alpm_sigvalidity_t as alpm_sigvalidity_t;
#[doc = " A PGP key"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _alpm_pgpkey_t {
    #[doc = " The actual key data"]
    pub data: *mut ::std::os::raw::c_void,
    #[doc = " The key's fingerprint"]
    pub fingerprint: *mut ::std::os::raw::c_char,
    #[doc = " UID of the key"]
    pub uid: *mut ::std::os::raw::c_char,
    #[doc = " Name of the key's owner"]
    pub name: *mut ::std::os::raw::c_char,
    #[doc = " Email of the key's owner"]
    pub email: *mut ::std::os::raw::c_char,
    #[doc = " When the key was created"]
    pub created: alpm_time_t,
    #[doc = " When the key expires"]
    pub expires: alpm_time_t,
    #[doc = " The length of the key"]
    pub length: ::std::os::raw::c_uint,
    #[doc = " has the key been revoked"]
    pub revoked: ::std::os::raw::c_uint,
    #[doc = " A character representing the  encryption algorithm used by the public key"]
    #[doc = ""]
    #[doc = " ? = unknown"]
    #[doc = " R = RSA"]
    #[doc = " D = DSA"]
    #[doc = " E = EDDSA"]
    pub pubkey_algo: ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__alpm_pgpkey_t() {
    assert_eq!(
        ::std::mem::size_of::<_alpm_pgpkey_t>(),
        72usize,
        concat!("Size of: ", stringify!(_alpm_pgpkey_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_alpm_pgpkey_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_alpm_pgpkey_t))
    );
    fn test_field_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_pgpkey_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_pgpkey_t),
                "::",
                stringify!(data)
            )
        );
    }
    test_field_data();
    fn test_field_fingerprint() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_pgpkey_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fingerprint) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_pgpkey_t),
                "::",
                stringify!(fingerprint)
            )
        );
    }
    test_field_fingerprint();
    fn test_field_uid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_pgpkey_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).uid) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_pgpkey_t),
                "::",
                stringify!(uid)
            )
        );
    }
    test_field_uid();
    fn test_field_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_pgpkey_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_pgpkey_t),
                "::",
                stringify!(name)
            )
        );
    }
    test_field_name();
    fn test_field_email() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_pgpkey_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).email) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_pgpkey_t),
                "::",
                stringify!(email)
            )
        );
    }
    test_field_email();
    fn test_field_created() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_pgpkey_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).created) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_pgpkey_t),
                "::",
                stringify!(created)
            )
        );
    }
    test_field_created();
    fn test_field_expires() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_pgpkey_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).expires) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_pgpkey_t),
                "::",
                stringify!(expires)
            )
        );
    }
    test_field_expires();
    fn test_field_length() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_pgpkey_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_pgpkey_t),
                "::",
                stringify!(length)
            )
        );
    }
    test_field_length();
    fn test_field_revoked() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_pgpkey_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).revoked) as usize - ptr as usize
            },
            60usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_pgpkey_t),
                "::",
                stringify!(revoked)
            )
        );
    }
    test_field_revoked();
    fn test_field_pubkey_algo() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_pgpkey_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pubkey_algo) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_pgpkey_t),
                "::",
                stringify!(pubkey_algo)
            )
        );
    }
    test_field_pubkey_algo();
}
#[doc = " A PGP key"]
pub type alpm_pgpkey_t = _alpm_pgpkey_t;
#[doc = " Signature result. Contains the key, status, and validity of a given"]
#[doc = " signature."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _alpm_sigresult_t {
    #[doc = " The key of the signature"]
    pub key: alpm_pgpkey_t,
    #[doc = " The status of the signature"]
    pub status: alpm_sigstatus_t,
    #[doc = " The validity of the signature"]
    pub validity: alpm_sigvalidity_t,
}
#[test]
fn bindgen_test_layout__alpm_sigresult_t() {
    assert_eq!(
        ::std::mem::size_of::<_alpm_sigresult_t>(),
        80usize,
        concat!("Size of: ", stringify!(_alpm_sigresult_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_alpm_sigresult_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_alpm_sigresult_t))
    );
    fn test_field_key() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_sigresult_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).key) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_sigresult_t),
                "::",
                stringify!(key)
            )
        );
    }
    test_field_key();
    fn test_field_status() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_sigresult_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).status) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_sigresult_t),
                "::",
                stringify!(status)
            )
        );
    }
    test_field_status();
    fn test_field_validity() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_sigresult_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).validity) as usize - ptr as usize
            },
            76usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_sigresult_t),
                "::",
                stringify!(validity)
            )
        );
    }
    test_field_validity();
}
#[doc = " Signature result. Contains the key, status, and validity of a given"]
#[doc = " signature."]
pub type alpm_sigresult_t = _alpm_sigresult_t;
#[doc = " Signature list. Contains the number of signatures found and a pointer to an"]
#[doc = " array of results. The array is of size count."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _alpm_siglist_t {
    #[doc = " The amount of results in the array"]
    pub count: usize,
    #[doc = " An array of sigresults"]
    pub results: *mut alpm_sigresult_t,
}
#[test]
fn bindgen_test_layout__alpm_siglist_t() {
    assert_eq!(
        ::std::mem::size_of::<_alpm_siglist_t>(),
        16usize,
        concat!("Size of: ", stringify!(_alpm_siglist_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_alpm_siglist_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_alpm_siglist_t))
    );
    fn test_field_count() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_siglist_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_siglist_t),
                "::",
                stringify!(count)
            )
        );
    }
    test_field_count();
    fn test_field_results() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_siglist_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).results) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_siglist_t),
                "::",
                stringify!(results)
            )
        );
    }
    test_field_results();
}
#[doc = " Signature list. Contains the number of signatures found and a pointer to an"]
#[doc = " array of results. The array is of size count."]
pub type alpm_siglist_t = _alpm_siglist_t;
#[repr(u32)]
#[doc = " Types of version constraints in dependency specs."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _alpm_depmod_t {
    #[doc = " No version constraint"]
    ALPM_DEP_MOD_ANY = 1,
    #[doc = " Test version equality (package=x.y.z)"]
    ALPM_DEP_MOD_EQ = 2,
    #[doc = " Test for at least a version (package>=x.y.z)"]
    ALPM_DEP_MOD_GE = 3,
    #[doc = " Test for at most a version (package<=x.y.z)"]
    ALPM_DEP_MOD_LE = 4,
    #[doc = " Test for greater than some version (package>x.y.z)"]
    ALPM_DEP_MOD_GT = 5,
    #[doc = " Test for less than some version (package<x.y.z)"]
    ALPM_DEP_MOD_LT = 6,
}
#[doc = " Types of version constraints in dependency specs."]
pub use self::_alpm_depmod_t as alpm_depmod_t;
#[repr(u32)]
#[doc = " File conflict type."]
#[doc = " Whether the conflict results from a file existing on the filesystem, or with"]
#[doc = " another target in the transaction."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _alpm_fileconflicttype_t {
    #[doc = " The conflict results with a another target in the transaction"]
    ALPM_FILECONFLICT_TARGET = 1,
    #[doc = " The conflict results from a file existing on the filesystem"]
    ALPM_FILECONFLICT_FILESYSTEM = 2,
}
#[doc = " File conflict type."]
#[doc = " Whether the conflict results from a file existing on the filesystem, or with"]
#[doc = " another target in the transaction."]
pub use self::_alpm_fileconflicttype_t as alpm_fileconflicttype_t;
#[doc = " The basic dependency type."]
#[doc = ""]
#[doc = " This type is used throughout libalpm, not just for dependencies"]
#[doc = " but also conflicts and providers."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _alpm_depend_t {
    #[doc = "  Name of the provider to satisfy this dependency"]
    pub name: *mut ::std::os::raw::c_char,
    #[doc = "  Version of the provider to match against (optional)"]
    pub version: *mut ::std::os::raw::c_char,
    #[doc = " A description of why this dependency is needed (optional)"]
    pub desc: *mut ::std::os::raw::c_char,
    #[doc = " A hash of name (used internally to speed up conflict checks)"]
    pub name_hash: ::std::os::raw::c_ulong,
    #[doc = " How the version should match against the provider"]
    pub mod_: alpm_depmod_t,
}
#[test]
fn bindgen_test_layout__alpm_depend_t() {
    assert_eq!(
        ::std::mem::size_of::<_alpm_depend_t>(),
        40usize,
        concat!("Size of: ", stringify!(_alpm_depend_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_alpm_depend_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_alpm_depend_t))
    );
    fn test_field_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_depend_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_depend_t),
                "::",
                stringify!(name)
            )
        );
    }
    test_field_name();
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_depend_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_depend_t),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_desc() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_depend_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).desc) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_depend_t),
                "::",
                stringify!(desc)
            )
        );
    }
    test_field_desc();
    fn test_field_name_hash() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_depend_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).name_hash) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_depend_t),
                "::",
                stringify!(name_hash)
            )
        );
    }
    test_field_name_hash();
    fn test_field_mod() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_depend_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mod_) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_depend_t),
                "::",
                stringify!(mod_)
            )
        );
    }
    test_field_mod();
}
#[doc = " The basic dependency type."]
#[doc = ""]
#[doc = " This type is used throughout libalpm, not just for dependencies"]
#[doc = " but also conflicts and providers."]
pub type alpm_depend_t = _alpm_depend_t;
#[doc = " Missing dependency."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _alpm_depmissing_t {
    #[doc = " Name of the package that has the dependency"]
    pub target: *mut ::std::os::raw::c_char,
    #[doc = " The dependency that was wanted"]
    pub depend: *mut alpm_depend_t,
    #[doc = " If the depmissing was caused by a conflict, the name of the package"]
    #[doc = " that would be installed, causing the satisfying package to be removed"]
    pub causingpkg: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__alpm_depmissing_t() {
    assert_eq!(
        ::std::mem::size_of::<_alpm_depmissing_t>(),
        24usize,
        concat!("Size of: ", stringify!(_alpm_depmissing_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_alpm_depmissing_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_alpm_depmissing_t))
    );
    fn test_field_target() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_depmissing_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).target) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_depmissing_t),
                "::",
                stringify!(target)
            )
        );
    }
    test_field_target();
    fn test_field_depend() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_depmissing_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).depend) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_depmissing_t),
                "::",
                stringify!(depend)
            )
        );
    }
    test_field_depend();
    fn test_field_causingpkg() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_depmissing_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).causingpkg) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_depmissing_t),
                "::",
                stringify!(causingpkg)
            )
        );
    }
    test_field_causingpkg();
}
#[doc = " Missing dependency."]
pub type alpm_depmissing_t = _alpm_depmissing_t;
#[doc = " A conflict that has occurred between two packages."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _alpm_conflict_t {
    #[doc = " Hash of the first package name"]
    #[doc = " (used internally to speed up conflict checks)"]
    pub package1_hash: ::std::os::raw::c_ulong,
    #[doc = " Hash of the second package name"]
    #[doc = " (used internally to speed up conflict checks)"]
    pub package2_hash: ::std::os::raw::c_ulong,
    #[doc = " Name of the first package"]
    pub package1: *mut ::std::os::raw::c_char,
    #[doc = " Name of the second package"]
    pub package2: *mut ::std::os::raw::c_char,
    #[doc = " The conflict"]
    pub reason: *mut alpm_depend_t,
}
#[test]
fn bindgen_test_layout__alpm_conflict_t() {
    assert_eq!(
        ::std::mem::size_of::<_alpm_conflict_t>(),
        40usize,
        concat!("Size of: ", stringify!(_alpm_conflict_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_alpm_conflict_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_alpm_conflict_t))
    );
    fn test_field_package1_hash() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_conflict_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).package1_hash) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_conflict_t),
                "::",
                stringify!(package1_hash)
            )
        );
    }
    test_field_package1_hash();
    fn test_field_package2_hash() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_conflict_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).package2_hash) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_conflict_t),
                "::",
                stringify!(package2_hash)
            )
        );
    }
    test_field_package2_hash();
    fn test_field_package1() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_conflict_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).package1) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_conflict_t),
                "::",
                stringify!(package1)
            )
        );
    }
    test_field_package1();
    fn test_field_package2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_conflict_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).package2) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_conflict_t),
                "::",
                stringify!(package2)
            )
        );
    }
    test_field_package2();
    fn test_field_reason() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_conflict_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reason) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_conflict_t),
                "::",
                stringify!(reason)
            )
        );
    }
    test_field_reason();
}
#[doc = " A conflict that has occurred between two packages."]
pub type alpm_conflict_t = _alpm_conflict_t;
#[doc = " File conflict."]
#[doc = ""]
#[doc = " A conflict that has happened due to a two packages containing the same file,"]
#[doc = " or a package contains a file that is already on the filesystem and not owned"]
#[doc = " by that package."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _alpm_fileconflict_t {
    #[doc = " The name of the package that caused the conflict"]
    pub target: *mut ::std::os::raw::c_char,
    #[doc = " The type of conflict"]
    pub type_: alpm_fileconflicttype_t,
    #[doc = " The name of the file that the package conflicts with"]
    pub file: *mut ::std::os::raw::c_char,
    #[doc = " The name of the package that also owns the file if there is one"]
    pub ctarget: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__alpm_fileconflict_t() {
    assert_eq!(
        ::std::mem::size_of::<_alpm_fileconflict_t>(),
        32usize,
        concat!("Size of: ", stringify!(_alpm_fileconflict_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_alpm_fileconflict_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_alpm_fileconflict_t))
    );
    fn test_field_target() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_fileconflict_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).target) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_fileconflict_t),
                "::",
                stringify!(target)
            )
        );
    }
    test_field_target();
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_fileconflict_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_fileconflict_t),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
    fn test_field_file() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_fileconflict_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).file) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_fileconflict_t),
                "::",
                stringify!(file)
            )
        );
    }
    test_field_file();
    fn test_field_ctarget() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_fileconflict_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ctarget) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_fileconflict_t),
                "::",
                stringify!(ctarget)
            )
        );
    }
    test_field_ctarget();
}
#[doc = " File conflict."]
#[doc = ""]
#[doc = " A conflict that has happened due to a two packages containing the same file,"]
#[doc = " or a package contains a file that is already on the filesystem and not owned"]
#[doc = " by that package."]
pub type alpm_fileconflict_t = _alpm_fileconflict_t;
#[repr(u32)]
#[doc = " Type of events."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _alpm_event_type_t {
    #[doc = " Dependencies will be computed for a package."]
    ALPM_EVENT_CHECKDEPS_START = 1,
    #[doc = " Dependencies were computed for a package."]
    ALPM_EVENT_CHECKDEPS_DONE = 2,
    #[doc = " File conflicts will be computed for a package."]
    ALPM_EVENT_FILECONFLICTS_START = 3,
    #[doc = " File conflicts were computed for a package."]
    ALPM_EVENT_FILECONFLICTS_DONE = 4,
    #[doc = " Dependencies will be resolved for target package."]
    ALPM_EVENT_RESOLVEDEPS_START = 5,
    #[doc = " Dependencies were resolved for target package."]
    ALPM_EVENT_RESOLVEDEPS_DONE = 6,
    #[doc = " Inter-conflicts will be checked for target package."]
    ALPM_EVENT_INTERCONFLICTS_START = 7,
    #[doc = " Inter-conflicts were checked for target package."]
    ALPM_EVENT_INTERCONFLICTS_DONE = 8,
    #[doc = " Processing the package transaction is starting."]
    ALPM_EVENT_TRANSACTION_START = 9,
    #[doc = " Processing the package transaction is finished."]
    ALPM_EVENT_TRANSACTION_DONE = 10,
    #[doc = " Package will be installed/upgraded/downgraded/re-installed/removed; See"]
    #[doc = " alpm_event_package_operation_t for arguments."]
    ALPM_EVENT_PACKAGE_OPERATION_START = 11,
    #[doc = " Package was installed/upgraded/downgraded/re-installed/removed; See"]
    #[doc = " alpm_event_package_operation_t for arguments."]
    ALPM_EVENT_PACKAGE_OPERATION_DONE = 12,
    #[doc = " Target package's integrity will be checked."]
    ALPM_EVENT_INTEGRITY_START = 13,
    #[doc = " Target package's integrity was checked."]
    ALPM_EVENT_INTEGRITY_DONE = 14,
    #[doc = " Target package will be loaded."]
    ALPM_EVENT_LOAD_START = 15,
    #[doc = " Target package is finished loading."]
    ALPM_EVENT_LOAD_DONE = 16,
    #[doc = " Scriptlet has printed information; See alpm_event_scriptlet_info_t for"]
    #[doc = " arguments."]
    ALPM_EVENT_SCRIPTLET_INFO = 17,
    #[doc = " Database files will be downloaded from a repository."]
    ALPM_EVENT_DB_RETRIEVE_START = 18,
    #[doc = " Database files were downloaded from a repository."]
    ALPM_EVENT_DB_RETRIEVE_DONE = 19,
    #[doc = " Not all database files were successfully downloaded from a repository."]
    ALPM_EVENT_DB_RETRIEVE_FAILED = 20,
    #[doc = " Package files will be downloaded from a repository."]
    ALPM_EVENT_PKG_RETRIEVE_START = 21,
    #[doc = " Package files were downloaded from a repository."]
    ALPM_EVENT_PKG_RETRIEVE_DONE = 22,
    #[doc = " Not all package files were successfully downloaded from a repository."]
    ALPM_EVENT_PKG_RETRIEVE_FAILED = 23,
    #[doc = " Disk space usage will be computed for a package."]
    ALPM_EVENT_DISKSPACE_START = 24,
    #[doc = " Disk space usage was computed for a package."]
    ALPM_EVENT_DISKSPACE_DONE = 25,
    #[doc = " An optdepend for another package is being removed; See"]
    #[doc = " alpm_event_optdep_removal_t for arguments."]
    ALPM_EVENT_OPTDEP_REMOVAL = 26,
    #[doc = " A configured repository database is missing; See"]
    #[doc = " alpm_event_database_missing_t for arguments."]
    ALPM_EVENT_DATABASE_MISSING = 27,
    #[doc = " Checking keys used to create signatures are in keyring."]
    ALPM_EVENT_KEYRING_START = 28,
    #[doc = " Keyring checking is finished."]
    ALPM_EVENT_KEYRING_DONE = 29,
    #[doc = " Downloading missing keys into keyring."]
    ALPM_EVENT_KEY_DOWNLOAD_START = 30,
    #[doc = " Key downloading is finished."]
    ALPM_EVENT_KEY_DOWNLOAD_DONE = 31,
    #[doc = " A .pacnew file was created; See alpm_event_pacnew_created_t for arguments."]
    ALPM_EVENT_PACNEW_CREATED = 32,
    #[doc = " A .pacsave file was created; See alpm_event_pacsave_created_t for"]
    #[doc = " arguments."]
    ALPM_EVENT_PACSAVE_CREATED = 33,
    #[doc = " Processing hooks will be started."]
    ALPM_EVENT_HOOK_START = 34,
    #[doc = " Processing hooks is finished."]
    ALPM_EVENT_HOOK_DONE = 35,
    #[doc = " A hook is starting"]
    ALPM_EVENT_HOOK_RUN_START = 36,
    #[doc = " A hook has finished running."]
    ALPM_EVENT_HOOK_RUN_DONE = 37,
}
#[doc = " Type of events."]
pub use self::_alpm_event_type_t as alpm_event_type_t;
#[doc = " An event that may represent any event."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _alpm_event_any_t {
    #[doc = " Type of event"]
    pub type_: alpm_event_type_t,
}
#[test]
fn bindgen_test_layout__alpm_event_any_t() {
    assert_eq!(
        ::std::mem::size_of::<_alpm_event_any_t>(),
        4usize,
        concat!("Size of: ", stringify!(_alpm_event_any_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_alpm_event_any_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_alpm_event_any_t))
    );
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_event_any_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_event_any_t),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
}
#[doc = " An event that may represent any event."]
pub type alpm_event_any_t = _alpm_event_any_t;
#[repr(u32)]
#[doc = " An enum over the kind of package operations."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _alpm_package_operation_t {
    #[doc = " Package (to be) installed. (No oldpkg)"]
    ALPM_PACKAGE_INSTALL = 1,
    #[doc = " Package (to be) upgraded"]
    ALPM_PACKAGE_UPGRADE = 2,
    #[doc = " Package (to be) re-installed"]
    ALPM_PACKAGE_REINSTALL = 3,
    #[doc = " Package (to be) downgraded"]
    ALPM_PACKAGE_DOWNGRADE = 4,
    #[doc = " Package (to be) removed (No newpkg)"]
    ALPM_PACKAGE_REMOVE = 5,
}
#[doc = " An enum over the kind of package operations."]
pub use self::_alpm_package_operation_t as alpm_package_operation_t;
#[doc = " A package operation event occurred."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _alpm_event_package_operation_t {
    #[doc = " Type of event"]
    pub type_: alpm_event_type_t,
    #[doc = " Type of operation"]
    pub operation: alpm_package_operation_t,
    #[doc = " Old package"]
    pub oldpkg: *mut alpm_pkg_t,
    #[doc = " New package"]
    pub newpkg: *mut alpm_pkg_t,
}
#[test]
fn bindgen_test_layout__alpm_event_package_operation_t() {
    assert_eq!(
        ::std::mem::size_of::<_alpm_event_package_operation_t>(),
        24usize,
        concat!("Size of: ", stringify!(_alpm_event_package_operation_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_alpm_event_package_operation_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_alpm_event_package_operation_t))
    );
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_event_package_operation_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_event_package_operation_t),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
    fn test_field_operation() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_event_package_operation_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).operation) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_event_package_operation_t),
                "::",
                stringify!(operation)
            )
        );
    }
    test_field_operation();
    fn test_field_oldpkg() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_event_package_operation_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).oldpkg) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_event_package_operation_t),
                "::",
                stringify!(oldpkg)
            )
        );
    }
    test_field_oldpkg();
    fn test_field_newpkg() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_event_package_operation_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).newpkg) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_event_package_operation_t),
                "::",
                stringify!(newpkg)
            )
        );
    }
    test_field_newpkg();
}
#[doc = " A package operation event occurred."]
pub type alpm_event_package_operation_t = _alpm_event_package_operation_t;
#[doc = " An optional dependency was removed."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _alpm_event_optdep_removal_t {
    #[doc = " Type of event"]
    pub type_: alpm_event_type_t,
    #[doc = " Package with the optdep"]
    pub pkg: *mut alpm_pkg_t,
    #[doc = " Optdep being removed"]
    pub optdep: *mut alpm_depend_t,
}
#[test]
fn bindgen_test_layout__alpm_event_optdep_removal_t() {
    assert_eq!(
        ::std::mem::size_of::<_alpm_event_optdep_removal_t>(),
        24usize,
        concat!("Size of: ", stringify!(_alpm_event_optdep_removal_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_alpm_event_optdep_removal_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_alpm_event_optdep_removal_t))
    );
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_event_optdep_removal_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_event_optdep_removal_t),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
    fn test_field_pkg() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_event_optdep_removal_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pkg) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_event_optdep_removal_t),
                "::",
                stringify!(pkg)
            )
        );
    }
    test_field_pkg();
    fn test_field_optdep() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_event_optdep_removal_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).optdep) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_event_optdep_removal_t),
                "::",
                stringify!(optdep)
            )
        );
    }
    test_field_optdep();
}
#[doc = " An optional dependency was removed."]
pub type alpm_event_optdep_removal_t = _alpm_event_optdep_removal_t;
#[doc = " A scriptlet was ran."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _alpm_event_scriptlet_info_t {
    #[doc = " Type of event"]
    pub type_: alpm_event_type_t,
    #[doc = " Line of scriptlet output"]
    pub line: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__alpm_event_scriptlet_info_t() {
    assert_eq!(
        ::std::mem::size_of::<_alpm_event_scriptlet_info_t>(),
        16usize,
        concat!("Size of: ", stringify!(_alpm_event_scriptlet_info_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_alpm_event_scriptlet_info_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_alpm_event_scriptlet_info_t))
    );
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_event_scriptlet_info_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_event_scriptlet_info_t),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
    fn test_field_line() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_event_scriptlet_info_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).line) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_event_scriptlet_info_t),
                "::",
                stringify!(line)
            )
        );
    }
    test_field_line();
}
#[doc = " A scriptlet was ran."]
pub type alpm_event_scriptlet_info_t = _alpm_event_scriptlet_info_t;
#[doc = " A database is missing."]
#[doc = ""]
#[doc = " The database is registered but has not been downloaded"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _alpm_event_database_missing_t {
    #[doc = " Type of event"]
    pub type_: alpm_event_type_t,
    #[doc = " Name of the database"]
    pub dbname: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__alpm_event_database_missing_t() {
    assert_eq!(
        ::std::mem::size_of::<_alpm_event_database_missing_t>(),
        16usize,
        concat!("Size of: ", stringify!(_alpm_event_database_missing_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_alpm_event_database_missing_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_alpm_event_database_missing_t))
    );
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_event_database_missing_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_event_database_missing_t),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
    fn test_field_dbname() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_event_database_missing_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dbname) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_event_database_missing_t),
                "::",
                stringify!(dbname)
            )
        );
    }
    test_field_dbname();
}
#[doc = " A database is missing."]
#[doc = ""]
#[doc = " The database is registered but has not been downloaded"]
pub type alpm_event_database_missing_t = _alpm_event_database_missing_t;
#[doc = " A package was downloaded."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _alpm_event_pkgdownload_t {
    #[doc = " Type of event"]
    pub type_: alpm_event_type_t,
    #[doc = " Name of the file"]
    pub file: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__alpm_event_pkgdownload_t() {
    assert_eq!(
        ::std::mem::size_of::<_alpm_event_pkgdownload_t>(),
        16usize,
        concat!("Size of: ", stringify!(_alpm_event_pkgdownload_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_alpm_event_pkgdownload_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_alpm_event_pkgdownload_t))
    );
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_event_pkgdownload_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_event_pkgdownload_t),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
    fn test_field_file() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_event_pkgdownload_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).file) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_event_pkgdownload_t),
                "::",
                stringify!(file)
            )
        );
    }
    test_field_file();
}
#[doc = " A package was downloaded."]
pub type alpm_event_pkgdownload_t = _alpm_event_pkgdownload_t;
#[doc = " A pacnew file was created."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _alpm_event_pacnew_created_t {
    #[doc = " Type of event"]
    pub type_: alpm_event_type_t,
    #[doc = " Whether the creation was result of a NoUpgrade or not"]
    pub from_noupgrade: ::std::os::raw::c_int,
    #[doc = " Old package"]
    pub oldpkg: *mut alpm_pkg_t,
    #[doc = " New Package"]
    pub newpkg: *mut alpm_pkg_t,
    #[doc = " Filename of the file without the .pacnew suffix"]
    pub file: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__alpm_event_pacnew_created_t() {
    assert_eq!(
        ::std::mem::size_of::<_alpm_event_pacnew_created_t>(),
        32usize,
        concat!("Size of: ", stringify!(_alpm_event_pacnew_created_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_alpm_event_pacnew_created_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_alpm_event_pacnew_created_t))
    );
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_event_pacnew_created_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_event_pacnew_created_t),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
    fn test_field_from_noupgrade() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_event_pacnew_created_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).from_noupgrade) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_event_pacnew_created_t),
                "::",
                stringify!(from_noupgrade)
            )
        );
    }
    test_field_from_noupgrade();
    fn test_field_oldpkg() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_event_pacnew_created_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).oldpkg) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_event_pacnew_created_t),
                "::",
                stringify!(oldpkg)
            )
        );
    }
    test_field_oldpkg();
    fn test_field_newpkg() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_event_pacnew_created_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).newpkg) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_event_pacnew_created_t),
                "::",
                stringify!(newpkg)
            )
        );
    }
    test_field_newpkg();
    fn test_field_file() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_event_pacnew_created_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).file) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_event_pacnew_created_t),
                "::",
                stringify!(file)
            )
        );
    }
    test_field_file();
}
#[doc = " A pacnew file was created."]
pub type alpm_event_pacnew_created_t = _alpm_event_pacnew_created_t;
#[doc = " A pacsave file was created."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _alpm_event_pacsave_created_t {
    #[doc = " Type of event"]
    pub type_: alpm_event_type_t,
    #[doc = " Old package"]
    pub oldpkg: *mut alpm_pkg_t,
    #[doc = " Filename of the file without the .pacsave suffix"]
    pub file: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__alpm_event_pacsave_created_t() {
    assert_eq!(
        ::std::mem::size_of::<_alpm_event_pacsave_created_t>(),
        24usize,
        concat!("Size of: ", stringify!(_alpm_event_pacsave_created_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_alpm_event_pacsave_created_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_alpm_event_pacsave_created_t))
    );
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_event_pacsave_created_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_event_pacsave_created_t),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
    fn test_field_oldpkg() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_event_pacsave_created_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).oldpkg) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_event_pacsave_created_t),
                "::",
                stringify!(oldpkg)
            )
        );
    }
    test_field_oldpkg();
    fn test_field_file() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_event_pacsave_created_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).file) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_event_pacsave_created_t),
                "::",
                stringify!(file)
            )
        );
    }
    test_field_file();
}
#[doc = " A pacsave file was created."]
pub type alpm_event_pacsave_created_t = _alpm_event_pacsave_created_t;
#[repr(u32)]
#[doc = " Kind of hook."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _alpm_hook_when_t {
    ALPM_HOOK_PRE_TRANSACTION = 1,
    ALPM_HOOK_POST_TRANSACTION = 2,
}
#[doc = " Kind of hook."]
pub use self::_alpm_hook_when_t as alpm_hook_when_t;
#[doc = " pre/post transaction hooks are to be ran."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _alpm_event_hook_t {
    #[doc = " Type of event"]
    pub type_: alpm_event_type_t,
    #[doc = " Type of hook"]
    pub when: alpm_hook_when_t,
}
#[test]
fn bindgen_test_layout__alpm_event_hook_t() {
    assert_eq!(
        ::std::mem::size_of::<_alpm_event_hook_t>(),
        8usize,
        concat!("Size of: ", stringify!(_alpm_event_hook_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_alpm_event_hook_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_alpm_event_hook_t))
    );
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_event_hook_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_event_hook_t),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
    fn test_field_when() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_event_hook_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).when) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_event_hook_t),
                "::",
                stringify!(when)
            )
        );
    }
    test_field_when();
}
#[doc = " pre/post transaction hooks are to be ran."]
pub type alpm_event_hook_t = _alpm_event_hook_t;
#[doc = " A pre/post transaction hook was ran."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _alpm_event_hook_run_t {
    #[doc = " Type of event"]
    pub type_: alpm_event_type_t,
    #[doc = " Name of hook"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = " Description of hook to be outputted"]
    pub desc: *const ::std::os::raw::c_char,
    #[doc = " position of hook being run"]
    pub position: usize,
    #[doc = " total hooks being run"]
    pub total: usize,
}
#[test]
fn bindgen_test_layout__alpm_event_hook_run_t() {
    assert_eq!(
        ::std::mem::size_of::<_alpm_event_hook_run_t>(),
        40usize,
        concat!("Size of: ", stringify!(_alpm_event_hook_run_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_alpm_event_hook_run_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_alpm_event_hook_run_t))
    );
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_event_hook_run_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_event_hook_run_t),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
    fn test_field_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_event_hook_run_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_event_hook_run_t),
                "::",
                stringify!(name)
            )
        );
    }
    test_field_name();
    fn test_field_desc() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_event_hook_run_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).desc) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_event_hook_run_t),
                "::",
                stringify!(desc)
            )
        );
    }
    test_field_desc();
    fn test_field_position() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_event_hook_run_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).position) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_event_hook_run_t),
                "::",
                stringify!(position)
            )
        );
    }
    test_field_position();
    fn test_field_total() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_event_hook_run_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).total) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_event_hook_run_t),
                "::",
                stringify!(total)
            )
        );
    }
    test_field_total();
}
#[doc = " A pre/post transaction hook was ran."]
pub type alpm_event_hook_run_t = _alpm_event_hook_run_t;
#[doc = " Packages downloading about to start."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _alpm_event_pkg_retrieve_t {
    #[doc = " Type of event"]
    pub type_: alpm_event_type_t,
    #[doc = " Number of packages to download"]
    pub num: usize,
    #[doc = " Total size of packages to download"]
    pub total_size: off_t,
}
#[test]
fn bindgen_test_layout__alpm_event_pkg_retrieve_t() {
    assert_eq!(
        ::std::mem::size_of::<_alpm_event_pkg_retrieve_t>(),
        24usize,
        concat!("Size of: ", stringify!(_alpm_event_pkg_retrieve_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_alpm_event_pkg_retrieve_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_alpm_event_pkg_retrieve_t))
    );
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_event_pkg_retrieve_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_event_pkg_retrieve_t),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
    fn test_field_num() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_event_pkg_retrieve_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).num) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_event_pkg_retrieve_t),
                "::",
                stringify!(num)
            )
        );
    }
    test_field_num();
    fn test_field_total_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_event_pkg_retrieve_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).total_size) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_event_pkg_retrieve_t),
                "::",
                stringify!(total_size)
            )
        );
    }
    test_field_total_size();
}
#[doc = " Packages downloading about to start."]
pub type alpm_event_pkg_retrieve_t = _alpm_event_pkg_retrieve_t;
#[doc = " Events."]
#[doc = " This is a union passed to the callback that allows the frontend to know"]
#[doc = " which type of event was triggered (via type). It is then possible to"]
#[doc = " typecast the pointer to the right structure, or use the union field, in order"]
#[doc = " to access event-specific data."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _alpm_event_t {
    #[doc = " Type of event it's always safe to access this."]
    pub type_: alpm_event_type_t,
    #[doc = " The any event type. It's always safe to access this."]
    pub any: alpm_event_any_t,
    #[doc = " Package operation"]
    pub package_operation: alpm_event_package_operation_t,
    #[doc = " An optdept was remove"]
    pub optdep_removal: alpm_event_optdep_removal_t,
    #[doc = " A scriptlet was ran"]
    pub scriptlet_info: alpm_event_scriptlet_info_t,
    #[doc = " A database is missing"]
    pub database_missing: alpm_event_database_missing_t,
    #[doc = " A package was downloaded"]
    pub pkgdownload: alpm_event_pkgdownload_t,
    #[doc = " A pacnew file was created"]
    pub pacnew_created: alpm_event_pacnew_created_t,
    #[doc = " A pacsave file was created"]
    pub pacsave_created: alpm_event_pacsave_created_t,
    #[doc = " Pre/post transaction hooks are being ran"]
    pub hook: alpm_event_hook_t,
    #[doc = " A hook was ran"]
    pub hook_run: alpm_event_hook_run_t,
    #[doc = " Download packages"]
    pub pkg_retrieve: alpm_event_pkg_retrieve_t,
}
#[test]
fn bindgen_test_layout__alpm_event_t() {
    assert_eq!(
        ::std::mem::size_of::<_alpm_event_t>(),
        40usize,
        concat!("Size of: ", stringify!(_alpm_event_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_alpm_event_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_alpm_event_t))
    );
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_event_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_event_t),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
    fn test_field_any() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_event_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).any) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_event_t),
                "::",
                stringify!(any)
            )
        );
    }
    test_field_any();
    fn test_field_package_operation() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_event_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).package_operation) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_event_t),
                "::",
                stringify!(package_operation)
            )
        );
    }
    test_field_package_operation();
    fn test_field_optdep_removal() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_event_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).optdep_removal) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_event_t),
                "::",
                stringify!(optdep_removal)
            )
        );
    }
    test_field_optdep_removal();
    fn test_field_scriptlet_info() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_event_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).scriptlet_info) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_event_t),
                "::",
                stringify!(scriptlet_info)
            )
        );
    }
    test_field_scriptlet_info();
    fn test_field_database_missing() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_event_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).database_missing) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_event_t),
                "::",
                stringify!(database_missing)
            )
        );
    }
    test_field_database_missing();
    fn test_field_pkgdownload() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_event_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pkgdownload) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_event_t),
                "::",
                stringify!(pkgdownload)
            )
        );
    }
    test_field_pkgdownload();
    fn test_field_pacnew_created() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_event_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pacnew_created) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_event_t),
                "::",
                stringify!(pacnew_created)
            )
        );
    }
    test_field_pacnew_created();
    fn test_field_pacsave_created() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_event_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pacsave_created) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_event_t),
                "::",
                stringify!(pacsave_created)
            )
        );
    }
    test_field_pacsave_created();
    fn test_field_hook() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_event_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).hook) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_event_t),
                "::",
                stringify!(hook)
            )
        );
    }
    test_field_hook();
    fn test_field_hook_run() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_event_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).hook_run) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_event_t),
                "::",
                stringify!(hook_run)
            )
        );
    }
    test_field_hook_run();
    fn test_field_pkg_retrieve() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_event_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pkg_retrieve) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_event_t),
                "::",
                stringify!(pkg_retrieve)
            )
        );
    }
    test_field_pkg_retrieve();
}
#[doc = " Events."]
#[doc = " This is a union passed to the callback that allows the frontend to know"]
#[doc = " which type of event was triggered (via type). It is then possible to"]
#[doc = " typecast the pointer to the right structure, or use the union field, in order"]
#[doc = " to access event-specific data."]
pub type alpm_event_t = _alpm_event_t;
#[doc = " Event callback."]
#[doc = ""]
#[doc = " Called when an event occurs"]
#[doc = " @param ctx user-provided context"]
#[doc = " @param event the event that occurred"]
pub type alpm_cb_event = ::std::option::Option<
    unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void, arg1: *mut alpm_event_t),
>;
pub mod _alpm_question_type_t {
    #[doc = " Type of question."]
    #[doc = " Unlike the events or progress enumerations, this enum has bitmask values"]
    #[doc = " so a frontend can use a bitmask map to supply preselected answers to the"]
    #[doc = " different types of questions."]
    pub type Type = ::std::os::raw::c_uint;
    #[doc = " Should target in ignorepkg be installed anyway?"]
    pub const ALPM_QUESTION_INSTALL_IGNOREPKG: Type = 1;
    #[doc = " Should a package be replaced?"]
    pub const ALPM_QUESTION_REPLACE_PKG: Type = 2;
    #[doc = " Should a conflicting package be removed?"]
    pub const ALPM_QUESTION_CONFLICT_PKG: Type = 4;
    #[doc = " Should a corrupted package be deleted?"]
    pub const ALPM_QUESTION_CORRUPTED_PKG: Type = 8;
    #[doc = " Should unresolvable targets be removed from the transaction?"]
    pub const ALPM_QUESTION_REMOVE_PKGS: Type = 16;
    #[doc = " Provider selection"]
    pub const ALPM_QUESTION_SELECT_PROVIDER: Type = 32;
    #[doc = " Should a key be imported?"]
    pub const ALPM_QUESTION_IMPORT_KEY: Type = 64;
}
#[doc = " Type of question."]
#[doc = " Unlike the events or progress enumerations, this enum has bitmask values"]
#[doc = " so a frontend can use a bitmask map to supply preselected answers to the"]
#[doc = " different types of questions."]
pub use self::_alpm_question_type_t::Type as alpm_question_type_t;
#[doc = " A question that can represent any other question."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _alpm_question_any_t {
    #[doc = " Type of question"]
    pub type_: alpm_question_type_t,
    #[doc = " Answer"]
    pub answer: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__alpm_question_any_t() {
    assert_eq!(
        ::std::mem::size_of::<_alpm_question_any_t>(),
        8usize,
        concat!("Size of: ", stringify!(_alpm_question_any_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_alpm_question_any_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_alpm_question_any_t))
    );
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_question_any_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_question_any_t),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
    fn test_field_answer() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_question_any_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).answer) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_question_any_t),
                "::",
                stringify!(answer)
            )
        );
    }
    test_field_answer();
}
#[doc = " A question that can represent any other question."]
pub type alpm_question_any_t = _alpm_question_any_t;
#[doc = " Should target in ignorepkg be installed anyway?"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _alpm_question_install_ignorepkg_t {
    #[doc = " Type of question"]
    pub type_: alpm_question_type_t,
    #[doc = " Answer: whether or not to install pkg anyway"]
    pub install: ::std::os::raw::c_int,
    #[doc = " The ignored package that we are deciding whether to install"]
    pub pkg: *mut alpm_pkg_t,
}
#[test]
fn bindgen_test_layout__alpm_question_install_ignorepkg_t() {
    assert_eq!(
        ::std::mem::size_of::<_alpm_question_install_ignorepkg_t>(),
        16usize,
        concat!("Size of: ", stringify!(_alpm_question_install_ignorepkg_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_alpm_question_install_ignorepkg_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_alpm_question_install_ignorepkg_t)
        )
    );
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_alpm_question_install_ignorepkg_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_question_install_ignorepkg_t),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
    fn test_field_install() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_alpm_question_install_ignorepkg_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).install) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_question_install_ignorepkg_t),
                "::",
                stringify!(install)
            )
        );
    }
    test_field_install();
    fn test_field_pkg() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_alpm_question_install_ignorepkg_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pkg) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_question_install_ignorepkg_t),
                "::",
                stringify!(pkg)
            )
        );
    }
    test_field_pkg();
}
#[doc = " Should target in ignorepkg be installed anyway?"]
pub type alpm_question_install_ignorepkg_t = _alpm_question_install_ignorepkg_t;
#[doc = " Should a package be replaced?"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _alpm_question_replace_t {
    #[doc = " Type of question"]
    pub type_: alpm_question_type_t,
    #[doc = " Answer: whether or not to replace oldpkg with newpkg"]
    pub replace: ::std::os::raw::c_int,
    #[doc = " Package to be replaced"]
    pub oldpkg: *mut alpm_pkg_t,
    #[doc = " Package to replace with."]
    pub newpkg: *mut alpm_pkg_t,
    #[doc = " DB of newpkg"]
    pub newdb: *mut alpm_db_t,
}
#[test]
fn bindgen_test_layout__alpm_question_replace_t() {
    assert_eq!(
        ::std::mem::size_of::<_alpm_question_replace_t>(),
        32usize,
        concat!("Size of: ", stringify!(_alpm_question_replace_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_alpm_question_replace_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_alpm_question_replace_t))
    );
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_question_replace_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_question_replace_t),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
    fn test_field_replace() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_question_replace_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).replace) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_question_replace_t),
                "::",
                stringify!(replace)
            )
        );
    }
    test_field_replace();
    fn test_field_oldpkg() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_question_replace_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).oldpkg) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_question_replace_t),
                "::",
                stringify!(oldpkg)
            )
        );
    }
    test_field_oldpkg();
    fn test_field_newpkg() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_question_replace_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).newpkg) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_question_replace_t),
                "::",
                stringify!(newpkg)
            )
        );
    }
    test_field_newpkg();
    fn test_field_newdb() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_question_replace_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).newdb) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_question_replace_t),
                "::",
                stringify!(newdb)
            )
        );
    }
    test_field_newdb();
}
#[doc = " Should a package be replaced?"]
pub type alpm_question_replace_t = _alpm_question_replace_t;
#[doc = " Should a conflicting package be removed?"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _alpm_question_conflict_t {
    #[doc = " Type of question"]
    pub type_: alpm_question_type_t,
    #[doc = " Answer: whether or not to remove conflict->package2"]
    pub remove: ::std::os::raw::c_int,
    #[doc = " Conflict info"]
    pub conflict: *mut alpm_conflict_t,
}
#[test]
fn bindgen_test_layout__alpm_question_conflict_t() {
    assert_eq!(
        ::std::mem::size_of::<_alpm_question_conflict_t>(),
        16usize,
        concat!("Size of: ", stringify!(_alpm_question_conflict_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_alpm_question_conflict_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_alpm_question_conflict_t))
    );
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_question_conflict_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_question_conflict_t),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
    fn test_field_remove() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_question_conflict_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).remove) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_question_conflict_t),
                "::",
                stringify!(remove)
            )
        );
    }
    test_field_remove();
    fn test_field_conflict() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_question_conflict_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).conflict) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_question_conflict_t),
                "::",
                stringify!(conflict)
            )
        );
    }
    test_field_conflict();
}
#[doc = " Should a conflicting package be removed?"]
pub type alpm_question_conflict_t = _alpm_question_conflict_t;
#[doc = " Should a corrupted package be deleted?"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _alpm_question_corrupted_t {
    #[doc = " Type of question"]
    pub type_: alpm_question_type_t,
    #[doc = " Answer: whether or not to remove filepath"]
    pub remove: ::std::os::raw::c_int,
    #[doc = " File to remove"]
    pub filepath: *const ::std::os::raw::c_char,
    #[doc = " Error code indicating the reason for package invalidity"]
    pub reason: alpm_errno_t,
}
#[test]
fn bindgen_test_layout__alpm_question_corrupted_t() {
    assert_eq!(
        ::std::mem::size_of::<_alpm_question_corrupted_t>(),
        24usize,
        concat!("Size of: ", stringify!(_alpm_question_corrupted_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_alpm_question_corrupted_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_alpm_question_corrupted_t))
    );
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_question_corrupted_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_question_corrupted_t),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
    fn test_field_remove() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_question_corrupted_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).remove) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_question_corrupted_t),
                "::",
                stringify!(remove)
            )
        );
    }
    test_field_remove();
    fn test_field_filepath() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_question_corrupted_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).filepath) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_question_corrupted_t),
                "::",
                stringify!(filepath)
            )
        );
    }
    test_field_filepath();
    fn test_field_reason() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_question_corrupted_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reason) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_question_corrupted_t),
                "::",
                stringify!(reason)
            )
        );
    }
    test_field_reason();
}
#[doc = " Should a corrupted package be deleted?"]
pub type alpm_question_corrupted_t = _alpm_question_corrupted_t;
#[doc = " Should unresolvable targets be removed from the transaction?"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _alpm_question_remove_pkgs_t {
    #[doc = " Type of question"]
    pub type_: alpm_question_type_t,
    #[doc = " Answer: whether or not to skip packages"]
    pub skip: ::std::os::raw::c_int,
    #[doc = " List of alpm_pkg_t* with unresolved dependencies"]
    pub packages: *mut alpm_list_t,
}
#[test]
fn bindgen_test_layout__alpm_question_remove_pkgs_t() {
    assert_eq!(
        ::std::mem::size_of::<_alpm_question_remove_pkgs_t>(),
        16usize,
        concat!("Size of: ", stringify!(_alpm_question_remove_pkgs_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_alpm_question_remove_pkgs_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_alpm_question_remove_pkgs_t))
    );
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_question_remove_pkgs_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_question_remove_pkgs_t),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
    fn test_field_skip() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_question_remove_pkgs_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).skip) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_question_remove_pkgs_t),
                "::",
                stringify!(skip)
            )
        );
    }
    test_field_skip();
    fn test_field_packages() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_question_remove_pkgs_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).packages) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_question_remove_pkgs_t),
                "::",
                stringify!(packages)
            )
        );
    }
    test_field_packages();
}
#[doc = " Should unresolvable targets be removed from the transaction?"]
pub type alpm_question_remove_pkgs_t = _alpm_question_remove_pkgs_t;
#[doc = " Provider selection"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _alpm_question_select_provider_t {
    #[doc = " Type of question"]
    pub type_: alpm_question_type_t,
    #[doc = " Answer: which provider to use (index from providers)"]
    pub use_index: ::std::os::raw::c_int,
    #[doc = " List of alpm_pkg_t* as possible providers"]
    pub providers: *mut alpm_list_t,
    #[doc = " What providers provide for"]
    pub depend: *mut alpm_depend_t,
}
#[test]
fn bindgen_test_layout__alpm_question_select_provider_t() {
    assert_eq!(
        ::std::mem::size_of::<_alpm_question_select_provider_t>(),
        24usize,
        concat!("Size of: ", stringify!(_alpm_question_select_provider_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_alpm_question_select_provider_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_alpm_question_select_provider_t)
        )
    );
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_question_select_provider_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_question_select_provider_t),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
    fn test_field_use_index() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_question_select_provider_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).use_index) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_question_select_provider_t),
                "::",
                stringify!(use_index)
            )
        );
    }
    test_field_use_index();
    fn test_field_providers() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_question_select_provider_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).providers) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_question_select_provider_t),
                "::",
                stringify!(providers)
            )
        );
    }
    test_field_providers();
    fn test_field_depend() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_question_select_provider_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).depend) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_question_select_provider_t),
                "::",
                stringify!(depend)
            )
        );
    }
    test_field_depend();
}
#[doc = " Provider selection"]
pub type alpm_question_select_provider_t = _alpm_question_select_provider_t;
#[doc = " Should a key be imported?"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _alpm_question_import_key_t {
    #[doc = " Type of question"]
    pub type_: alpm_question_type_t,
    #[doc = " Answer: whether or not to import key"]
    pub import: ::std::os::raw::c_int,
    #[doc = " The key to import"]
    pub key: *mut alpm_pgpkey_t,
}
#[test]
fn bindgen_test_layout__alpm_question_import_key_t() {
    assert_eq!(
        ::std::mem::size_of::<_alpm_question_import_key_t>(),
        16usize,
        concat!("Size of: ", stringify!(_alpm_question_import_key_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_alpm_question_import_key_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_alpm_question_import_key_t))
    );
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_question_import_key_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_question_import_key_t),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
    fn test_field_import() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_question_import_key_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).import) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_question_import_key_t),
                "::",
                stringify!(import)
            )
        );
    }
    test_field_import();
    fn test_field_key() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_question_import_key_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).key) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_question_import_key_t),
                "::",
                stringify!(key)
            )
        );
    }
    test_field_key();
}
#[doc = " Should a key be imported?"]
pub type alpm_question_import_key_t = _alpm_question_import_key_t;
#[doc = " Questions."]
#[doc = " This is an union passed to the callback that allows the frontend to know"]
#[doc = " which type of question was triggered (via type). It is then possible to"]
#[doc = " typecast the pointer to the right structure, or use the union field, in order"]
#[doc = " to access question-specific data."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _alpm_question_t {
    #[doc = " The type of question. It's always safe to access this."]
    pub type_: alpm_question_type_t,
    #[doc = " A question that can represent any question."]
    #[doc = " It's always safe to access this."]
    pub any: alpm_question_any_t,
    #[doc = " Should target in ignorepkg be installed anyway?"]
    pub install_ignorepkg: alpm_question_install_ignorepkg_t,
    #[doc = " Should a package be replaced?"]
    pub replace: alpm_question_replace_t,
    #[doc = " Should a conflicting package be removed?"]
    pub conflict: alpm_question_conflict_t,
    #[doc = " Should a corrupted package be deleted?"]
    pub corrupted: alpm_question_corrupted_t,
    #[doc = " Should unresolvable targets be removed from the transaction?"]
    pub remove_pkgs: alpm_question_remove_pkgs_t,
    #[doc = " Provider selection"]
    pub select_provider: alpm_question_select_provider_t,
    #[doc = " Should a key be imported?"]
    pub import_key: alpm_question_import_key_t,
}
#[test]
fn bindgen_test_layout__alpm_question_t() {
    assert_eq!(
        ::std::mem::size_of::<_alpm_question_t>(),
        32usize,
        concat!("Size of: ", stringify!(_alpm_question_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_alpm_question_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_alpm_question_t))
    );
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_question_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_question_t),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
    fn test_field_any() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_question_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).any) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_question_t),
                "::",
                stringify!(any)
            )
        );
    }
    test_field_any();
    fn test_field_install_ignorepkg() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_question_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).install_ignorepkg) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_question_t),
                "::",
                stringify!(install_ignorepkg)
            )
        );
    }
    test_field_install_ignorepkg();
    fn test_field_replace() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_question_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).replace) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_question_t),
                "::",
                stringify!(replace)
            )
        );
    }
    test_field_replace();
    fn test_field_conflict() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_question_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).conflict) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_question_t),
                "::",
                stringify!(conflict)
            )
        );
    }
    test_field_conflict();
    fn test_field_corrupted() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_question_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).corrupted) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_question_t),
                "::",
                stringify!(corrupted)
            )
        );
    }
    test_field_corrupted();
    fn test_field_remove_pkgs() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_question_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).remove_pkgs) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_question_t),
                "::",
                stringify!(remove_pkgs)
            )
        );
    }
    test_field_remove_pkgs();
    fn test_field_select_provider() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_question_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).select_provider) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_question_t),
                "::",
                stringify!(select_provider)
            )
        );
    }
    test_field_select_provider();
    fn test_field_import_key() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_question_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).import_key) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_question_t),
                "::",
                stringify!(import_key)
            )
        );
    }
    test_field_import_key();
}
#[doc = " Questions."]
#[doc = " This is an union passed to the callback that allows the frontend to know"]
#[doc = " which type of question was triggered (via type). It is then possible to"]
#[doc = " typecast the pointer to the right structure, or use the union field, in order"]
#[doc = " to access question-specific data."]
pub type alpm_question_t = _alpm_question_t;
#[doc = " Question callback."]
#[doc = ""]
#[doc = " This callback allows user to give input and decide what to do during certain events"]
#[doc = " @param ctx user-provided context"]
#[doc = " @param question the question being asked."]
pub type alpm_cb_question = ::std::option::Option<
    unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void, arg1: *mut alpm_question_t),
>;
#[repr(u32)]
#[doc = " An enum over different kinds of progress alerts."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _alpm_progress_t {
    #[doc = " Package install"]
    ALPM_PROGRESS_ADD_START = 0,
    #[doc = " Package upgrade"]
    ALPM_PROGRESS_UPGRADE_START = 1,
    #[doc = " Package downgrade"]
    ALPM_PROGRESS_DOWNGRADE_START = 2,
    #[doc = " Package reinstall"]
    ALPM_PROGRESS_REINSTALL_START = 3,
    #[doc = " Package removal"]
    ALPM_PROGRESS_REMOVE_START = 4,
    #[doc = " Conflict checking"]
    ALPM_PROGRESS_CONFLICTS_START = 5,
    #[doc = " Diskspace checking"]
    ALPM_PROGRESS_DISKSPACE_START = 6,
    #[doc = " Package Integrity checking"]
    ALPM_PROGRESS_INTEGRITY_START = 7,
    #[doc = " Loading packages from disk"]
    ALPM_PROGRESS_LOAD_START = 8,
    #[doc = " Checking signatures of packages"]
    ALPM_PROGRESS_KEYRING_START = 9,
}
#[doc = " An enum over different kinds of progress alerts."]
pub use self::_alpm_progress_t as alpm_progress_t;
#[doc = " Progress callback"]
#[doc = ""]
#[doc = " Alert the front end about the progress of certain events."]
#[doc = " Allows the implementation of loading bars for events that"]
#[doc = " make take a while to complete."]
#[doc = " @param ctx user-provided context"]
#[doc = " @param progress the kind of event that is progressing"]
#[doc = " @param pkg for package operations, the name of the package being operated on"]
#[doc = " @param percent the percent completion of the action"]
#[doc = " @param howmany the total amount of items in the action"]
#[doc = " @param current the current amount of items completed"]
pub type alpm_cb_progress = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::std::os::raw::c_void,
        progress: alpm_progress_t,
        pkg: *const ::std::os::raw::c_char,
        percent: ::std::os::raw::c_int,
        howmany: usize,
        current: usize,
    ),
>;
#[repr(u32)]
#[doc = " File download events."]
#[doc = " These events are reported by ALPM via download callback."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _alpm_download_event_type_t {
    #[doc = " A download was started"]
    ALPM_DOWNLOAD_INIT = 0,
    #[doc = " A download made progress"]
    ALPM_DOWNLOAD_PROGRESS = 1,
    #[doc = " Download will be retried"]
    ALPM_DOWNLOAD_RETRY = 2,
    #[doc = " A download completed"]
    ALPM_DOWNLOAD_COMPLETED = 3,
}
#[doc = " File download events."]
#[doc = " These events are reported by ALPM via download callback."]
pub use self::_alpm_download_event_type_t as alpm_download_event_type_t;
#[doc = " Context struct for when a download starts."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _alpm_download_event_init_t {
    #[doc = " whether this file is optional and thus the errors could be ignored"]
    pub optional: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__alpm_download_event_init_t() {
    assert_eq!(
        ::std::mem::size_of::<_alpm_download_event_init_t>(),
        4usize,
        concat!("Size of: ", stringify!(_alpm_download_event_init_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_alpm_download_event_init_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_alpm_download_event_init_t))
    );
    fn test_field_optional() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_download_event_init_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).optional) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_download_event_init_t),
                "::",
                stringify!(optional)
            )
        );
    }
    test_field_optional();
}
#[doc = " Context struct for when a download starts."]
pub type alpm_download_event_init_t = _alpm_download_event_init_t;
#[doc = " Context struct for when a download progresses."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _alpm_download_event_progress_t {
    #[doc = " Amount of data downloaded"]
    pub downloaded: off_t,
    #[doc = " Total amount need to be downloaded"]
    pub total: off_t,
}
#[test]
fn bindgen_test_layout__alpm_download_event_progress_t() {
    assert_eq!(
        ::std::mem::size_of::<_alpm_download_event_progress_t>(),
        16usize,
        concat!("Size of: ", stringify!(_alpm_download_event_progress_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_alpm_download_event_progress_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_alpm_download_event_progress_t))
    );
    fn test_field_downloaded() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_download_event_progress_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).downloaded) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_download_event_progress_t),
                "::",
                stringify!(downloaded)
            )
        );
    }
    test_field_downloaded();
    fn test_field_total() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_download_event_progress_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).total) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_download_event_progress_t),
                "::",
                stringify!(total)
            )
        );
    }
    test_field_total();
}
#[doc = " Context struct for when a download progresses."]
pub type alpm_download_event_progress_t = _alpm_download_event_progress_t;
#[doc = " Context struct for when a download retries."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _alpm_download_event_retry_t {
    #[doc = " If the download will resume or start over"]
    pub resume: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__alpm_download_event_retry_t() {
    assert_eq!(
        ::std::mem::size_of::<_alpm_download_event_retry_t>(),
        4usize,
        concat!("Size of: ", stringify!(_alpm_download_event_retry_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_alpm_download_event_retry_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_alpm_download_event_retry_t))
    );
    fn test_field_resume() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_download_event_retry_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).resume) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_download_event_retry_t),
                "::",
                stringify!(resume)
            )
        );
    }
    test_field_resume();
}
#[doc = " Context struct for when a download retries."]
pub type alpm_download_event_retry_t = _alpm_download_event_retry_t;
#[doc = " Context struct for when a download completes."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _alpm_download_event_completed_t {
    #[doc = " Total bytes in file"]
    pub total: off_t,
    #[doc = " download result code:"]
    #[doc = "    0 - download completed successfully"]
    #[doc = "    1 - the file is up-to-date"]
    #[doc = "   -1 - error"]
    pub result: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__alpm_download_event_completed_t() {
    assert_eq!(
        ::std::mem::size_of::<_alpm_download_event_completed_t>(),
        16usize,
        concat!("Size of: ", stringify!(_alpm_download_event_completed_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_alpm_download_event_completed_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_alpm_download_event_completed_t)
        )
    );
    fn test_field_total() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_download_event_completed_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).total) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_download_event_completed_t),
                "::",
                stringify!(total)
            )
        );
    }
    test_field_total();
    fn test_field_result() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_alpm_download_event_completed_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).result) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_alpm_download_event_completed_t),
                "::",
                stringify!(result)
            )
        );
    }
    test_field_result();
}
#[doc = " Context struct for when a download completes."]
pub type alpm_download_event_completed_t = _alpm_download_event_completed_t;
#[doc = " Type of download progress callbacks."]
#[doc = " @param ctx user-provided context"]
#[doc = " @param filename the name of the file being downloaded"]
#[doc = " @param event the event type"]
#[doc = " @param data the event data of type alpm_download_event_*_t"]
pub type alpm_cb_download = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::std::os::raw::c_void,
        filename: *const ::std::os::raw::c_char,
        event: alpm_download_event_type_t,
        data: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " A callback for downloading files"]
#[doc = " @param ctx user-provided context"]
#[doc = " @param url the URL of the file to be downloaded"]
#[doc = " @param localpath the directory to which the file should be downloaded"]
#[doc = " @param force whether to force an update, even if the file is the same"]
#[doc = " @return 0 on success, 1 if the file exists and is identical, -1 on"]
#[doc = " error."]
pub type alpm_cb_fetch = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::std::os::raw::c_void,
        url: *const ::std::os::raw::c_char,
        localpath: *const ::std::os::raw::c_char,
        force: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
pub mod _alpm_db_usage_t {
    #[doc = " The usage level of a database."]
    pub type Type = ::std::os::raw::c_uint;
    #[doc = " Enable refreshes for this database"]
    pub const ALPM_DB_USAGE_SYNC: Type = 1;
    #[doc = " Enable search for this database"]
    pub const ALPM_DB_USAGE_SEARCH: Type = 2;
    #[doc = " Enable installing packages from this database"]
    pub const ALPM_DB_USAGE_INSTALL: Type = 4;
    #[doc = " Enable sysupgrades with this database"]
    pub const ALPM_DB_USAGE_UPGRADE: Type = 8;
    #[doc = " Enable all usage levels"]
    pub const ALPM_DB_USAGE_ALL: Type = 15;
}
#[doc = " The usage level of a database."]
pub use self::_alpm_db_usage_t::Type as alpm_db_usage_t;
pub mod _alpm_loglevel_t {
    #[doc = " Logging Levels"]
    pub type Type = ::std::os::raw::c_uint;
    #[doc = " Error"]
    pub const ALPM_LOG_ERROR: Type = 1;
    #[doc = " Warning"]
    pub const ALPM_LOG_WARNING: Type = 2;
    #[doc = " Debug"]
    pub const ALPM_LOG_DEBUG: Type = 4;
    #[doc = " Function"]
    pub const ALPM_LOG_FUNCTION: Type = 8;
}
#[doc = " Logging Levels"]
pub use self::_alpm_loglevel_t::Type as alpm_loglevel_t;
#[doc = " The callback type for logging."]
#[doc = ""]
#[doc = " libalpm will call this function whenever something is to be logged."]
#[doc = " many libalpm will produce log output. Additionally any calls to \\link alpm_logaction"]
#[doc = " \\endlink will also call this callback."]
#[doc = " @param ctx user-provided context"]
#[doc = " @param level the currently set loglevel"]
#[doc = " @param fmt the printf like format string"]
#[doc = " @param args printf like arguments"]
pub type alpm_cb_log = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::std::os::raw::c_void,
        level: alpm_loglevel_t,
        fmt: *const ::std::os::raw::c_char,
        args: *mut __va_list_tag,
    ),
>;
#[repr(u32)]
#[doc = " Package install reasons."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _alpm_pkgreason_t {
    #[doc = " Explicitly requested by the user."]
    ALPM_PKG_REASON_EXPLICIT = 0,
    #[doc = " Installed as a dependency for another package."]
    ALPM_PKG_REASON_DEPEND = 1,
}
#[doc = " Package install reasons."]
pub use self::_alpm_pkgreason_t as alpm_pkgreason_t;
#[repr(u32)]
#[doc = " Location a package object was loaded from."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _alpm_pkgfrom_t {
    #[doc = " Loaded from a file via \\link alpm_pkg_load \\endlink"]
    ALPM_PKG_FROM_FILE = 1,
    #[doc = " From the local database"]
    ALPM_PKG_FROM_LOCALDB = 2,
    #[doc = " From a sync database"]
    ALPM_PKG_FROM_SYNCDB = 3,
}
#[doc = " Location a package object was loaded from."]
pub use self::_alpm_pkgfrom_t as alpm_pkgfrom_t;
pub mod _alpm_pkgvalidation_t {
    #[doc = " Method used to validate a package."]
    pub type Type = ::std::os::raw::c_uint;
    #[doc = " The package's validation type is unknown"]
    pub const ALPM_PKG_VALIDATION_UNKNOWN: Type = 0;
    #[doc = " The package does not have any validation"]
    pub const ALPM_PKG_VALIDATION_NONE: Type = 1;
    #[doc = " The package is validated with md5"]
    pub const ALPM_PKG_VALIDATION_MD5SUM: Type = 2;
    #[doc = " The package is validated with sha256"]
    pub const ALPM_PKG_VALIDATION_SHA256SUM: Type = 4;
    #[doc = " The package is validated with a PGP signature"]
    pub const ALPM_PKG_VALIDATION_SIGNATURE: Type = 8;
}
#[doc = " Method used to validate a package."]
pub use self::_alpm_pkgvalidation_t::Type as alpm_pkgvalidation_t;
pub mod _alpm_transflag_t {
    #[doc = " Transaction flags"]
    pub type Type = ::std::os::raw::c_uint;
    #[doc = " Ignore dependency checks."]
    pub const ALPM_TRANS_FLAG_NODEPS: Type = 1;
    #[doc = " Delete files even if they are tagged as backup."]
    pub const ALPM_TRANS_FLAG_NOSAVE: Type = 4;
    #[doc = " Ignore version numbers when checking dependencies."]
    pub const ALPM_TRANS_FLAG_NODEPVERSION: Type = 8;
    #[doc = " Remove also any packages depending on a package being removed."]
    pub const ALPM_TRANS_FLAG_CASCADE: Type = 16;
    #[doc = " Remove packages and their unneeded deps (not explicitly installed)."]
    pub const ALPM_TRANS_FLAG_RECURSE: Type = 32;
    #[doc = " Modify database but do not commit changes to the filesystem."]
    pub const ALPM_TRANS_FLAG_DBONLY: Type = 64;
    #[doc = " Use ALPM_PKG_REASON_DEPEND when installing packages."]
    pub const ALPM_TRANS_FLAG_ALLDEPS: Type = 256;
    #[doc = " Only download packages and do not actually install."]
    pub const ALPM_TRANS_FLAG_DOWNLOADONLY: Type = 512;
    #[doc = " Do not execute install scriptlets after installing."]
    pub const ALPM_TRANS_FLAG_NOSCRIPTLET: Type = 1024;
    #[doc = " Ignore dependency conflicts."]
    pub const ALPM_TRANS_FLAG_NOCONFLICTS: Type = 2048;
    #[doc = " Do not install a package if it is already installed and up to date."]
    pub const ALPM_TRANS_FLAG_NEEDED: Type = 8192;
    #[doc = " Use ALPM_PKG_REASON_EXPLICIT when installing packages."]
    pub const ALPM_TRANS_FLAG_ALLEXPLICIT: Type = 16384;
    #[doc = " Do not remove a package if it is needed by another one."]
    pub const ALPM_TRANS_FLAG_UNNEEDED: Type = 32768;
    #[doc = " Remove also explicitly installed unneeded deps (use with ALPM_TRANS_FLAG_RECURSE)."]
    pub const ALPM_TRANS_FLAG_RECURSEALL: Type = 65536;
    #[doc = " Do not lock the database during the operation."]
    pub const ALPM_TRANS_FLAG_NOLOCK: Type = 131072;
}
#[doc = " Transaction flags"]
pub use self::_alpm_transflag_t::Type as alpm_transflag_t;
pub mod alpm_caps {
    #[doc = " Enum of possible compile time features"]
    pub type Type = ::std::os::raw::c_uint;
    #[doc = " localization"]
    pub const ALPM_CAPABILITY_NLS: Type = 1;
    #[doc = " Ability to download"]
    pub const ALPM_CAPABILITY_DOWNLOADER: Type = 2;
    #[doc = " Signature checking"]
    pub const ALPM_CAPABILITY_SIGNATURES: Type = 4;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    fn test_field_gp_offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__va_list_tag>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).gp_offset) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__va_list_tag),
                "::",
                stringify!(gp_offset)
            )
        );
    }
    test_field_gp_offset();
    fn test_field_fp_offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__va_list_tag>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fp_offset) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(__va_list_tag),
                "::",
                stringify!(fp_offset)
            )
        );
    }
    test_field_fp_offset();
    fn test_field_overflow_arg_area() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__va_list_tag>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).overflow_arg_area) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(__va_list_tag),
                "::",
                stringify!(overflow_arg_area)
            )
        );
    }
    test_field_overflow_arg_area();
    fn test_field_reg_save_area() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__va_list_tag>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reg_save_area) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(__va_list_tag),
                "::",
                stringify!(reg_save_area)
            )
        );
    }
    test_field_reg_save_area();
}
extern crate libloading;
pub struct libalpm {
    __library: ::libloading::Library,
    pub alpm_list_free: unsafe extern "C" fn(list: *mut alpm_list_t),
    pub alpm_list_free_inner: unsafe extern "C" fn(list: *mut alpm_list_t, fn_: alpm_list_fn_free),
    pub alpm_list_add: unsafe extern "C" fn(
        list: *mut alpm_list_t,
        data: *mut ::std::os::raw::c_void,
    ) -> *mut alpm_list_t,
    pub alpm_list_append: unsafe extern "C" fn(
        list: *mut *mut alpm_list_t,
        data: *mut ::std::os::raw::c_void,
    ) -> *mut alpm_list_t,
    pub alpm_list_append_strdup: unsafe extern "C" fn(
        list: *mut *mut alpm_list_t,
        data: *const ::std::os::raw::c_char,
    ) -> *mut alpm_list_t,
    pub alpm_list_add_sorted: unsafe extern "C" fn(
        list: *mut alpm_list_t,
        data: *mut ::std::os::raw::c_void,
        fn_: alpm_list_fn_cmp,
    ) -> *mut alpm_list_t,
    pub alpm_list_join:
        unsafe extern "C" fn(first: *mut alpm_list_t, second: *mut alpm_list_t) -> *mut alpm_list_t,
    pub alpm_list_mmerge: unsafe extern "C" fn(
        left: *mut alpm_list_t,
        right: *mut alpm_list_t,
        fn_: alpm_list_fn_cmp,
    ) -> *mut alpm_list_t,
    pub alpm_list_msort: unsafe extern "C" fn(
        list: *mut alpm_list_t,
        n: usize,
        fn_: alpm_list_fn_cmp,
    ) -> *mut alpm_list_t,
    pub alpm_list_remove_item: unsafe extern "C" fn(
        haystack: *mut alpm_list_t,
        item: *mut alpm_list_t,
    ) -> *mut alpm_list_t,
    pub alpm_list_remove: unsafe extern "C" fn(
        haystack: *mut alpm_list_t,
        needle: *const ::std::os::raw::c_void,
        fn_: alpm_list_fn_cmp,
        data: *mut *mut ::std::os::raw::c_void,
    ) -> *mut alpm_list_t,
    pub alpm_list_remove_str: unsafe extern "C" fn(
        haystack: *mut alpm_list_t,
        needle: *const ::std::os::raw::c_char,
        data: *mut *mut ::std::os::raw::c_char,
    ) -> *mut alpm_list_t,
    pub alpm_list_remove_dupes: unsafe extern "C" fn(list: *const alpm_list_t) -> *mut alpm_list_t,
    pub alpm_list_strdup: unsafe extern "C" fn(list: *const alpm_list_t) -> *mut alpm_list_t,
    pub alpm_list_copy: unsafe extern "C" fn(list: *const alpm_list_t) -> *mut alpm_list_t,
    pub alpm_list_copy_data:
        unsafe extern "C" fn(list: *const alpm_list_t, size: usize) -> *mut alpm_list_t,
    pub alpm_list_reverse: unsafe extern "C" fn(list: *mut alpm_list_t) -> *mut alpm_list_t,
    pub alpm_list_nth: unsafe extern "C" fn(list: *const alpm_list_t, n: usize) -> *mut alpm_list_t,
    pub alpm_list_next: unsafe extern "C" fn(list: *const alpm_list_t) -> *mut alpm_list_t,
    pub alpm_list_previous: unsafe extern "C" fn(list: *const alpm_list_t) -> *mut alpm_list_t,
    pub alpm_list_last: unsafe extern "C" fn(list: *const alpm_list_t) -> *mut alpm_list_t,
    pub alpm_list_count: unsafe extern "C" fn(list: *const alpm_list_t) -> usize,
    pub alpm_list_find: unsafe extern "C" fn(
        haystack: *const alpm_list_t,
        needle: *const ::std::os::raw::c_void,
        fn_: alpm_list_fn_cmp,
    ) -> *mut ::std::os::raw::c_void,
    pub alpm_list_find_ptr: unsafe extern "C" fn(
        haystack: *const alpm_list_t,
        needle: *const ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void,
    pub alpm_list_find_str: unsafe extern "C" fn(
        haystack: *const alpm_list_t,
        needle: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char,
    pub alpm_list_diff_sorted: unsafe extern "C" fn(
        left: *const alpm_list_t,
        right: *const alpm_list_t,
        fn_: alpm_list_fn_cmp,
        onlyleft: *mut *mut alpm_list_t,
        onlyright: *mut *mut alpm_list_t,
    ),
    pub alpm_list_diff: unsafe extern "C" fn(
        lhs: *const alpm_list_t,
        rhs: *const alpm_list_t,
        fn_: alpm_list_fn_cmp,
    ) -> *mut alpm_list_t,
    pub alpm_list_to_array: unsafe extern "C" fn(
        list: *const alpm_list_t,
        n: usize,
        size: usize,
    ) -> *mut ::std::os::raw::c_void,
    pub alpm_filelist_contains: unsafe extern "C" fn(
        filelist: *mut alpm_filelist_t,
        path: *const ::std::os::raw::c_char,
    ) -> *mut alpm_file_t,
    pub alpm_find_group_pkgs: unsafe extern "C" fn(
        dbs: *mut alpm_list_t,
        name: *const ::std::os::raw::c_char,
    ) -> *mut alpm_list_t,
    pub alpm_errno: unsafe extern "C" fn(handle: *mut alpm_handle_t) -> alpm_errno_t,
    pub alpm_strerror: unsafe extern "C" fn(err: alpm_errno_t) -> *const ::std::os::raw::c_char,
    pub alpm_initialize: unsafe extern "C" fn(
        root: *const ::std::os::raw::c_char,
        dbpath: *const ::std::os::raw::c_char,
        err: *mut alpm_errno_t,
    ) -> *mut alpm_handle_t,
    pub alpm_release: unsafe extern "C" fn(handle: *mut alpm_handle_t) -> ::std::os::raw::c_int,
    pub alpm_pkg_check_pgp_signature: unsafe extern "C" fn(
        pkg: *mut alpm_pkg_t,
        siglist: *mut alpm_siglist_t,
    ) -> ::std::os::raw::c_int,
    pub alpm_db_check_pgp_signature: unsafe extern "C" fn(
        db: *mut alpm_db_t,
        siglist: *mut alpm_siglist_t,
    ) -> ::std::os::raw::c_int,
    pub alpm_siglist_cleanup:
        unsafe extern "C" fn(siglist: *mut alpm_siglist_t) -> ::std::os::raw::c_int,
    pub alpm_decode_signature: unsafe extern "C" fn(
        base64_data: *const ::std::os::raw::c_char,
        data: *mut *mut ::std::os::raw::c_uchar,
        data_len: *mut usize,
    ) -> ::std::os::raw::c_int,
    pub alpm_extract_keyid: unsafe extern "C" fn(
        handle: *mut alpm_handle_t,
        identifier: *const ::std::os::raw::c_char,
        sig: *const ::std::os::raw::c_uchar,
        len: usize,
        keys: *mut *mut alpm_list_t,
    ) -> ::std::os::raw::c_int,
    pub alpm_checkdeps: unsafe extern "C" fn(
        handle: *mut alpm_handle_t,
        pkglist: *mut alpm_list_t,
        remove: *mut alpm_list_t,
        upgrade: *mut alpm_list_t,
        reversedeps: ::std::os::raw::c_int,
    ) -> *mut alpm_list_t,
    pub alpm_find_satisfier: unsafe extern "C" fn(
        pkgs: *mut alpm_list_t,
        depstring: *const ::std::os::raw::c_char,
    ) -> *mut alpm_pkg_t,
    pub alpm_find_dbs_satisfier: unsafe extern "C" fn(
        handle: *mut alpm_handle_t,
        dbs: *mut alpm_list_t,
        depstring: *const ::std::os::raw::c_char,
    ) -> *mut alpm_pkg_t,
    pub alpm_checkconflicts: unsafe extern "C" fn(
        handle: *mut alpm_handle_t,
        pkglist: *mut alpm_list_t,
    ) -> *mut alpm_list_t,
    pub alpm_dep_compute_string:
        unsafe extern "C" fn(dep: *const alpm_depend_t) -> *mut ::std::os::raw::c_char,
    pub alpm_dep_from_string:
        unsafe extern "C" fn(depstring: *const ::std::os::raw::c_char) -> *mut alpm_depend_t,
    pub alpm_dep_free: unsafe extern "C" fn(dep: *mut alpm_depend_t),
    pub alpm_fileconflict_free: unsafe extern "C" fn(conflict: *mut alpm_fileconflict_t),
    pub alpm_depmissing_free: unsafe extern "C" fn(miss: *mut alpm_depmissing_t),
    pub alpm_conflict_free: unsafe extern "C" fn(conflict: *mut alpm_conflict_t),
    pub alpm_get_localdb: unsafe extern "C" fn(handle: *mut alpm_handle_t) -> *mut alpm_db_t,
    pub alpm_get_syncdbs: unsafe extern "C" fn(handle: *mut alpm_handle_t) -> *mut alpm_list_t,
    pub alpm_register_syncdb: unsafe extern "C" fn(
        handle: *mut alpm_handle_t,
        treename: *const ::std::os::raw::c_char,
        level: ::std::os::raw::c_int,
    ) -> *mut alpm_db_t,
    pub alpm_unregister_all_syncdbs:
        unsafe extern "C" fn(handle: *mut alpm_handle_t) -> ::std::os::raw::c_int,
    pub alpm_db_unregister: unsafe extern "C" fn(db: *mut alpm_db_t) -> ::std::os::raw::c_int,
    pub alpm_db_get_name:
        unsafe extern "C" fn(db: *const alpm_db_t) -> *const ::std::os::raw::c_char,
    pub alpm_db_get_siglevel: unsafe extern "C" fn(db: *mut alpm_db_t) -> ::std::os::raw::c_int,
    pub alpm_db_get_valid: unsafe extern "C" fn(db: *mut alpm_db_t) -> ::std::os::raw::c_int,
    pub alpm_db_get_servers: unsafe extern "C" fn(db: *const alpm_db_t) -> *mut alpm_list_t,
    pub alpm_db_set_servers: unsafe extern "C" fn(
        db: *mut alpm_db_t,
        servers: *mut alpm_list_t,
    ) -> ::std::os::raw::c_int,
    pub alpm_db_add_server: unsafe extern "C" fn(
        db: *mut alpm_db_t,
        url: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int,
    pub alpm_db_remove_server: unsafe extern "C" fn(
        db: *mut alpm_db_t,
        url: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int,
    pub alpm_db_update: unsafe extern "C" fn(
        handle: *mut alpm_handle_t,
        dbs: *mut alpm_list_t,
        force: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
    pub alpm_db_get_pkg: unsafe extern "C" fn(
        db: *mut alpm_db_t,
        name: *const ::std::os::raw::c_char,
    ) -> *mut alpm_pkg_t,
    pub alpm_db_get_pkgcache: unsafe extern "C" fn(db: *mut alpm_db_t) -> *mut alpm_list_t,
    pub alpm_db_get_group: unsafe extern "C" fn(
        db: *mut alpm_db_t,
        name: *const ::std::os::raw::c_char,
    ) -> *mut alpm_group_t,
    pub alpm_db_get_groupcache: unsafe extern "C" fn(db: *mut alpm_db_t) -> *mut alpm_list_t,
    pub alpm_db_search: unsafe extern "C" fn(
        db: *mut alpm_db_t,
        needles: *const alpm_list_t,
        ret: *mut *mut alpm_list_t,
    ) -> ::std::os::raw::c_int,
    pub alpm_db_set_usage: unsafe extern "C" fn(
        db: *mut alpm_db_t,
        usage: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
    pub alpm_db_get_usage: unsafe extern "C" fn(
        db: *mut alpm_db_t,
        usage: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
    pub alpm_logaction: unsafe extern "C" fn(
        handle: *mut alpm_handle_t,
        prefix: *const ::std::os::raw::c_char,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int,
    pub alpm_option_get_logcb: unsafe extern "C" fn(handle: *mut alpm_handle_t) -> alpm_cb_log,
    pub alpm_option_get_logcb_ctx:
        unsafe extern "C" fn(handle: *mut alpm_handle_t) -> *mut ::std::os::raw::c_void,
    pub alpm_option_set_logcb: unsafe extern "C" fn(
        handle: *mut alpm_handle_t,
        cb: alpm_cb_log,
        ctx: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
    pub alpm_option_get_dlcb: unsafe extern "C" fn(handle: *mut alpm_handle_t) -> alpm_cb_download,
    pub alpm_option_get_dlcb_ctx:
        unsafe extern "C" fn(handle: *mut alpm_handle_t) -> *mut ::std::os::raw::c_void,
    pub alpm_option_set_dlcb: unsafe extern "C" fn(
        handle: *mut alpm_handle_t,
        cb: alpm_cb_download,
        ctx: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
    pub alpm_option_get_fetchcb: unsafe extern "C" fn(handle: *mut alpm_handle_t) -> alpm_cb_fetch,
    pub alpm_option_get_fetchcb_ctx:
        unsafe extern "C" fn(handle: *mut alpm_handle_t) -> *mut ::std::os::raw::c_void,
    pub alpm_option_set_fetchcb: unsafe extern "C" fn(
        handle: *mut alpm_handle_t,
        cb: alpm_cb_fetch,
        ctx: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
    pub alpm_option_get_eventcb: unsafe extern "C" fn(handle: *mut alpm_handle_t) -> alpm_cb_event,
    pub alpm_option_get_eventcb_ctx:
        unsafe extern "C" fn(handle: *mut alpm_handle_t) -> *mut ::std::os::raw::c_void,
    pub alpm_option_set_eventcb: unsafe extern "C" fn(
        handle: *mut alpm_handle_t,
        cb: alpm_cb_event,
        ctx: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
    pub alpm_option_get_questioncb:
        unsafe extern "C" fn(handle: *mut alpm_handle_t) -> alpm_cb_question,
    pub alpm_option_get_questioncb_ctx:
        unsafe extern "C" fn(handle: *mut alpm_handle_t) -> *mut ::std::os::raw::c_void,
    pub alpm_option_set_questioncb: unsafe extern "C" fn(
        handle: *mut alpm_handle_t,
        cb: alpm_cb_question,
        ctx: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
    pub alpm_option_get_progresscb:
        unsafe extern "C" fn(handle: *mut alpm_handle_t) -> alpm_cb_progress,
    pub alpm_option_get_progresscb_ctx:
        unsafe extern "C" fn(handle: *mut alpm_handle_t) -> *mut ::std::os::raw::c_void,
    pub alpm_option_set_progresscb: unsafe extern "C" fn(
        handle: *mut alpm_handle_t,
        cb: alpm_cb_progress,
        ctx: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
    pub alpm_option_get_root:
        unsafe extern "C" fn(handle: *mut alpm_handle_t) -> *const ::std::os::raw::c_char,
    pub alpm_option_get_dbpath:
        unsafe extern "C" fn(handle: *mut alpm_handle_t) -> *const ::std::os::raw::c_char,
    pub alpm_option_get_lockfile:
        unsafe extern "C" fn(handle: *mut alpm_handle_t) -> *const ::std::os::raw::c_char,
    pub alpm_option_get_cachedirs:
        unsafe extern "C" fn(handle: *mut alpm_handle_t) -> *mut alpm_list_t,
    pub alpm_option_set_cachedirs: unsafe extern "C" fn(
        handle: *mut alpm_handle_t,
        cachedirs: *mut alpm_list_t,
    ) -> ::std::os::raw::c_int,
    pub alpm_option_add_cachedir: unsafe extern "C" fn(
        handle: *mut alpm_handle_t,
        cachedir: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int,
    pub alpm_option_remove_cachedir: unsafe extern "C" fn(
        handle: *mut alpm_handle_t,
        cachedir: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int,
    pub alpm_option_get_hookdirs:
        unsafe extern "C" fn(handle: *mut alpm_handle_t) -> *mut alpm_list_t,
    pub alpm_option_set_hookdirs: unsafe extern "C" fn(
        handle: *mut alpm_handle_t,
        hookdirs: *mut alpm_list_t,
    ) -> ::std::os::raw::c_int,
    pub alpm_option_add_hookdir: unsafe extern "C" fn(
        handle: *mut alpm_handle_t,
        hookdir: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int,
    pub alpm_option_remove_hookdir: unsafe extern "C" fn(
        handle: *mut alpm_handle_t,
        hookdir: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int,
    pub alpm_option_get_overwrite_files:
        unsafe extern "C" fn(handle: *mut alpm_handle_t) -> *mut alpm_list_t,
    pub alpm_option_set_overwrite_files: unsafe extern "C" fn(
        handle: *mut alpm_handle_t,
        globs: *mut alpm_list_t,
    ) -> ::std::os::raw::c_int,
    pub alpm_option_add_overwrite_file: unsafe extern "C" fn(
        handle: *mut alpm_handle_t,
        glob: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int,
    pub alpm_option_remove_overwrite_file: unsafe extern "C" fn(
        handle: *mut alpm_handle_t,
        glob: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int,
    pub alpm_option_get_logfile:
        unsafe extern "C" fn(handle: *mut alpm_handle_t) -> *const ::std::os::raw::c_char,
    pub alpm_option_set_logfile: unsafe extern "C" fn(
        handle: *mut alpm_handle_t,
        logfile: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int,
    pub alpm_option_get_gpgdir:
        unsafe extern "C" fn(handle: *mut alpm_handle_t) -> *const ::std::os::raw::c_char,
    pub alpm_option_set_gpgdir: unsafe extern "C" fn(
        handle: *mut alpm_handle_t,
        gpgdir: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int,
    pub alpm_option_get_usesyslog:
        unsafe extern "C" fn(handle: *mut alpm_handle_t) -> ::std::os::raw::c_int,
    pub alpm_option_set_usesyslog: unsafe extern "C" fn(
        handle: *mut alpm_handle_t,
        usesyslog: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
    pub alpm_option_get_noupgrades:
        unsafe extern "C" fn(handle: *mut alpm_handle_t) -> *mut alpm_list_t,
    pub alpm_option_add_noupgrade: unsafe extern "C" fn(
        handle: *mut alpm_handle_t,
        path: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int,
    pub alpm_option_set_noupgrades: unsafe extern "C" fn(
        handle: *mut alpm_handle_t,
        noupgrade: *mut alpm_list_t,
    ) -> ::std::os::raw::c_int,
    pub alpm_option_remove_noupgrade: unsafe extern "C" fn(
        handle: *mut alpm_handle_t,
        path: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int,
    pub alpm_option_match_noupgrade: unsafe extern "C" fn(
        handle: *mut alpm_handle_t,
        path: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int,
    pub alpm_option_get_noextracts:
        unsafe extern "C" fn(handle: *mut alpm_handle_t) -> *mut alpm_list_t,
    pub alpm_option_add_noextract: unsafe extern "C" fn(
        handle: *mut alpm_handle_t,
        path: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int,
    pub alpm_option_set_noextracts: unsafe extern "C" fn(
        handle: *mut alpm_handle_t,
        noextract: *mut alpm_list_t,
    ) -> ::std::os::raw::c_int,
    pub alpm_option_remove_noextract: unsafe extern "C" fn(
        handle: *mut alpm_handle_t,
        path: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int,
    pub alpm_option_match_noextract: unsafe extern "C" fn(
        handle: *mut alpm_handle_t,
        path: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int,
    pub alpm_option_get_ignorepkgs:
        unsafe extern "C" fn(handle: *mut alpm_handle_t) -> *mut alpm_list_t,
    pub alpm_option_add_ignorepkg: unsafe extern "C" fn(
        handle: *mut alpm_handle_t,
        pkg: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int,
    pub alpm_option_set_ignorepkgs: unsafe extern "C" fn(
        handle: *mut alpm_handle_t,
        ignorepkgs: *mut alpm_list_t,
    ) -> ::std::os::raw::c_int,
    pub alpm_option_remove_ignorepkg: unsafe extern "C" fn(
        handle: *mut alpm_handle_t,
        pkg: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int,
    pub alpm_option_get_ignoregroups:
        unsafe extern "C" fn(handle: *mut alpm_handle_t) -> *mut alpm_list_t,
    pub alpm_option_add_ignoregroup: unsafe extern "C" fn(
        handle: *mut alpm_handle_t,
        grp: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int,
    pub alpm_option_set_ignoregroups: unsafe extern "C" fn(
        handle: *mut alpm_handle_t,
        ignoregrps: *mut alpm_list_t,
    ) -> ::std::os::raw::c_int,
    pub alpm_option_remove_ignoregroup: unsafe extern "C" fn(
        handle: *mut alpm_handle_t,
        grp: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int,
    pub alpm_option_get_assumeinstalled:
        unsafe extern "C" fn(handle: *mut alpm_handle_t) -> *mut alpm_list_t,
    pub alpm_option_add_assumeinstalled: unsafe extern "C" fn(
        handle: *mut alpm_handle_t,
        dep: *const alpm_depend_t,
    ) -> ::std::os::raw::c_int,
    pub alpm_option_set_assumeinstalled: unsafe extern "C" fn(
        handle: *mut alpm_handle_t,
        deps: *mut alpm_list_t,
    ) -> ::std::os::raw::c_int,
    pub alpm_option_remove_assumeinstalled: unsafe extern "C" fn(
        handle: *mut alpm_handle_t,
        dep: *const alpm_depend_t,
    ) -> ::std::os::raw::c_int,
    pub alpm_option_get_architectures:
        unsafe extern "C" fn(handle: *mut alpm_handle_t) -> *mut alpm_list_t,
    pub alpm_option_add_architecture: unsafe extern "C" fn(
        handle: *mut alpm_handle_t,
        arch: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int,
    pub alpm_option_set_architectures: unsafe extern "C" fn(
        handle: *mut alpm_handle_t,
        arches: *mut alpm_list_t,
    ) -> ::std::os::raw::c_int,
    pub alpm_option_remove_architecture: unsafe extern "C" fn(
        handle: *mut alpm_handle_t,
        arch: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int,
    pub alpm_option_get_checkspace:
        unsafe extern "C" fn(handle: *mut alpm_handle_t) -> ::std::os::raw::c_int,
    pub alpm_option_set_checkspace: unsafe extern "C" fn(
        handle: *mut alpm_handle_t,
        checkspace: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
    pub alpm_option_get_dbext:
        unsafe extern "C" fn(handle: *mut alpm_handle_t) -> *const ::std::os::raw::c_char,
    pub alpm_option_set_dbext: unsafe extern "C" fn(
        handle: *mut alpm_handle_t,
        dbext: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int,
    pub alpm_option_get_default_siglevel:
        unsafe extern "C" fn(handle: *mut alpm_handle_t) -> ::std::os::raw::c_int,
    pub alpm_option_set_default_siglevel: unsafe extern "C" fn(
        handle: *mut alpm_handle_t,
        level: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
    pub alpm_option_get_local_file_siglevel:
        unsafe extern "C" fn(handle: *mut alpm_handle_t) -> ::std::os::raw::c_int,
    pub alpm_option_set_local_file_siglevel: unsafe extern "C" fn(
        handle: *mut alpm_handle_t,
        level: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
    pub alpm_option_get_remote_file_siglevel:
        unsafe extern "C" fn(handle: *mut alpm_handle_t) -> ::std::os::raw::c_int,
    pub alpm_option_set_remote_file_siglevel: unsafe extern "C" fn(
        handle: *mut alpm_handle_t,
        level: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
    pub alpm_option_set_disable_dl_timeout: unsafe extern "C" fn(
        handle: *mut alpm_handle_t,
        disable_dl_timeout: ::std::os::raw::c_ushort,
    ) -> ::std::os::raw::c_int,
    pub alpm_option_get_parallel_downloads:
        unsafe extern "C" fn(handle: *mut alpm_handle_t) -> ::std::os::raw::c_int,
    pub alpm_option_set_parallel_downloads: unsafe extern "C" fn(
        handle: *mut alpm_handle_t,
        num_streams: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int,
    pub alpm_pkg_load: unsafe extern "C" fn(
        handle: *mut alpm_handle_t,
        filename: *const ::std::os::raw::c_char,
        full: ::std::os::raw::c_int,
        level: ::std::os::raw::c_int,
        pkg: *mut *mut alpm_pkg_t,
    ) -> ::std::os::raw::c_int,
    pub alpm_fetch_pkgurl: unsafe extern "C" fn(
        handle: *mut alpm_handle_t,
        urls: *const alpm_list_t,
        fetched: *mut *mut alpm_list_t,
    ) -> ::std::os::raw::c_int,
    pub alpm_pkg_find: unsafe extern "C" fn(
        haystack: *mut alpm_list_t,
        needle: *const ::std::os::raw::c_char,
    ) -> *mut alpm_pkg_t,
    pub alpm_pkg_free: unsafe extern "C" fn(pkg: *mut alpm_pkg_t) -> ::std::os::raw::c_int,
    pub alpm_pkg_checkmd5sum: unsafe extern "C" fn(pkg: *mut alpm_pkg_t) -> ::std::os::raw::c_int,
    pub alpm_pkg_vercmp: unsafe extern "C" fn(
        a: *const ::std::os::raw::c_char,
        b: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int,
    pub alpm_pkg_compute_requiredby: unsafe extern "C" fn(pkg: *mut alpm_pkg_t) -> *mut alpm_list_t,
    pub alpm_pkg_compute_optionalfor:
        unsafe extern "C" fn(pkg: *mut alpm_pkg_t) -> *mut alpm_list_t,
    pub alpm_pkg_should_ignore: unsafe extern "C" fn(
        handle: *mut alpm_handle_t,
        pkg: *mut alpm_pkg_t,
    ) -> ::std::os::raw::c_int,
    pub alpm_pkg_get_filename:
        unsafe extern "C" fn(pkg: *mut alpm_pkg_t) -> *const ::std::os::raw::c_char,
    pub alpm_pkg_get_base:
        unsafe extern "C" fn(pkg: *mut alpm_pkg_t) -> *const ::std::os::raw::c_char,
    pub alpm_pkg_get_name:
        unsafe extern "C" fn(pkg: *mut alpm_pkg_t) -> *const ::std::os::raw::c_char,
    pub alpm_pkg_get_version:
        unsafe extern "C" fn(pkg: *mut alpm_pkg_t) -> *const ::std::os::raw::c_char,
    pub alpm_pkg_get_origin: unsafe extern "C" fn(pkg: *mut alpm_pkg_t) -> alpm_pkgfrom_t,
    pub alpm_pkg_get_desc:
        unsafe extern "C" fn(pkg: *mut alpm_pkg_t) -> *const ::std::os::raw::c_char,
    pub alpm_pkg_get_url:
        unsafe extern "C" fn(pkg: *mut alpm_pkg_t) -> *const ::std::os::raw::c_char,
    pub alpm_pkg_get_builddate: unsafe extern "C" fn(pkg: *mut alpm_pkg_t) -> alpm_time_t,
    pub alpm_pkg_get_installdate: unsafe extern "C" fn(pkg: *mut alpm_pkg_t) -> alpm_time_t,
    pub alpm_pkg_get_packager:
        unsafe extern "C" fn(pkg: *mut alpm_pkg_t) -> *const ::std::os::raw::c_char,
    pub alpm_pkg_get_md5sum:
        unsafe extern "C" fn(pkg: *mut alpm_pkg_t) -> *const ::std::os::raw::c_char,
    pub alpm_pkg_get_sha256sum:
        unsafe extern "C" fn(pkg: *mut alpm_pkg_t) -> *const ::std::os::raw::c_char,
    pub alpm_pkg_get_arch:
        unsafe extern "C" fn(pkg: *mut alpm_pkg_t) -> *const ::std::os::raw::c_char,
    pub alpm_pkg_get_size: unsafe extern "C" fn(pkg: *mut alpm_pkg_t) -> off_t,
    pub alpm_pkg_get_isize: unsafe extern "C" fn(pkg: *mut alpm_pkg_t) -> off_t,
    pub alpm_pkg_get_reason: unsafe extern "C" fn(pkg: *mut alpm_pkg_t) -> alpm_pkgreason_t,
    pub alpm_pkg_get_licenses: unsafe extern "C" fn(pkg: *mut alpm_pkg_t) -> *mut alpm_list_t,
    pub alpm_pkg_get_groups: unsafe extern "C" fn(pkg: *mut alpm_pkg_t) -> *mut alpm_list_t,
    pub alpm_pkg_get_depends: unsafe extern "C" fn(pkg: *mut alpm_pkg_t) -> *mut alpm_list_t,
    pub alpm_pkg_get_optdepends: unsafe extern "C" fn(pkg: *mut alpm_pkg_t) -> *mut alpm_list_t,
    pub alpm_pkg_get_checkdepends: unsafe extern "C" fn(pkg: *mut alpm_pkg_t) -> *mut alpm_list_t,
    pub alpm_pkg_get_makedepends: unsafe extern "C" fn(pkg: *mut alpm_pkg_t) -> *mut alpm_list_t,
    pub alpm_pkg_get_conflicts: unsafe extern "C" fn(pkg: *mut alpm_pkg_t) -> *mut alpm_list_t,
    pub alpm_pkg_get_provides: unsafe extern "C" fn(pkg: *mut alpm_pkg_t) -> *mut alpm_list_t,
    pub alpm_pkg_get_replaces: unsafe extern "C" fn(pkg: *mut alpm_pkg_t) -> *mut alpm_list_t,
    pub alpm_pkg_get_files: unsafe extern "C" fn(pkg: *mut alpm_pkg_t) -> *mut alpm_filelist_t,
    pub alpm_pkg_get_backup: unsafe extern "C" fn(pkg: *mut alpm_pkg_t) -> *mut alpm_list_t,
    pub alpm_pkg_get_db: unsafe extern "C" fn(pkg: *mut alpm_pkg_t) -> *mut alpm_db_t,
    pub alpm_pkg_get_base64_sig:
        unsafe extern "C" fn(pkg: *mut alpm_pkg_t) -> *const ::std::os::raw::c_char,
    pub alpm_pkg_get_sig: unsafe extern "C" fn(
        pkg: *mut alpm_pkg_t,
        sig: *mut *mut ::std::os::raw::c_uchar,
        sig_len: *mut usize,
    ) -> ::std::os::raw::c_int,
    pub alpm_pkg_get_validation:
        unsafe extern "C" fn(pkg: *mut alpm_pkg_t) -> ::std::os::raw::c_int,
    pub alpm_pkg_has_scriptlet: unsafe extern "C" fn(pkg: *mut alpm_pkg_t) -> ::std::os::raw::c_int,
    pub alpm_pkg_download_size: unsafe extern "C" fn(newpkg: *mut alpm_pkg_t) -> off_t,
    pub alpm_pkg_set_reason: unsafe extern "C" fn(
        pkg: *mut alpm_pkg_t,
        reason: alpm_pkgreason_t,
    ) -> ::std::os::raw::c_int,
    pub alpm_pkg_changelog_open:
        unsafe extern "C" fn(pkg: *mut alpm_pkg_t) -> *mut ::std::os::raw::c_void,
    pub alpm_pkg_changelog_read: unsafe extern "C" fn(
        ptr: *mut ::std::os::raw::c_void,
        size: usize,
        pkg: *const alpm_pkg_t,
        fp: *mut ::std::os::raw::c_void,
    ) -> usize,
    pub alpm_pkg_changelog_close: unsafe extern "C" fn(
        pkg: *const alpm_pkg_t,
        fp: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
    pub alpm_pkg_mtree_open: unsafe extern "C" fn(pkg: *mut alpm_pkg_t) -> *mut archive,
    pub alpm_pkg_mtree_next: unsafe extern "C" fn(
        pkg: *const alpm_pkg_t,
        archive: *mut archive,
        entry: *mut *mut archive_entry,
    ) -> ::std::os::raw::c_int,
    pub alpm_pkg_mtree_close: unsafe extern "C" fn(
        pkg: *const alpm_pkg_t,
        archive: *mut archive,
    ) -> ::std::os::raw::c_int,
    pub alpm_trans_get_flags:
        unsafe extern "C" fn(handle: *mut alpm_handle_t) -> ::std::os::raw::c_int,
    pub alpm_trans_get_add: unsafe extern "C" fn(handle: *mut alpm_handle_t) -> *mut alpm_list_t,
    pub alpm_trans_get_remove: unsafe extern "C" fn(handle: *mut alpm_handle_t) -> *mut alpm_list_t,
    pub alpm_trans_init: unsafe extern "C" fn(
        handle: *mut alpm_handle_t,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
    pub alpm_trans_prepare: unsafe extern "C" fn(
        handle: *mut alpm_handle_t,
        data: *mut *mut alpm_list_t,
    ) -> ::std::os::raw::c_int,
    pub alpm_trans_commit: unsafe extern "C" fn(
        handle: *mut alpm_handle_t,
        data: *mut *mut alpm_list_t,
    ) -> ::std::os::raw::c_int,
    pub alpm_trans_interrupt:
        unsafe extern "C" fn(handle: *mut alpm_handle_t) -> ::std::os::raw::c_int,
    pub alpm_trans_release:
        unsafe extern "C" fn(handle: *mut alpm_handle_t) -> ::std::os::raw::c_int,
    pub alpm_sync_sysupgrade: unsafe extern "C" fn(
        handle: *mut alpm_handle_t,
        enable_downgrade: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
    pub alpm_add_pkg: unsafe extern "C" fn(
        handle: *mut alpm_handle_t,
        pkg: *mut alpm_pkg_t,
    ) -> ::std::os::raw::c_int,
    pub alpm_remove_pkg: unsafe extern "C" fn(
        handle: *mut alpm_handle_t,
        pkg: *mut alpm_pkg_t,
    ) -> ::std::os::raw::c_int,
    pub alpm_sync_get_new_version:
        unsafe extern "C" fn(pkg: *mut alpm_pkg_t, dbs_sync: *mut alpm_list_t) -> *mut alpm_pkg_t,
    pub alpm_compute_md5sum: unsafe extern "C" fn(
        filename: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char,
    pub alpm_compute_sha256sum: unsafe extern "C" fn(
        filename: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char,
    pub alpm_unlock: unsafe extern "C" fn(handle: *mut alpm_handle_t) -> ::std::os::raw::c_int,
    pub alpm_version: unsafe extern "C" fn() -> *const ::std::os::raw::c_char,
    pub alpm_capabilities: unsafe extern "C" fn() -> ::std::os::raw::c_int,
}
impl libalpm {
    pub unsafe fn new<P>(path: P) -> Result<Self, ::libloading::Error>
    where
        P: AsRef<::std::ffi::OsStr>,
    {
        let library = ::libloading::Library::new(path)?;
        Self::from_library(library)
    }
    pub unsafe fn from_library<L>(library: L) -> Result<Self, ::libloading::Error>
    where
        L: Into<::libloading::Library>,
    {
        let __library = library.into();
        let alpm_list_free = __library.get(b"alpm_list_free\0").map(|sym| *sym)?;
        let alpm_list_free_inner = __library.get(b"alpm_list_free_inner\0").map(|sym| *sym)?;
        let alpm_list_add = __library.get(b"alpm_list_add\0").map(|sym| *sym)?;
        let alpm_list_append = __library.get(b"alpm_list_append\0").map(|sym| *sym)?;
        let alpm_list_append_strdup = __library
            .get(b"alpm_list_append_strdup\0")
            .map(|sym| *sym)?;
        let alpm_list_add_sorted = __library.get(b"alpm_list_add_sorted\0").map(|sym| *sym)?;
        let alpm_list_join = __library.get(b"alpm_list_join\0").map(|sym| *sym)?;
        let alpm_list_mmerge = __library.get(b"alpm_list_mmerge\0").map(|sym| *sym)?;
        let alpm_list_msort = __library.get(b"alpm_list_msort\0").map(|sym| *sym)?;
        let alpm_list_remove_item = __library.get(b"alpm_list_remove_item\0").map(|sym| *sym)?;
        let alpm_list_remove = __library.get(b"alpm_list_remove\0").map(|sym| *sym)?;
        let alpm_list_remove_str = __library.get(b"alpm_list_remove_str\0").map(|sym| *sym)?;
        let alpm_list_remove_dupes = __library.get(b"alpm_list_remove_dupes\0").map(|sym| *sym)?;
        let alpm_list_strdup = __library.get(b"alpm_list_strdup\0").map(|sym| *sym)?;
        let alpm_list_copy = __library.get(b"alpm_list_copy\0").map(|sym| *sym)?;
        let alpm_list_copy_data = __library.get(b"alpm_list_copy_data\0").map(|sym| *sym)?;
        let alpm_list_reverse = __library.get(b"alpm_list_reverse\0").map(|sym| *sym)?;
        let alpm_list_nth = __library.get(b"alpm_list_nth\0").map(|sym| *sym)?;
        let alpm_list_next = __library.get(b"alpm_list_next\0").map(|sym| *sym)?;
        let alpm_list_previous = __library.get(b"alpm_list_previous\0").map(|sym| *sym)?;
        let alpm_list_last = __library.get(b"alpm_list_last\0").map(|sym| *sym)?;
        let alpm_list_count = __library.get(b"alpm_list_count\0").map(|sym| *sym)?;
        let alpm_list_find = __library.get(b"alpm_list_find\0").map(|sym| *sym)?;
        let alpm_list_find_ptr = __library.get(b"alpm_list_find_ptr\0").map(|sym| *sym)?;
        let alpm_list_find_str = __library.get(b"alpm_list_find_str\0").map(|sym| *sym)?;
        let alpm_list_diff_sorted = __library.get(b"alpm_list_diff_sorted\0").map(|sym| *sym)?;
        let alpm_list_diff = __library.get(b"alpm_list_diff\0").map(|sym| *sym)?;
        let alpm_list_to_array = __library.get(b"alpm_list_to_array\0").map(|sym| *sym)?;
        let alpm_filelist_contains = __library.get(b"alpm_filelist_contains\0").map(|sym| *sym)?;
        let alpm_find_group_pkgs = __library.get(b"alpm_find_group_pkgs\0").map(|sym| *sym)?;
        let alpm_errno = __library.get(b"alpm_errno\0").map(|sym| *sym)?;
        let alpm_strerror = __library.get(b"alpm_strerror\0").map(|sym| *sym)?;
        let alpm_initialize = __library.get(b"alpm_initialize\0").map(|sym| *sym)?;
        let alpm_release = __library.get(b"alpm_release\0").map(|sym| *sym)?;
        let alpm_pkg_check_pgp_signature = __library
            .get(b"alpm_pkg_check_pgp_signature\0")
            .map(|sym| *sym)?;
        let alpm_db_check_pgp_signature = __library
            .get(b"alpm_db_check_pgp_signature\0")
            .map(|sym| *sym)?;
        let alpm_siglist_cleanup = __library.get(b"alpm_siglist_cleanup\0").map(|sym| *sym)?;
        let alpm_decode_signature = __library.get(b"alpm_decode_signature\0").map(|sym| *sym)?;
        let alpm_extract_keyid = __library.get(b"alpm_extract_keyid\0").map(|sym| *sym)?;
        let alpm_checkdeps = __library.get(b"alpm_checkdeps\0").map(|sym| *sym)?;
        let alpm_find_satisfier = __library.get(b"alpm_find_satisfier\0").map(|sym| *sym)?;
        let alpm_find_dbs_satisfier = __library
            .get(b"alpm_find_dbs_satisfier\0")
            .map(|sym| *sym)?;
        let alpm_checkconflicts = __library.get(b"alpm_checkconflicts\0").map(|sym| *sym)?;
        let alpm_dep_compute_string = __library
            .get(b"alpm_dep_compute_string\0")
            .map(|sym| *sym)?;
        let alpm_dep_from_string = __library.get(b"alpm_dep_from_string\0").map(|sym| *sym)?;
        let alpm_dep_free = __library.get(b"alpm_dep_free\0").map(|sym| *sym)?;
        let alpm_fileconflict_free = __library.get(b"alpm_fileconflict_free\0").map(|sym| *sym)?;
        let alpm_depmissing_free = __library.get(b"alpm_depmissing_free\0").map(|sym| *sym)?;
        let alpm_conflict_free = __library.get(b"alpm_conflict_free\0").map(|sym| *sym)?;
        let alpm_get_localdb = __library.get(b"alpm_get_localdb\0").map(|sym| *sym)?;
        let alpm_get_syncdbs = __library.get(b"alpm_get_syncdbs\0").map(|sym| *sym)?;
        let alpm_register_syncdb = __library.get(b"alpm_register_syncdb\0").map(|sym| *sym)?;
        let alpm_unregister_all_syncdbs = __library
            .get(b"alpm_unregister_all_syncdbs\0")
            .map(|sym| *sym)?;
        let alpm_db_unregister = __library.get(b"alpm_db_unregister\0").map(|sym| *sym)?;
        let alpm_db_get_name = __library.get(b"alpm_db_get_name\0").map(|sym| *sym)?;
        let alpm_db_get_siglevel = __library.get(b"alpm_db_get_siglevel\0").map(|sym| *sym)?;
        let alpm_db_get_valid = __library.get(b"alpm_db_get_valid\0").map(|sym| *sym)?;
        let alpm_db_get_servers = __library.get(b"alpm_db_get_servers\0").map(|sym| *sym)?;
        let alpm_db_set_servers = __library.get(b"alpm_db_set_servers\0").map(|sym| *sym)?;
        let alpm_db_add_server = __library.get(b"alpm_db_add_server\0").map(|sym| *sym)?;
        let alpm_db_remove_server = __library.get(b"alpm_db_remove_server\0").map(|sym| *sym)?;
        let alpm_db_update = __library.get(b"alpm_db_update\0").map(|sym| *sym)?;
        let alpm_db_get_pkg = __library.get(b"alpm_db_get_pkg\0").map(|sym| *sym)?;
        let alpm_db_get_pkgcache = __library.get(b"alpm_db_get_pkgcache\0").map(|sym| *sym)?;
        let alpm_db_get_group = __library.get(b"alpm_db_get_group\0").map(|sym| *sym)?;
        let alpm_db_get_groupcache = __library.get(b"alpm_db_get_groupcache\0").map(|sym| *sym)?;
        let alpm_db_search = __library.get(b"alpm_db_search\0").map(|sym| *sym)?;
        let alpm_db_set_usage = __library.get(b"alpm_db_set_usage\0").map(|sym| *sym)?;
        let alpm_db_get_usage = __library.get(b"alpm_db_get_usage\0").map(|sym| *sym)?;
        let alpm_logaction = __library.get(b"alpm_logaction\0").map(|sym| *sym)?;
        let alpm_option_get_logcb = __library.get(b"alpm_option_get_logcb\0").map(|sym| *sym)?;
        let alpm_option_get_logcb_ctx = __library
            .get(b"alpm_option_get_logcb_ctx\0")
            .map(|sym| *sym)?;
        let alpm_option_set_logcb = __library.get(b"alpm_option_set_logcb\0").map(|sym| *sym)?;
        let alpm_option_get_dlcb = __library.get(b"alpm_option_get_dlcb\0").map(|sym| *sym)?;
        let alpm_option_get_dlcb_ctx = __library
            .get(b"alpm_option_get_dlcb_ctx\0")
            .map(|sym| *sym)?;
        let alpm_option_set_dlcb = __library.get(b"alpm_option_set_dlcb\0").map(|sym| *sym)?;
        let alpm_option_get_fetchcb = __library
            .get(b"alpm_option_get_fetchcb\0")
            .map(|sym| *sym)?;
        let alpm_option_get_fetchcb_ctx = __library
            .get(b"alpm_option_get_fetchcb_ctx\0")
            .map(|sym| *sym)?;
        let alpm_option_set_fetchcb = __library
            .get(b"alpm_option_set_fetchcb\0")
            .map(|sym| *sym)?;
        let alpm_option_get_eventcb = __library
            .get(b"alpm_option_get_eventcb\0")
            .map(|sym| *sym)?;
        let alpm_option_get_eventcb_ctx = __library
            .get(b"alpm_option_get_eventcb_ctx\0")
            .map(|sym| *sym)?;
        let alpm_option_set_eventcb = __library
            .get(b"alpm_option_set_eventcb\0")
            .map(|sym| *sym)?;
        let alpm_option_get_questioncb = __library
            .get(b"alpm_option_get_questioncb\0")
            .map(|sym| *sym)?;
        let alpm_option_get_questioncb_ctx = __library
            .get(b"alpm_option_get_questioncb_ctx\0")
            .map(|sym| *sym)?;
        let alpm_option_set_questioncb = __library
            .get(b"alpm_option_set_questioncb\0")
            .map(|sym| *sym)?;
        let alpm_option_get_progresscb = __library
            .get(b"alpm_option_get_progresscb\0")
            .map(|sym| *sym)?;
        let alpm_option_get_progresscb_ctx = __library
            .get(b"alpm_option_get_progresscb_ctx\0")
            .map(|sym| *sym)?;
        let alpm_option_set_progresscb = __library
            .get(b"alpm_option_set_progresscb\0")
            .map(|sym| *sym)?;
        let alpm_option_get_root = __library.get(b"alpm_option_get_root\0").map(|sym| *sym)?;
        let alpm_option_get_dbpath = __library.get(b"alpm_option_get_dbpath\0").map(|sym| *sym)?;
        let alpm_option_get_lockfile = __library
            .get(b"alpm_option_get_lockfile\0")
            .map(|sym| *sym)?;
        let alpm_option_get_cachedirs = __library
            .get(b"alpm_option_get_cachedirs\0")
            .map(|sym| *sym)?;
        let alpm_option_set_cachedirs = __library
            .get(b"alpm_option_set_cachedirs\0")
            .map(|sym| *sym)?;
        let alpm_option_add_cachedir = __library
            .get(b"alpm_option_add_cachedir\0")
            .map(|sym| *sym)?;
        let alpm_option_remove_cachedir = __library
            .get(b"alpm_option_remove_cachedir\0")
            .map(|sym| *sym)?;
        let alpm_option_get_hookdirs = __library
            .get(b"alpm_option_get_hookdirs\0")
            .map(|sym| *sym)?;
        let alpm_option_set_hookdirs = __library
            .get(b"alpm_option_set_hookdirs\0")
            .map(|sym| *sym)?;
        let alpm_option_add_hookdir = __library
            .get(b"alpm_option_add_hookdir\0")
            .map(|sym| *sym)?;
        let alpm_option_remove_hookdir = __library
            .get(b"alpm_option_remove_hookdir\0")
            .map(|sym| *sym)?;
        let alpm_option_get_overwrite_files = __library
            .get(b"alpm_option_get_overwrite_files\0")
            .map(|sym| *sym)?;
        let alpm_option_set_overwrite_files = __library
            .get(b"alpm_option_set_overwrite_files\0")
            .map(|sym| *sym)?;
        let alpm_option_add_overwrite_file = __library
            .get(b"alpm_option_add_overwrite_file\0")
            .map(|sym| *sym)?;
        let alpm_option_remove_overwrite_file = __library
            .get(b"alpm_option_remove_overwrite_file\0")
            .map(|sym| *sym)?;
        let alpm_option_get_logfile = __library
            .get(b"alpm_option_get_logfile\0")
            .map(|sym| *sym)?;
        let alpm_option_set_logfile = __library
            .get(b"alpm_option_set_logfile\0")
            .map(|sym| *sym)?;
        let alpm_option_get_gpgdir = __library.get(b"alpm_option_get_gpgdir\0").map(|sym| *sym)?;
        let alpm_option_set_gpgdir = __library.get(b"alpm_option_set_gpgdir\0").map(|sym| *sym)?;
        let alpm_option_get_usesyslog = __library
            .get(b"alpm_option_get_usesyslog\0")
            .map(|sym| *sym)?;
        let alpm_option_set_usesyslog = __library
            .get(b"alpm_option_set_usesyslog\0")
            .map(|sym| *sym)?;
        let alpm_option_get_noupgrades = __library
            .get(b"alpm_option_get_noupgrades\0")
            .map(|sym| *sym)?;
        let alpm_option_add_noupgrade = __library
            .get(b"alpm_option_add_noupgrade\0")
            .map(|sym| *sym)?;
        let alpm_option_set_noupgrades = __library
            .get(b"alpm_option_set_noupgrades\0")
            .map(|sym| *sym)?;
        let alpm_option_remove_noupgrade = __library
            .get(b"alpm_option_remove_noupgrade\0")
            .map(|sym| *sym)?;
        let alpm_option_match_noupgrade = __library
            .get(b"alpm_option_match_noupgrade\0")
            .map(|sym| *sym)?;
        let alpm_option_get_noextracts = __library
            .get(b"alpm_option_get_noextracts\0")
            .map(|sym| *sym)?;
        let alpm_option_add_noextract = __library
            .get(b"alpm_option_add_noextract\0")
            .map(|sym| *sym)?;
        let alpm_option_set_noextracts = __library
            .get(b"alpm_option_set_noextracts\0")
            .map(|sym| *sym)?;
        let alpm_option_remove_noextract = __library
            .get(b"alpm_option_remove_noextract\0")
            .map(|sym| *sym)?;
        let alpm_option_match_noextract = __library
            .get(b"alpm_option_match_noextract\0")
            .map(|sym| *sym)?;
        let alpm_option_get_ignorepkgs = __library
            .get(b"alpm_option_get_ignorepkgs\0")
            .map(|sym| *sym)?;
        let alpm_option_add_ignorepkg = __library
            .get(b"alpm_option_add_ignorepkg\0")
            .map(|sym| *sym)?;
        let alpm_option_set_ignorepkgs = __library
            .get(b"alpm_option_set_ignorepkgs\0")
            .map(|sym| *sym)?;
        let alpm_option_remove_ignorepkg = __library
            .get(b"alpm_option_remove_ignorepkg\0")
            .map(|sym| *sym)?;
        let alpm_option_get_ignoregroups = __library
            .get(b"alpm_option_get_ignoregroups\0")
            .map(|sym| *sym)?;
        let alpm_option_add_ignoregroup = __library
            .get(b"alpm_option_add_ignoregroup\0")
            .map(|sym| *sym)?;
        let alpm_option_set_ignoregroups = __library
            .get(b"alpm_option_set_ignoregroups\0")
            .map(|sym| *sym)?;
        let alpm_option_remove_ignoregroup = __library
            .get(b"alpm_option_remove_ignoregroup\0")
            .map(|sym| *sym)?;
        let alpm_option_get_assumeinstalled = __library
            .get(b"alpm_option_get_assumeinstalled\0")
            .map(|sym| *sym)?;
        let alpm_option_add_assumeinstalled = __library
            .get(b"alpm_option_add_assumeinstalled\0")
            .map(|sym| *sym)?;
        let alpm_option_set_assumeinstalled = __library
            .get(b"alpm_option_set_assumeinstalled\0")
            .map(|sym| *sym)?;
        let alpm_option_remove_assumeinstalled = __library
            .get(b"alpm_option_remove_assumeinstalled\0")
            .map(|sym| *sym)?;
        let alpm_option_get_architectures = __library
            .get(b"alpm_option_get_architectures\0")
            .map(|sym| *sym)?;
        let alpm_option_add_architecture = __library
            .get(b"alpm_option_add_architecture\0")
            .map(|sym| *sym)?;
        let alpm_option_set_architectures = __library
            .get(b"alpm_option_set_architectures\0")
            .map(|sym| *sym)?;
        let alpm_option_remove_architecture = __library
            .get(b"alpm_option_remove_architecture\0")
            .map(|sym| *sym)?;
        let alpm_option_get_checkspace = __library
            .get(b"alpm_option_get_checkspace\0")
            .map(|sym| *sym)?;
        let alpm_option_set_checkspace = __library
            .get(b"alpm_option_set_checkspace\0")
            .map(|sym| *sym)?;
        let alpm_option_get_dbext = __library.get(b"alpm_option_get_dbext\0").map(|sym| *sym)?;
        let alpm_option_set_dbext = __library.get(b"alpm_option_set_dbext\0").map(|sym| *sym)?;
        let alpm_option_get_default_siglevel = __library
            .get(b"alpm_option_get_default_siglevel\0")
            .map(|sym| *sym)?;
        let alpm_option_set_default_siglevel = __library
            .get(b"alpm_option_set_default_siglevel\0")
            .map(|sym| *sym)?;
        let alpm_option_get_local_file_siglevel = __library
            .get(b"alpm_option_get_local_file_siglevel\0")
            .map(|sym| *sym)?;
        let alpm_option_set_local_file_siglevel = __library
            .get(b"alpm_option_set_local_file_siglevel\0")
            .map(|sym| *sym)?;
        let alpm_option_get_remote_file_siglevel = __library
            .get(b"alpm_option_get_remote_file_siglevel\0")
            .map(|sym| *sym)?;
        let alpm_option_set_remote_file_siglevel = __library
            .get(b"alpm_option_set_remote_file_siglevel\0")
            .map(|sym| *sym)?;
        let alpm_option_set_disable_dl_timeout = __library
            .get(b"alpm_option_set_disable_dl_timeout\0")
            .map(|sym| *sym)?;
        let alpm_option_get_parallel_downloads = __library
            .get(b"alpm_option_get_parallel_downloads\0")
            .map(|sym| *sym)?;
        let alpm_option_set_parallel_downloads = __library
            .get(b"alpm_option_set_parallel_downloads\0")
            .map(|sym| *sym)?;
        let alpm_pkg_load = __library.get(b"alpm_pkg_load\0").map(|sym| *sym)?;
        let alpm_fetch_pkgurl = __library.get(b"alpm_fetch_pkgurl\0").map(|sym| *sym)?;
        let alpm_pkg_find = __library.get(b"alpm_pkg_find\0").map(|sym| *sym)?;
        let alpm_pkg_free = __library.get(b"alpm_pkg_free\0").map(|sym| *sym)?;
        let alpm_pkg_checkmd5sum = __library.get(b"alpm_pkg_checkmd5sum\0").map(|sym| *sym)?;
        let alpm_pkg_vercmp = __library.get(b"alpm_pkg_vercmp\0").map(|sym| *sym)?;
        let alpm_pkg_compute_requiredby = __library
            .get(b"alpm_pkg_compute_requiredby\0")
            .map(|sym| *sym)?;
        let alpm_pkg_compute_optionalfor = __library
            .get(b"alpm_pkg_compute_optionalfor\0")
            .map(|sym| *sym)?;
        let alpm_pkg_should_ignore = __library.get(b"alpm_pkg_should_ignore\0").map(|sym| *sym)?;
        let alpm_pkg_get_filename = __library.get(b"alpm_pkg_get_filename\0").map(|sym| *sym)?;
        let alpm_pkg_get_base = __library.get(b"alpm_pkg_get_base\0").map(|sym| *sym)?;
        let alpm_pkg_get_name = __library.get(b"alpm_pkg_get_name\0").map(|sym| *sym)?;
        let alpm_pkg_get_version = __library.get(b"alpm_pkg_get_version\0").map(|sym| *sym)?;
        let alpm_pkg_get_origin = __library.get(b"alpm_pkg_get_origin\0").map(|sym| *sym)?;
        let alpm_pkg_get_desc = __library.get(b"alpm_pkg_get_desc\0").map(|sym| *sym)?;
        let alpm_pkg_get_url = __library.get(b"alpm_pkg_get_url\0").map(|sym| *sym)?;
        let alpm_pkg_get_builddate = __library.get(b"alpm_pkg_get_builddate\0").map(|sym| *sym)?;
        let alpm_pkg_get_installdate = __library
            .get(b"alpm_pkg_get_installdate\0")
            .map(|sym| *sym)?;
        let alpm_pkg_get_packager = __library.get(b"alpm_pkg_get_packager\0").map(|sym| *sym)?;
        let alpm_pkg_get_md5sum = __library.get(b"alpm_pkg_get_md5sum\0").map(|sym| *sym)?;
        let alpm_pkg_get_sha256sum = __library.get(b"alpm_pkg_get_sha256sum\0").map(|sym| *sym)?;
        let alpm_pkg_get_arch = __library.get(b"alpm_pkg_get_arch\0").map(|sym| *sym)?;
        let alpm_pkg_get_size = __library.get(b"alpm_pkg_get_size\0").map(|sym| *sym)?;
        let alpm_pkg_get_isize = __library.get(b"alpm_pkg_get_isize\0").map(|sym| *sym)?;
        let alpm_pkg_get_reason = __library.get(b"alpm_pkg_get_reason\0").map(|sym| *sym)?;
        let alpm_pkg_get_licenses = __library.get(b"alpm_pkg_get_licenses\0").map(|sym| *sym)?;
        let alpm_pkg_get_groups = __library.get(b"alpm_pkg_get_groups\0").map(|sym| *sym)?;
        let alpm_pkg_get_depends = __library.get(b"alpm_pkg_get_depends\0").map(|sym| *sym)?;
        let alpm_pkg_get_optdepends = __library
            .get(b"alpm_pkg_get_optdepends\0")
            .map(|sym| *sym)?;
        let alpm_pkg_get_checkdepends = __library
            .get(b"alpm_pkg_get_checkdepends\0")
            .map(|sym| *sym)?;
        let alpm_pkg_get_makedepends = __library
            .get(b"alpm_pkg_get_makedepends\0")
            .map(|sym| *sym)?;
        let alpm_pkg_get_conflicts = __library.get(b"alpm_pkg_get_conflicts\0").map(|sym| *sym)?;
        let alpm_pkg_get_provides = __library.get(b"alpm_pkg_get_provides\0").map(|sym| *sym)?;
        let alpm_pkg_get_replaces = __library.get(b"alpm_pkg_get_replaces\0").map(|sym| *sym)?;
        let alpm_pkg_get_files = __library.get(b"alpm_pkg_get_files\0").map(|sym| *sym)?;
        let alpm_pkg_get_backup = __library.get(b"alpm_pkg_get_backup\0").map(|sym| *sym)?;
        let alpm_pkg_get_db = __library.get(b"alpm_pkg_get_db\0").map(|sym| *sym)?;
        let alpm_pkg_get_base64_sig = __library
            .get(b"alpm_pkg_get_base64_sig\0")
            .map(|sym| *sym)?;
        let alpm_pkg_get_sig = __library.get(b"alpm_pkg_get_sig\0").map(|sym| *sym)?;
        let alpm_pkg_get_validation = __library
            .get(b"alpm_pkg_get_validation\0")
            .map(|sym| *sym)?;
        let alpm_pkg_has_scriptlet = __library.get(b"alpm_pkg_has_scriptlet\0").map(|sym| *sym)?;
        let alpm_pkg_download_size = __library.get(b"alpm_pkg_download_size\0").map(|sym| *sym)?;
        let alpm_pkg_set_reason = __library.get(b"alpm_pkg_set_reason\0").map(|sym| *sym)?;
        let alpm_pkg_changelog_open = __library
            .get(b"alpm_pkg_changelog_open\0")
            .map(|sym| *sym)?;
        let alpm_pkg_changelog_read = __library
            .get(b"alpm_pkg_changelog_read\0")
            .map(|sym| *sym)?;
        let alpm_pkg_changelog_close = __library
            .get(b"alpm_pkg_changelog_close\0")
            .map(|sym| *sym)?;
        let alpm_pkg_mtree_open = __library.get(b"alpm_pkg_mtree_open\0").map(|sym| *sym)?;
        let alpm_pkg_mtree_next = __library.get(b"alpm_pkg_mtree_next\0").map(|sym| *sym)?;
        let alpm_pkg_mtree_close = __library.get(b"alpm_pkg_mtree_close\0").map(|sym| *sym)?;
        let alpm_trans_get_flags = __library.get(b"alpm_trans_get_flags\0").map(|sym| *sym)?;
        let alpm_trans_get_add = __library.get(b"alpm_trans_get_add\0").map(|sym| *sym)?;
        let alpm_trans_get_remove = __library.get(b"alpm_trans_get_remove\0").map(|sym| *sym)?;
        let alpm_trans_init = __library.get(b"alpm_trans_init\0").map(|sym| *sym)?;
        let alpm_trans_prepare = __library.get(b"alpm_trans_prepare\0").map(|sym| *sym)?;
        let alpm_trans_commit = __library.get(b"alpm_trans_commit\0").map(|sym| *sym)?;
        let alpm_trans_interrupt = __library.get(b"alpm_trans_interrupt\0").map(|sym| *sym)?;
        let alpm_trans_release = __library.get(b"alpm_trans_release\0").map(|sym| *sym)?;
        let alpm_sync_sysupgrade = __library.get(b"alpm_sync_sysupgrade\0").map(|sym| *sym)?;
        let alpm_add_pkg = __library.get(b"alpm_add_pkg\0").map(|sym| *sym)?;
        let alpm_remove_pkg = __library.get(b"alpm_remove_pkg\0").map(|sym| *sym)?;
        let alpm_sync_get_new_version = __library
            .get(b"alpm_sync_get_new_version\0")
            .map(|sym| *sym)?;
        let alpm_compute_md5sum = __library.get(b"alpm_compute_md5sum\0").map(|sym| *sym)?;
        let alpm_compute_sha256sum = __library.get(b"alpm_compute_sha256sum\0").map(|sym| *sym)?;
        let alpm_unlock = __library.get(b"alpm_unlock\0").map(|sym| *sym)?;
        let alpm_version = __library.get(b"alpm_version\0").map(|sym| *sym)?;
        let alpm_capabilities = __library.get(b"alpm_capabilities\0").map(|sym| *sym)?;
        Ok(libalpm {
            __library,
            alpm_list_free,
            alpm_list_free_inner,
            alpm_list_add,
            alpm_list_append,
            alpm_list_append_strdup,
            alpm_list_add_sorted,
            alpm_list_join,
            alpm_list_mmerge,
            alpm_list_msort,
            alpm_list_remove_item,
            alpm_list_remove,
            alpm_list_remove_str,
            alpm_list_remove_dupes,
            alpm_list_strdup,
            alpm_list_copy,
            alpm_list_copy_data,
            alpm_list_reverse,
            alpm_list_nth,
            alpm_list_next,
            alpm_list_previous,
            alpm_list_last,
            alpm_list_count,
            alpm_list_find,
            alpm_list_find_ptr,
            alpm_list_find_str,
            alpm_list_diff_sorted,
            alpm_list_diff,
            alpm_list_to_array,
            alpm_filelist_contains,
            alpm_find_group_pkgs,
            alpm_errno,
            alpm_strerror,
            alpm_initialize,
            alpm_release,
            alpm_pkg_check_pgp_signature,
            alpm_db_check_pgp_signature,
            alpm_siglist_cleanup,
            alpm_decode_signature,
            alpm_extract_keyid,
            alpm_checkdeps,
            alpm_find_satisfier,
            alpm_find_dbs_satisfier,
            alpm_checkconflicts,
            alpm_dep_compute_string,
            alpm_dep_from_string,
            alpm_dep_free,
            alpm_fileconflict_free,
            alpm_depmissing_free,
            alpm_conflict_free,
            alpm_get_localdb,
            alpm_get_syncdbs,
            alpm_register_syncdb,
            alpm_unregister_all_syncdbs,
            alpm_db_unregister,
            alpm_db_get_name,
            alpm_db_get_siglevel,
            alpm_db_get_valid,
            alpm_db_get_servers,
            alpm_db_set_servers,
            alpm_db_add_server,
            alpm_db_remove_server,
            alpm_db_update,
            alpm_db_get_pkg,
            alpm_db_get_pkgcache,
            alpm_db_get_group,
            alpm_db_get_groupcache,
            alpm_db_search,
            alpm_db_set_usage,
            alpm_db_get_usage,
            alpm_logaction,
            alpm_option_get_logcb,
            alpm_option_get_logcb_ctx,
            alpm_option_set_logcb,
            alpm_option_get_dlcb,
            alpm_option_get_dlcb_ctx,
            alpm_option_set_dlcb,
            alpm_option_get_fetchcb,
            alpm_option_get_fetchcb_ctx,
            alpm_option_set_fetchcb,
            alpm_option_get_eventcb,
            alpm_option_get_eventcb_ctx,
            alpm_option_set_eventcb,
            alpm_option_get_questioncb,
            alpm_option_get_questioncb_ctx,
            alpm_option_set_questioncb,
            alpm_option_get_progresscb,
            alpm_option_get_progresscb_ctx,
            alpm_option_set_progresscb,
            alpm_option_get_root,
            alpm_option_get_dbpath,
            alpm_option_get_lockfile,
            alpm_option_get_cachedirs,
            alpm_option_set_cachedirs,
            alpm_option_add_cachedir,
            alpm_option_remove_cachedir,
            alpm_option_get_hookdirs,
            alpm_option_set_hookdirs,
            alpm_option_add_hookdir,
            alpm_option_remove_hookdir,
            alpm_option_get_overwrite_files,
            alpm_option_set_overwrite_files,
            alpm_option_add_overwrite_file,
            alpm_option_remove_overwrite_file,
            alpm_option_get_logfile,
            alpm_option_set_logfile,
            alpm_option_get_gpgdir,
            alpm_option_set_gpgdir,
            alpm_option_get_usesyslog,
            alpm_option_set_usesyslog,
            alpm_option_get_noupgrades,
            alpm_option_add_noupgrade,
            alpm_option_set_noupgrades,
            alpm_option_remove_noupgrade,
            alpm_option_match_noupgrade,
            alpm_option_get_noextracts,
            alpm_option_add_noextract,
            alpm_option_set_noextracts,
            alpm_option_remove_noextract,
            alpm_option_match_noextract,
            alpm_option_get_ignorepkgs,
            alpm_option_add_ignorepkg,
            alpm_option_set_ignorepkgs,
            alpm_option_remove_ignorepkg,
            alpm_option_get_ignoregroups,
            alpm_option_add_ignoregroup,
            alpm_option_set_ignoregroups,
            alpm_option_remove_ignoregroup,
            alpm_option_get_assumeinstalled,
            alpm_option_add_assumeinstalled,
            alpm_option_set_assumeinstalled,
            alpm_option_remove_assumeinstalled,
            alpm_option_get_architectures,
            alpm_option_add_architecture,
            alpm_option_set_architectures,
            alpm_option_remove_architecture,
            alpm_option_get_checkspace,
            alpm_option_set_checkspace,
            alpm_option_get_dbext,
            alpm_option_set_dbext,
            alpm_option_get_default_siglevel,
            alpm_option_set_default_siglevel,
            alpm_option_get_local_file_siglevel,
            alpm_option_set_local_file_siglevel,
            alpm_option_get_remote_file_siglevel,
            alpm_option_set_remote_file_siglevel,
            alpm_option_set_disable_dl_timeout,
            alpm_option_get_parallel_downloads,
            alpm_option_set_parallel_downloads,
            alpm_pkg_load,
            alpm_fetch_pkgurl,
            alpm_pkg_find,
            alpm_pkg_free,
            alpm_pkg_checkmd5sum,
            alpm_pkg_vercmp,
            alpm_pkg_compute_requiredby,
            alpm_pkg_compute_optionalfor,
            alpm_pkg_should_ignore,
            alpm_pkg_get_filename,
            alpm_pkg_get_base,
            alpm_pkg_get_name,
            alpm_pkg_get_version,
            alpm_pkg_get_origin,
            alpm_pkg_get_desc,
            alpm_pkg_get_url,
            alpm_pkg_get_builddate,
            alpm_pkg_get_installdate,
            alpm_pkg_get_packager,
            alpm_pkg_get_md5sum,
            alpm_pkg_get_sha256sum,
            alpm_pkg_get_arch,
            alpm_pkg_get_size,
            alpm_pkg_get_isize,
            alpm_pkg_get_reason,
            alpm_pkg_get_licenses,
            alpm_pkg_get_groups,
            alpm_pkg_get_depends,
            alpm_pkg_get_optdepends,
            alpm_pkg_get_checkdepends,
            alpm_pkg_get_makedepends,
            alpm_pkg_get_conflicts,
            alpm_pkg_get_provides,
            alpm_pkg_get_replaces,
            alpm_pkg_get_files,
            alpm_pkg_get_backup,
            alpm_pkg_get_db,
            alpm_pkg_get_base64_sig,
            alpm_pkg_get_sig,
            alpm_pkg_get_validation,
            alpm_pkg_has_scriptlet,
            alpm_pkg_download_size,
            alpm_pkg_set_reason,
            alpm_pkg_changelog_open,
            alpm_pkg_changelog_read,
            alpm_pkg_changelog_close,
            alpm_pkg_mtree_open,
            alpm_pkg_mtree_next,
            alpm_pkg_mtree_close,
            alpm_trans_get_flags,
            alpm_trans_get_add,
            alpm_trans_get_remove,
            alpm_trans_init,
            alpm_trans_prepare,
            alpm_trans_commit,
            alpm_trans_interrupt,
            alpm_trans_release,
            alpm_sync_sysupgrade,
            alpm_add_pkg,
            alpm_remove_pkg,
            alpm_sync_get_new_version,
            alpm_compute_md5sum,
            alpm_compute_sha256sum,
            alpm_unlock,
            alpm_version,
            alpm_capabilities,
        })
    }
    pub unsafe fn alpm_list_free(&self, list: *mut alpm_list_t) -> () {
        (self.alpm_list_free)(list)
    }
    pub unsafe fn alpm_list_free_inner(
        &self,
        list: *mut alpm_list_t,
        fn_: alpm_list_fn_free,
    ) -> () {
        (self.alpm_list_free_inner)(list, fn_)
    }
    pub unsafe fn alpm_list_add(
        &self,
        list: *mut alpm_list_t,
        data: *mut ::std::os::raw::c_void,
    ) -> *mut alpm_list_t {
        (self.alpm_list_add)(list, data)
    }
    pub unsafe fn alpm_list_append(
        &self,
        list: *mut *mut alpm_list_t,
        data: *mut ::std::os::raw::c_void,
    ) -> *mut alpm_list_t {
        (self.alpm_list_append)(list, data)
    }
    pub unsafe fn alpm_list_append_strdup(
        &self,
        list: *mut *mut alpm_list_t,
        data: *const ::std::os::raw::c_char,
    ) -> *mut alpm_list_t {
        (self.alpm_list_append_strdup)(list, data)
    }
    pub unsafe fn alpm_list_add_sorted(
        &self,
        list: *mut alpm_list_t,
        data: *mut ::std::os::raw::c_void,
        fn_: alpm_list_fn_cmp,
    ) -> *mut alpm_list_t {
        (self.alpm_list_add_sorted)(list, data, fn_)
    }
    pub unsafe fn alpm_list_join(
        &self,
        first: *mut alpm_list_t,
        second: *mut alpm_list_t,
    ) -> *mut alpm_list_t {
        (self.alpm_list_join)(first, second)
    }
    pub unsafe fn alpm_list_mmerge(
        &self,
        left: *mut alpm_list_t,
        right: *mut alpm_list_t,
        fn_: alpm_list_fn_cmp,
    ) -> *mut alpm_list_t {
        (self.alpm_list_mmerge)(left, right, fn_)
    }
    pub unsafe fn alpm_list_msort(
        &self,
        list: *mut alpm_list_t,
        n: usize,
        fn_: alpm_list_fn_cmp,
    ) -> *mut alpm_list_t {
        (self.alpm_list_msort)(list, n, fn_)
    }
    pub unsafe fn alpm_list_remove_item(
        &self,
        haystack: *mut alpm_list_t,
        item: *mut alpm_list_t,
    ) -> *mut alpm_list_t {
        (self.alpm_list_remove_item)(haystack, item)
    }
    pub unsafe fn alpm_list_remove(
        &self,
        haystack: *mut alpm_list_t,
        needle: *const ::std::os::raw::c_void,
        fn_: alpm_list_fn_cmp,
        data: *mut *mut ::std::os::raw::c_void,
    ) -> *mut alpm_list_t {
        (self.alpm_list_remove)(haystack, needle, fn_, data)
    }
    pub unsafe fn alpm_list_remove_str(
        &self,
        haystack: *mut alpm_list_t,
        needle: *const ::std::os::raw::c_char,
        data: *mut *mut ::std::os::raw::c_char,
    ) -> *mut alpm_list_t {
        (self.alpm_list_remove_str)(haystack, needle, data)
    }
    pub unsafe fn alpm_list_remove_dupes(&self, list: *const alpm_list_t) -> *mut alpm_list_t {
        (self.alpm_list_remove_dupes)(list)
    }
    pub unsafe fn alpm_list_strdup(&self, list: *const alpm_list_t) -> *mut alpm_list_t {
        (self.alpm_list_strdup)(list)
    }
    pub unsafe fn alpm_list_copy(&self, list: *const alpm_list_t) -> *mut alpm_list_t {
        (self.alpm_list_copy)(list)
    }
    pub unsafe fn alpm_list_copy_data(
        &self,
        list: *const alpm_list_t,
        size: usize,
    ) -> *mut alpm_list_t {
        (self.alpm_list_copy_data)(list, size)
    }
    pub unsafe fn alpm_list_reverse(&self, list: *mut alpm_list_t) -> *mut alpm_list_t {
        (self.alpm_list_reverse)(list)
    }
    pub unsafe fn alpm_list_nth(&self, list: *const alpm_list_t, n: usize) -> *mut alpm_list_t {
        (self.alpm_list_nth)(list, n)
    }
    pub unsafe fn alpm_list_next(&self, list: *const alpm_list_t) -> *mut alpm_list_t {
        (self.alpm_list_next)(list)
    }
    pub unsafe fn alpm_list_previous(&self, list: *const alpm_list_t) -> *mut alpm_list_t {
        (self.alpm_list_previous)(list)
    }
    pub unsafe fn alpm_list_last(&self, list: *const alpm_list_t) -> *mut alpm_list_t {
        (self.alpm_list_last)(list)
    }
    pub unsafe fn alpm_list_count(&self, list: *const alpm_list_t) -> usize {
        (self.alpm_list_count)(list)
    }
    pub unsafe fn alpm_list_find(
        &self,
        haystack: *const alpm_list_t,
        needle: *const ::std::os::raw::c_void,
        fn_: alpm_list_fn_cmp,
    ) -> *mut ::std::os::raw::c_void {
        (self.alpm_list_find)(haystack, needle, fn_)
    }
    pub unsafe fn alpm_list_find_ptr(
        &self,
        haystack: *const alpm_list_t,
        needle: *const ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void {
        (self.alpm_list_find_ptr)(haystack, needle)
    }
    pub unsafe fn alpm_list_find_str(
        &self,
        haystack: *const alpm_list_t,
        needle: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char {
        (self.alpm_list_find_str)(haystack, needle)
    }
    pub unsafe fn alpm_list_diff_sorted(
        &self,
        left: *const alpm_list_t,
        right: *const alpm_list_t,
        fn_: alpm_list_fn_cmp,
        onlyleft: *mut *mut alpm_list_t,
        onlyright: *mut *mut alpm_list_t,
    ) -> () {
        (self.alpm_list_diff_sorted)(left, right, fn_, onlyleft, onlyright)
    }
    pub unsafe fn alpm_list_diff(
        &self,
        lhs: *const alpm_list_t,
        rhs: *const alpm_list_t,
        fn_: alpm_list_fn_cmp,
    ) -> *mut alpm_list_t {
        (self.alpm_list_diff)(lhs, rhs, fn_)
    }
    pub unsafe fn alpm_list_to_array(
        &self,
        list: *const alpm_list_t,
        n: usize,
        size: usize,
    ) -> *mut ::std::os::raw::c_void {
        (self.alpm_list_to_array)(list, n, size)
    }
    #[doc = " Determines whether a package filelist contains a given path."]
    #[doc = " The provided path should be relative to the install root with no leading"]
    #[doc = " slashes, e.g. \"etc/localtime\". When searching for directories, the path must"]
    #[doc = " have a trailing slash."]
    #[doc = " @param filelist a pointer to a package filelist"]
    #[doc = " @param path the path to search for in the package"]
    #[doc = " @return a pointer to the matching file or NULL if not found"]
    pub unsafe fn alpm_filelist_contains(
        &self,
        filelist: *mut alpm_filelist_t,
        path: *const ::std::os::raw::c_char,
    ) -> *mut alpm_file_t {
        (self.alpm_filelist_contains)(filelist, path)
    }
    #[doc = " Find group members across a list of databases."]
    #[doc = " If a member exists in several databases, only the first database is used."]
    #[doc = " IgnorePkg is also handled."]
    #[doc = " @param dbs the list of alpm_db_t *"]
    #[doc = " @param name the name of the group"]
    #[doc = " @return the list of alpm_pkg_t * (caller is responsible for alpm_list_free)"]
    pub unsafe fn alpm_find_group_pkgs(
        &self,
        dbs: *mut alpm_list_t,
        name: *const ::std::os::raw::c_char,
    ) -> *mut alpm_list_t {
        (self.alpm_find_group_pkgs)(dbs, name)
    }
    #[doc = " Returns the current error code from the handle."]
    #[doc = " @param handle the context handle"]
    #[doc = " @return the current error code of the handle"]
    pub unsafe fn alpm_errno(&self, handle: *mut alpm_handle_t) -> alpm_errno_t {
        (self.alpm_errno)(handle)
    }
    #[doc = " Returns the string corresponding to an error number."]
    #[doc = " @param err the error code to get the string for"]
    #[doc = " @return the string relating to the given error code"]
    pub unsafe fn alpm_strerror(&self, err: alpm_errno_t) -> *const ::std::os::raw::c_char {
        (self.alpm_strerror)(err)
    }
    #[doc = " Initializes the library."]
    #[doc = " Creates handle, connects to database and creates lockfile."]
    #[doc = " This must be called before any other functions are called."]
    #[doc = " @param root the root path for all filesystem operations"]
    #[doc = " @param dbpath the absolute path to the libalpm database"]
    #[doc = " @param err an optional variable to hold any error return codes"]
    #[doc = " @return a context handle on success, NULL on error, err will be set if provided"]
    pub unsafe fn alpm_initialize(
        &self,
        root: *const ::std::os::raw::c_char,
        dbpath: *const ::std::os::raw::c_char,
        err: *mut alpm_errno_t,
    ) -> *mut alpm_handle_t {
        (self.alpm_initialize)(root, dbpath, err)
    }
    #[doc = " Release the library."]
    #[doc = " Disconnects from the database, removes handle and lockfile"]
    #[doc = " This should be the last alpm call you make."]
    #[doc = " After this returns, handle should be considered invalid and cannot be reused"]
    #[doc = " in any way."]
    #[doc = " @param handle the context handle"]
    #[doc = " @return 0 on success, -1 on error"]
    pub unsafe fn alpm_release(&self, handle: *mut alpm_handle_t) -> ::std::os::raw::c_int {
        (self.alpm_release)(handle)
    }
    #[doc = " Check the PGP signature for the given package file."]
    #[doc = " @param pkg the package to check"]
    #[doc = " @param siglist a pointer to storage for signature results"]
    #[doc = " @return a int value : 0 (valid), 1 (invalid), -1 (an error occurred)"]
    pub unsafe fn alpm_pkg_check_pgp_signature(
        &self,
        pkg: *mut alpm_pkg_t,
        siglist: *mut alpm_siglist_t,
    ) -> ::std::os::raw::c_int {
        (self.alpm_pkg_check_pgp_signature)(pkg, siglist)
    }
    #[doc = " Check the PGP signature for the given database."]
    #[doc = " @param db the database to check"]
    #[doc = " @param siglist a pointer to storage for signature results"]
    #[doc = " @return a int value : 0 (valid), 1 (invalid), -1 (an error occurred)"]
    pub unsafe fn alpm_db_check_pgp_signature(
        &self,
        db: *mut alpm_db_t,
        siglist: *mut alpm_siglist_t,
    ) -> ::std::os::raw::c_int {
        (self.alpm_db_check_pgp_signature)(db, siglist)
    }
    #[doc = " Clean up and free a signature result list."]
    #[doc = " Note that this does not free the siglist object itself in case that"]
    #[doc = " was allocated on the stack; this is the responsibility of the caller."]
    #[doc = " @param siglist a pointer to storage for signature results"]
    #[doc = " @return 0 on success, -1 on error"]
    pub unsafe fn alpm_siglist_cleanup(
        &self,
        siglist: *mut alpm_siglist_t,
    ) -> ::std::os::raw::c_int {
        (self.alpm_siglist_cleanup)(siglist)
    }
    #[doc = " Decode a loaded signature in base64 form."]
    #[doc = " @param base64_data the signature to attempt to decode"]
    #[doc = " @param data the decoded data; must be freed by the caller"]
    #[doc = " @param data_len the length of the returned data"]
    #[doc = " @return 0 on success, -1 on failure to properly decode"]
    pub unsafe fn alpm_decode_signature(
        &self,
        base64_data: *const ::std::os::raw::c_char,
        data: *mut *mut ::std::os::raw::c_uchar,
        data_len: *mut usize,
    ) -> ::std::os::raw::c_int {
        (self.alpm_decode_signature)(base64_data, data, data_len)
    }
    #[doc = " Extract the Issuer Key ID from a signature"]
    #[doc = " @param handle the context handle"]
    #[doc = " @param identifier the identifier of the key."]
    #[doc = " This may be the name of the package or the path to the package."]
    #[doc = " @param sig PGP signature"]
    #[doc = " @param len length of signature"]
    #[doc = " @param keys a pointer to storage for key IDs"]
    #[doc = " @return 0 on success, -1 on error"]
    pub unsafe fn alpm_extract_keyid(
        &self,
        handle: *mut alpm_handle_t,
        identifier: *const ::std::os::raw::c_char,
        sig: *const ::std::os::raw::c_uchar,
        len: usize,
        keys: *mut *mut alpm_list_t,
    ) -> ::std::os::raw::c_int {
        (self.alpm_extract_keyid)(handle, identifier, sig, len, keys)
    }
    #[doc = " Checks dependencies and returns missing ones in a list."]
    #[doc = " Dependencies can include versions with depmod operators."]
    #[doc = " @param handle the context handle"]
    #[doc = " @param pkglist the list of local packages"]
    #[doc = " @param remove an alpm_list_t* of packages to be removed"]
    #[doc = " @param upgrade an alpm_list_t* of packages to be upgraded (remove-then-upgrade)"]
    #[doc = " @param reversedeps handles the backward dependencies"]
    #[doc = " @return an alpm_list_t* of alpm_depmissing_t pointers."]
    pub unsafe fn alpm_checkdeps(
        &self,
        handle: *mut alpm_handle_t,
        pkglist: *mut alpm_list_t,
        remove: *mut alpm_list_t,
        upgrade: *mut alpm_list_t,
        reversedeps: ::std::os::raw::c_int,
    ) -> *mut alpm_list_t {
        (self.alpm_checkdeps)(handle, pkglist, remove, upgrade, reversedeps)
    }
    #[doc = " Find a package satisfying a specified dependency."]
    #[doc = " The dependency can include versions with depmod operators."]
    #[doc = " @param pkgs an alpm_list_t* of alpm_pkg_t where the satisfyer will be searched"]
    #[doc = " @param depstring package or provision name, versioned or not"]
    #[doc = " @return a alpm_pkg_t* satisfying depstring"]
    pub unsafe fn alpm_find_satisfier(
        &self,
        pkgs: *mut alpm_list_t,
        depstring: *const ::std::os::raw::c_char,
    ) -> *mut alpm_pkg_t {
        (self.alpm_find_satisfier)(pkgs, depstring)
    }
    #[doc = " Find a package satisfying a specified dependency."]
    #[doc = " First look for a literal, going through each db one by one. Then look for"]
    #[doc = " providers. The first satisfyer that belongs to an installed package is"]
    #[doc = " returned. If no providers belong to an installed package then an"]
    #[doc = " alpm_question_select_provider_t is created to select the provider."]
    #[doc = " The dependency can include versions with depmod operators."]
    #[doc = ""]
    #[doc = " @param handle the context handle"]
    #[doc = " @param dbs an alpm_list_t* of alpm_db_t where the satisfyer will be searched"]
    #[doc = " @param depstring package or provision name, versioned or not"]
    #[doc = " @return a alpm_pkg_t* satisfying depstring"]
    pub unsafe fn alpm_find_dbs_satisfier(
        &self,
        handle: *mut alpm_handle_t,
        dbs: *mut alpm_list_t,
        depstring: *const ::std::os::raw::c_char,
    ) -> *mut alpm_pkg_t {
        (self.alpm_find_dbs_satisfier)(handle, dbs, depstring)
    }
    #[doc = " Check the package conflicts in a database"]
    #[doc = ""]
    #[doc = " @param handle the context handle"]
    #[doc = " @param pkglist the list of packages to check"]
    #[doc = ""]
    #[doc = " @return an alpm_list_t of alpm_conflict_t"]
    pub unsafe fn alpm_checkconflicts(
        &self,
        handle: *mut alpm_handle_t,
        pkglist: *mut alpm_list_t,
    ) -> *mut alpm_list_t {
        (self.alpm_checkconflicts)(handle, pkglist)
    }
    #[doc = " Returns a newly allocated string representing the dependency information."]
    #[doc = " @param dep a dependency info structure"]
    #[doc = " @return a formatted string, e.g. \"glibc>=2.12\""]
    pub unsafe fn alpm_dep_compute_string(
        &self,
        dep: *const alpm_depend_t,
    ) -> *mut ::std::os::raw::c_char {
        (self.alpm_dep_compute_string)(dep)
    }
    #[doc = " Return a newly allocated dependency information parsed from a string"]
    #[doc = "\\link alpm_dep_free should be used to free the dependency \\endlink"]
    #[doc = " @param depstring a formatted string, e.g. \"glibc=2.12\""]
    #[doc = " @return a dependency info structure"]
    pub unsafe fn alpm_dep_from_string(
        &self,
        depstring: *const ::std::os::raw::c_char,
    ) -> *mut alpm_depend_t {
        (self.alpm_dep_from_string)(depstring)
    }
    #[doc = " Free a dependency info structure"]
    #[doc = " @param dep struct to free"]
    pub unsafe fn alpm_dep_free(&self, dep: *mut alpm_depend_t) -> () {
        (self.alpm_dep_free)(dep)
    }
    #[doc = " Free a fileconflict and its members."]
    #[doc = " @param conflict the fileconflict to free"]
    pub unsafe fn alpm_fileconflict_free(&self, conflict: *mut alpm_fileconflict_t) -> () {
        (self.alpm_fileconflict_free)(conflict)
    }
    #[doc = " Free a depmissing and its members"]
    #[doc = " @param miss the depmissing to free"]
    pub unsafe fn alpm_depmissing_free(&self, miss: *mut alpm_depmissing_t) -> () {
        (self.alpm_depmissing_free)(miss)
    }
    #[doc = " Free a conflict and its members."]
    #[doc = " @param conflict the conflict to free"]
    pub unsafe fn alpm_conflict_free(&self, conflict: *mut alpm_conflict_t) -> () {
        (self.alpm_conflict_free)(conflict)
    }
    #[doc = " Get the database of locally installed packages."]
    #[doc = " The returned pointer points to an internal structure"]
    #[doc = " of libalpm which should only be manipulated through"]
    #[doc = " libalpm functions."]
    #[doc = " @return a reference to the local database"]
    pub unsafe fn alpm_get_localdb(&self, handle: *mut alpm_handle_t) -> *mut alpm_db_t {
        (self.alpm_get_localdb)(handle)
    }
    #[doc = " Get the list of sync databases."]
    #[doc = " Returns a list of alpm_db_t structures, one for each registered"]
    #[doc = " sync database."]
    #[doc = ""]
    #[doc = " @param handle the context handle"]
    #[doc = " @return a reference to an internal list of alpm_db_t structures"]
    pub unsafe fn alpm_get_syncdbs(&self, handle: *mut alpm_handle_t) -> *mut alpm_list_t {
        (self.alpm_get_syncdbs)(handle)
    }
    #[doc = " Register a sync database of packages."]
    #[doc = " Databases can not be registered when there is an active transaction."]
    #[doc = ""]
    #[doc = " @param handle the context handle"]
    #[doc = " @param treename the name of the sync repository"]
    #[doc = " @param level what level of signature checking to perform on the"]
    #[doc = " database; note that this must be a '.sig' file type verification"]
    #[doc = " @return an alpm_db_t* on success (the value), NULL on error"]
    pub unsafe fn alpm_register_syncdb(
        &self,
        handle: *mut alpm_handle_t,
        treename: *const ::std::os::raw::c_char,
        level: ::std::os::raw::c_int,
    ) -> *mut alpm_db_t {
        (self.alpm_register_syncdb)(handle, treename, level)
    }
    #[doc = " Unregister all package databases."]
    #[doc = " Databases can not be unregistered while there is an active transaction."]
    #[doc = ""]
    #[doc = " @param handle the context handle"]
    #[doc = " @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub unsafe fn alpm_unregister_all_syncdbs(
        &self,
        handle: *mut alpm_handle_t,
    ) -> ::std::os::raw::c_int {
        (self.alpm_unregister_all_syncdbs)(handle)
    }
    #[doc = " Unregister a package database."]
    #[doc = " Databases can not be unregistered when there is an active transaction."]
    #[doc = ""]
    #[doc = " @param db pointer to the package database to unregister"]
    #[doc = " @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub unsafe fn alpm_db_unregister(&self, db: *mut alpm_db_t) -> ::std::os::raw::c_int {
        (self.alpm_db_unregister)(db)
    }
    #[doc = " Get the name of a package database."]
    #[doc = " @param db pointer to the package database"]
    #[doc = " @return the name of the package database, NULL on error"]
    pub unsafe fn alpm_db_get_name(&self, db: *const alpm_db_t) -> *const ::std::os::raw::c_char {
        (self.alpm_db_get_name)(db)
    }
    #[doc = " Get the signature verification level for a database."]
    #[doc = " Will return the default verification level if this database is set up"]
    #[doc = " with ALPM_SIG_USE_DEFAULT."]
    #[doc = " @param db pointer to the package database"]
    #[doc = " @return the signature verification level"]
    pub unsafe fn alpm_db_get_siglevel(&self, db: *mut alpm_db_t) -> ::std::os::raw::c_int {
        (self.alpm_db_get_siglevel)(db)
    }
    #[doc = " Check the validity of a database."]
    #[doc = " This is most useful for sync databases and verifying signature status."]
    #[doc = " If invalid, the handle error code will be set accordingly."]
    #[doc = " @param db pointer to the package database"]
    #[doc = " @return 0 if valid, -1 if invalid (pm_errno is set accordingly)"]
    pub unsafe fn alpm_db_get_valid(&self, db: *mut alpm_db_t) -> ::std::os::raw::c_int {
        (self.alpm_db_get_valid)(db)
    }
    #[doc = " Get the list of servers assigned to this db."]
    #[doc = " @param db pointer to the database to get the servers from"]
    #[doc = " @return a char* list of servers"]
    pub unsafe fn alpm_db_get_servers(&self, db: *const alpm_db_t) -> *mut alpm_list_t {
        (self.alpm_db_get_servers)(db)
    }
    #[doc = " Sets the list of servers for the database to use."]
    #[doc = " @param db the database to set the servers. The list will be duped and"]
    #[doc = " the original will still need to be freed by the caller."]
    #[doc = " @param servers a char* list of servers."]
    pub unsafe fn alpm_db_set_servers(
        &self,
        db: *mut alpm_db_t,
        servers: *mut alpm_list_t,
    ) -> ::std::os::raw::c_int {
        (self.alpm_db_set_servers)(db, servers)
    }
    #[doc = " Add a download server to a database."]
    #[doc = " @param db database pointer"]
    #[doc = " @param url url of the server"]
    #[doc = " @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub unsafe fn alpm_db_add_server(
        &self,
        db: *mut alpm_db_t,
        url: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int {
        (self.alpm_db_add_server)(db, url)
    }
    #[doc = " Remove a download server from a database."]
    #[doc = " @param db database pointer"]
    #[doc = " @param url url of the server"]
    #[doc = " @return 0 on success, 1 on server not present,"]
    #[doc = " -1 on error (pm_errno is set accordingly)"]
    pub unsafe fn alpm_db_remove_server(
        &self,
        db: *mut alpm_db_t,
        url: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int {
        (self.alpm_db_remove_server)(db, url)
    }
    #[doc = " Update package databases."]
    #[doc = ""]
    #[doc = " An update of the package databases in the list \\a dbs will be attempted."]
    #[doc = " Unless \\a force is true, the update will only be performed if the remote"]
    #[doc = " databases were modified since the last update."]
    #[doc = ""]
    #[doc = " This operation requires a database lock, and will return an applicable error"]
    #[doc = " if the lock could not be obtained."]
    #[doc = ""]
    #[doc = " Example:"]
    #[doc = " @code"]
    #[doc = " alpm_list_t *dbs = alpm_get_syncdbs(config->handle);"]
    #[doc = " ret = alpm_db_update(config->handle, dbs, force);"]
    #[doc = " if(ret < 0) {"]
    #[doc = "     pm_printf(ALPM_LOG_ERROR, _(\"failed to synchronize all databases (%s)\\n\"),"]
    #[doc = "         alpm_strerror(alpm_errno(config->handle)));"]
    #[doc = " }"]
    #[doc = " @endcode"]
    #[doc = ""]
    #[doc = " @note After a successful update, the \\link alpm_db_get_pkgcache()"]
    #[doc = " package cache \\endlink will be invalidated"]
    #[doc = " @param handle the context handle"]
    #[doc = " @param dbs list of package databases to update"]
    #[doc = " @param force if true, then forces the update, otherwise update only in case"]
    #[doc = " the databases aren't up to date"]
    #[doc = " @return 0 on success, -1 on error (pm_errno is set accordingly),"]
    #[doc = " 1 if all databases are up to to date"]
    pub unsafe fn alpm_db_update(
        &self,
        handle: *mut alpm_handle_t,
        dbs: *mut alpm_list_t,
        force: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        (self.alpm_db_update)(handle, dbs, force)
    }
    #[doc = " Get a package entry from a package database."]
    #[doc = " Looking up a package is O(1) and will be significantly faster than"]
    #[doc = " iterating over the pkgcahe."]
    #[doc = " @param db pointer to the package database to get the package from"]
    #[doc = " @param name of the package"]
    #[doc = " @return the package entry on success, NULL on error"]
    pub unsafe fn alpm_db_get_pkg(
        &self,
        db: *mut alpm_db_t,
        name: *const ::std::os::raw::c_char,
    ) -> *mut alpm_pkg_t {
        (self.alpm_db_get_pkg)(db, name)
    }
    #[doc = " Get the package cache of a package database."]
    #[doc = " This is a list of all packages the db contains."]
    #[doc = " @param db pointer to the package database to get the package from"]
    #[doc = " @return the list of packages on success, NULL on error"]
    pub unsafe fn alpm_db_get_pkgcache(&self, db: *mut alpm_db_t) -> *mut alpm_list_t {
        (self.alpm_db_get_pkgcache)(db)
    }
    #[doc = " Get a group entry from a package database."]
    #[doc = " Looking up a group is O(1) and will be significantly faster than"]
    #[doc = " iterating over the groupcahe."]
    #[doc = " @param db pointer to the package database to get the group from"]
    #[doc = " @param name of the group"]
    #[doc = " @return the groups entry on success, NULL on error"]
    pub unsafe fn alpm_db_get_group(
        &self,
        db: *mut alpm_db_t,
        name: *const ::std::os::raw::c_char,
    ) -> *mut alpm_group_t {
        (self.alpm_db_get_group)(db, name)
    }
    #[doc = " Get the group cache of a package database."]
    #[doc = " @param db pointer to the package database to get the group from"]
    #[doc = " @return the list of groups on success, NULL on error"]
    pub unsafe fn alpm_db_get_groupcache(&self, db: *mut alpm_db_t) -> *mut alpm_list_t {
        (self.alpm_db_get_groupcache)(db)
    }
    #[doc = " Searches a database with regular expressions."]
    #[doc = " @param db pointer to the package database to search in"]
    #[doc = " @param needles a list of regular expressions to search for"]
    #[doc = " @param ret pointer to list for storing packages matching all"]
    #[doc = " regular expressions - must point to an empty (NULL) alpm_list_t *."]
    #[doc = " @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub unsafe fn alpm_db_search(
        &self,
        db: *mut alpm_db_t,
        needles: *const alpm_list_t,
        ret: *mut *mut alpm_list_t,
    ) -> ::std::os::raw::c_int {
        (self.alpm_db_search)(db, needles, ret)
    }
    #[doc = " Sets the usage of a database."]
    #[doc = " @param db pointer to the package database to set the status for"]
    #[doc = " @param usage a bitmask of alpm_db_usage_t values"]
    #[doc = " @return 0 on success, or -1 on error"]
    pub unsafe fn alpm_db_set_usage(
        &self,
        db: *mut alpm_db_t,
        usage: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        (self.alpm_db_set_usage)(db, usage)
    }
    #[doc = " Gets the usage of a database."]
    #[doc = " @param db pointer to the package database to get the status of"]
    #[doc = " @param usage pointer to an alpm_db_usage_t to store db's status"]
    #[doc = " @return 0 on success, or -1 on error"]
    pub unsafe fn alpm_db_get_usage(
        &self,
        db: *mut alpm_db_t,
        usage: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        (self.alpm_db_get_usage)(db, usage)
    }
    #[doc = " Returns the callback used for logging."]
    #[doc = " @param handle the context handle"]
    #[doc = " @return the currently set log callback"]
    pub unsafe fn alpm_option_get_logcb(&self, handle: *mut alpm_handle_t) -> alpm_cb_log {
        (self.alpm_option_get_logcb)(handle)
    }
    #[doc = " Returns the callback used for logging."]
    #[doc = " @param handle the context handle"]
    #[doc = " @return the currently set log callback context"]
    pub unsafe fn alpm_option_get_logcb_ctx(
        &self,
        handle: *mut alpm_handle_t,
    ) -> *mut ::std::os::raw::c_void {
        (self.alpm_option_get_logcb_ctx)(handle)
    }
    #[doc = " Sets the callback used for logging."]
    #[doc = " @param handle the context handle"]
    #[doc = " @param cb the cb to use"]
    #[doc = " @param ctx user-provided context to pass to cb"]
    #[doc = " @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub unsafe fn alpm_option_set_logcb(
        &self,
        handle: *mut alpm_handle_t,
        cb: alpm_cb_log,
        ctx: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int {
        (self.alpm_option_set_logcb)(handle, cb, ctx)
    }
    #[doc = " Returns the callback used to report download progress."]
    #[doc = " @param handle the context handle"]
    #[doc = " @return the currently set download callback"]
    pub unsafe fn alpm_option_get_dlcb(&self, handle: *mut alpm_handle_t) -> alpm_cb_download {
        (self.alpm_option_get_dlcb)(handle)
    }
    #[doc = " Returns the callback used to report download progress."]
    #[doc = " @param handle the context handle"]
    #[doc = " @return the currently set download callback context"]
    pub unsafe fn alpm_option_get_dlcb_ctx(
        &self,
        handle: *mut alpm_handle_t,
    ) -> *mut ::std::os::raw::c_void {
        (self.alpm_option_get_dlcb_ctx)(handle)
    }
    #[doc = " Sets the callback used to report download progress."]
    #[doc = " @param handle the context handle"]
    #[doc = " @param cb the cb to use"]
    #[doc = " @param ctx user-provided context to pass to cb"]
    #[doc = " @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub unsafe fn alpm_option_set_dlcb(
        &self,
        handle: *mut alpm_handle_t,
        cb: alpm_cb_download,
        ctx: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int {
        (self.alpm_option_set_dlcb)(handle, cb, ctx)
    }
    #[doc = " Returns the downloading callback."]
    #[doc = " @param handle the context handle"]
    #[doc = " @return the currently set fetch callback"]
    pub unsafe fn alpm_option_get_fetchcb(&self, handle: *mut alpm_handle_t) -> alpm_cb_fetch {
        (self.alpm_option_get_fetchcb)(handle)
    }
    #[doc = " Returns the downloading callback."]
    #[doc = " @param handle the context handle"]
    #[doc = " @return the currently set fetch callback context"]
    pub unsafe fn alpm_option_get_fetchcb_ctx(
        &self,
        handle: *mut alpm_handle_t,
    ) -> *mut ::std::os::raw::c_void {
        (self.alpm_option_get_fetchcb_ctx)(handle)
    }
    #[doc = " Sets the downloading callback."]
    #[doc = " @param handle the context handle"]
    #[doc = " @param cb the cb to use"]
    #[doc = " @param ctx user-provided context to pass to cb"]
    #[doc = " @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub unsafe fn alpm_option_set_fetchcb(
        &self,
        handle: *mut alpm_handle_t,
        cb: alpm_cb_fetch,
        ctx: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int {
        (self.alpm_option_set_fetchcb)(handle, cb, ctx)
    }
    #[doc = " Returns the callback used for events."]
    #[doc = " @param handle the context handle"]
    #[doc = " @return the currently set event callback"]
    pub unsafe fn alpm_option_get_eventcb(&self, handle: *mut alpm_handle_t) -> alpm_cb_event {
        (self.alpm_option_get_eventcb)(handle)
    }
    #[doc = " Returns the callback used for events."]
    #[doc = " @param handle the context handle"]
    #[doc = " @return the currently set event callback context"]
    pub unsafe fn alpm_option_get_eventcb_ctx(
        &self,
        handle: *mut alpm_handle_t,
    ) -> *mut ::std::os::raw::c_void {
        (self.alpm_option_get_eventcb_ctx)(handle)
    }
    #[doc = " Sets the callback used for events."]
    #[doc = " @param handle the context handle"]
    #[doc = " @param cb the cb to use"]
    #[doc = " @param ctx user-provided context to pass to cb"]
    #[doc = " @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub unsafe fn alpm_option_set_eventcb(
        &self,
        handle: *mut alpm_handle_t,
        cb: alpm_cb_event,
        ctx: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int {
        (self.alpm_option_set_eventcb)(handle, cb, ctx)
    }
    #[doc = " Returns the callback used for questions."]
    #[doc = " @param handle the context handle"]
    #[doc = " @return the currently set question callback"]
    pub unsafe fn alpm_option_get_questioncb(
        &self,
        handle: *mut alpm_handle_t,
    ) -> alpm_cb_question {
        (self.alpm_option_get_questioncb)(handle)
    }
    #[doc = " Returns the callback used for questions."]
    #[doc = " @param handle the context handle"]
    #[doc = " @return the currently set question callback context"]
    pub unsafe fn alpm_option_get_questioncb_ctx(
        &self,
        handle: *mut alpm_handle_t,
    ) -> *mut ::std::os::raw::c_void {
        (self.alpm_option_get_questioncb_ctx)(handle)
    }
    #[doc = " Sets the callback used for questions."]
    #[doc = " @param handle the context handle"]
    #[doc = " @param cb the cb to use"]
    #[doc = " @param ctx user-provided context to pass to cb"]
    #[doc = " @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub unsafe fn alpm_option_set_questioncb(
        &self,
        handle: *mut alpm_handle_t,
        cb: alpm_cb_question,
        ctx: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int {
        (self.alpm_option_set_questioncb)(handle, cb, ctx)
    }
    #[doc = "Returns the callback used for operation progress."]
    #[doc = " @param handle the context handle"]
    #[doc = " @return the currently set progress callback"]
    pub unsafe fn alpm_option_get_progresscb(
        &self,
        handle: *mut alpm_handle_t,
    ) -> alpm_cb_progress {
        (self.alpm_option_get_progresscb)(handle)
    }
    #[doc = "Returns the callback used for operation progress."]
    #[doc = " @param handle the context handle"]
    #[doc = " @return the currently set progress callback context"]
    pub unsafe fn alpm_option_get_progresscb_ctx(
        &self,
        handle: *mut alpm_handle_t,
    ) -> *mut ::std::os::raw::c_void {
        (self.alpm_option_get_progresscb_ctx)(handle)
    }
    #[doc = " Sets the callback used for operation progress."]
    #[doc = " @param handle the context handle"]
    #[doc = " @param cb the cb to use"]
    #[doc = " @param ctx user-provided context to pass to cb"]
    #[doc = " @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub unsafe fn alpm_option_set_progresscb(
        &self,
        handle: *mut alpm_handle_t,
        cb: alpm_cb_progress,
        ctx: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int {
        (self.alpm_option_set_progresscb)(handle, cb, ctx)
    }
    #[doc = " Returns the root path. Read-only."]
    #[doc = " @param handle the context handle"]
    pub unsafe fn alpm_option_get_root(
        &self,
        handle: *mut alpm_handle_t,
    ) -> *const ::std::os::raw::c_char {
        (self.alpm_option_get_root)(handle)
    }
    #[doc = " Returns the path to the database directory. Read-only."]
    #[doc = " @param handle the context handle"]
    pub unsafe fn alpm_option_get_dbpath(
        &self,
        handle: *mut alpm_handle_t,
    ) -> *const ::std::os::raw::c_char {
        (self.alpm_option_get_dbpath)(handle)
    }
    #[doc = " Get the name of the database lock file. Read-only."]
    #[doc = " This is the name that the lockfile would have. It does not"]
    #[doc = " matter if the lockfile actually exists on disk."]
    #[doc = " @param handle the context handle"]
    pub unsafe fn alpm_option_get_lockfile(
        &self,
        handle: *mut alpm_handle_t,
    ) -> *const ::std::os::raw::c_char {
        (self.alpm_option_get_lockfile)(handle)
    }
    #[doc = " Gets the currently configured cachedirs,"]
    #[doc = " @param handle the context handle"]
    #[doc = " @return a char* list of cache directories"]
    pub unsafe fn alpm_option_get_cachedirs(&self, handle: *mut alpm_handle_t) -> *mut alpm_list_t {
        (self.alpm_option_get_cachedirs)(handle)
    }
    #[doc = " Sets the cachedirs."]
    #[doc = " @param handle the context handle"]
    #[doc = " @param cachedirs a char* list of cachdirs. The list will be duped and"]
    #[doc = " the original will still need to be freed by the caller."]
    #[doc = " @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub unsafe fn alpm_option_set_cachedirs(
        &self,
        handle: *mut alpm_handle_t,
        cachedirs: *mut alpm_list_t,
    ) -> ::std::os::raw::c_int {
        (self.alpm_option_set_cachedirs)(handle, cachedirs)
    }
    #[doc = " Append a cachedir to the configured cachedirs."]
    #[doc = " @param handle the context handle"]
    #[doc = " @param cachedir the cachedir to add"]
    #[doc = " @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub unsafe fn alpm_option_add_cachedir(
        &self,
        handle: *mut alpm_handle_t,
        cachedir: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int {
        (self.alpm_option_add_cachedir)(handle, cachedir)
    }
    #[doc = " Remove a cachedir from the configured cachedirs."]
    #[doc = " @param handle the context handle"]
    #[doc = " @param cachedir the cachedir to remove"]
    #[doc = " @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub unsafe fn alpm_option_remove_cachedir(
        &self,
        handle: *mut alpm_handle_t,
        cachedir: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int {
        (self.alpm_option_remove_cachedir)(handle, cachedir)
    }
    #[doc = " Gets the currently configured hookdirs,"]
    #[doc = " @param handle the context handle"]
    #[doc = " @return a char* list of hook directories"]
    pub unsafe fn alpm_option_get_hookdirs(&self, handle: *mut alpm_handle_t) -> *mut alpm_list_t {
        (self.alpm_option_get_hookdirs)(handle)
    }
    #[doc = " Sets the hookdirs."]
    #[doc = " @param handle the context handle"]
    #[doc = " @param hookdirs a char* list of hookdirs. The list will be duped and"]
    #[doc = " the original will still need to be freed by the caller."]
    #[doc = " @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub unsafe fn alpm_option_set_hookdirs(
        &self,
        handle: *mut alpm_handle_t,
        hookdirs: *mut alpm_list_t,
    ) -> ::std::os::raw::c_int {
        (self.alpm_option_set_hookdirs)(handle, hookdirs)
    }
    #[doc = " Append a hookdir to the configured hookdirs."]
    #[doc = " @param handle the context handle"]
    #[doc = " @param hookdir the hookdir to add"]
    #[doc = " @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub unsafe fn alpm_option_add_hookdir(
        &self,
        handle: *mut alpm_handle_t,
        hookdir: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int {
        (self.alpm_option_add_hookdir)(handle, hookdir)
    }
    #[doc = " Remove a hookdir from the configured hookdirs."]
    #[doc = " @param handle the context handle"]
    #[doc = " @param hookdir the hookdir to remove"]
    #[doc = " @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub unsafe fn alpm_option_remove_hookdir(
        &self,
        handle: *mut alpm_handle_t,
        hookdir: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int {
        (self.alpm_option_remove_hookdir)(handle, hookdir)
    }
    #[doc = " Gets the currently configured overwritable files,"]
    #[doc = " @param handle the context handle"]
    #[doc = " @return a char* list of overwritable file globs"]
    pub unsafe fn alpm_option_get_overwrite_files(
        &self,
        handle: *mut alpm_handle_t,
    ) -> *mut alpm_list_t {
        (self.alpm_option_get_overwrite_files)(handle)
    }
    #[doc = " Sets the overwritable files."]
    #[doc = " @param handle the context handle"]
    #[doc = " @param globs a char* list of overwritable file globs. The list will be duped and"]
    #[doc = " the original will still need to be freed by the caller."]
    #[doc = " @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub unsafe fn alpm_option_set_overwrite_files(
        &self,
        handle: *mut alpm_handle_t,
        globs: *mut alpm_list_t,
    ) -> ::std::os::raw::c_int {
        (self.alpm_option_set_overwrite_files)(handle, globs)
    }
    #[doc = " Append an overwritable file to the configured overwritable files."]
    #[doc = " @param handle the context handle"]
    #[doc = " @param glob the file glob to add"]
    #[doc = " @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub unsafe fn alpm_option_add_overwrite_file(
        &self,
        handle: *mut alpm_handle_t,
        glob: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int {
        (self.alpm_option_add_overwrite_file)(handle, glob)
    }
    #[doc = " Remove a file glob from the configured overwritable files globs."]
    #[doc = " @note The overwritable file list contains a list of globs. The glob to"]
    #[doc = " remove must exactly match the entry to remove. There is no glob expansion."]
    #[doc = " @param handle the context handle"]
    #[doc = " @param glob the file glob to remove"]
    #[doc = " @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub unsafe fn alpm_option_remove_overwrite_file(
        &self,
        handle: *mut alpm_handle_t,
        glob: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int {
        (self.alpm_option_remove_overwrite_file)(handle, glob)
    }
    #[doc = " Gets the filepath to the currently set logfile."]
    #[doc = " @param handle the context handle"]
    #[doc = " @return the path to the logfile"]
    pub unsafe fn alpm_option_get_logfile(
        &self,
        handle: *mut alpm_handle_t,
    ) -> *const ::std::os::raw::c_char {
        (self.alpm_option_get_logfile)(handle)
    }
    #[doc = " Sets the logfile path."]
    #[doc = " @param handle the context handle"]
    #[doc = " @param logfile path to the new location of the logfile"]
    #[doc = " @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub unsafe fn alpm_option_set_logfile(
        &self,
        handle: *mut alpm_handle_t,
        logfile: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int {
        (self.alpm_option_set_logfile)(handle, logfile)
    }
    #[doc = " Returns the path to libalpm's GnuPG home directory."]
    #[doc = " @param handle the context handle"]
    #[doc = " @return the path to libalpms's GnuPG home directory"]
    pub unsafe fn alpm_option_get_gpgdir(
        &self,
        handle: *mut alpm_handle_t,
    ) -> *const ::std::os::raw::c_char {
        (self.alpm_option_get_gpgdir)(handle)
    }
    #[doc = " Sets the path to libalpm's GnuPG home directory."]
    #[doc = " @param handle the context handle"]
    #[doc = " @param gpgdir the gpgdir to set"]
    pub unsafe fn alpm_option_set_gpgdir(
        &self,
        handle: *mut alpm_handle_t,
        gpgdir: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int {
        (self.alpm_option_set_gpgdir)(handle, gpgdir)
    }
    #[doc = " Returns whether to use syslog (0 is FALSE, TRUE otherwise)."]
    #[doc = " @param handle the context handle"]
    #[doc = " @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub unsafe fn alpm_option_get_usesyslog(
        &self,
        handle: *mut alpm_handle_t,
    ) -> ::std::os::raw::c_int {
        (self.alpm_option_get_usesyslog)(handle)
    }
    #[doc = " Sets whether to use syslog (0 is FALSE, TRUE otherwise)."]
    #[doc = " @param handle the context handle"]
    #[doc = " @param usesyslog whether to use the syslog (0 is FALSE, TRUE otherwise)"]
    pub unsafe fn alpm_option_set_usesyslog(
        &self,
        handle: *mut alpm_handle_t,
        usesyslog: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        (self.alpm_option_set_usesyslog)(handle, usesyslog)
    }
    #[doc = " Get the list of no-upgrade files"]
    #[doc = " @param handle the context handle"]
    #[doc = " @return the char* list of no-upgrade files"]
    pub unsafe fn alpm_option_get_noupgrades(
        &self,
        handle: *mut alpm_handle_t,
    ) -> *mut alpm_list_t {
        (self.alpm_option_get_noupgrades)(handle)
    }
    #[doc = " Add a file to the no-upgrade list"]
    #[doc = " @param handle the context handle"]
    #[doc = " @param path the path to add"]
    #[doc = " @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub unsafe fn alpm_option_add_noupgrade(
        &self,
        handle: *mut alpm_handle_t,
        path: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int {
        (self.alpm_option_add_noupgrade)(handle, path)
    }
    #[doc = " Sets the list of no-upgrade files"]
    #[doc = " @param handle the context handle"]
    #[doc = " @param noupgrade a char* list of file to not upgrade."]
    #[doc = " The list will be duped and the original will still need to be freed by the caller."]
    #[doc = " @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub unsafe fn alpm_option_set_noupgrades(
        &self,
        handle: *mut alpm_handle_t,
        noupgrade: *mut alpm_list_t,
    ) -> ::std::os::raw::c_int {
        (self.alpm_option_set_noupgrades)(handle, noupgrade)
    }
    #[doc = " Remove an entry from the no-upgrade list"]
    #[doc = " @param handle the context handle"]
    #[doc = " @param path the path to remove"]
    #[doc = " @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub unsafe fn alpm_option_remove_noupgrade(
        &self,
        handle: *mut alpm_handle_t,
        path: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int {
        (self.alpm_option_remove_noupgrade)(handle, path)
    }
    #[doc = " Test if a path matches any of the globs in the no-upgrade list"]
    #[doc = " @param handle the context handle"]
    #[doc = " @param path the path to test"]
    #[doc = " @return 0 is the path matches a glob, negative if there is no match and"]
    #[doc = " positive is the  match was inverted"]
    pub unsafe fn alpm_option_match_noupgrade(
        &self,
        handle: *mut alpm_handle_t,
        path: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int {
        (self.alpm_option_match_noupgrade)(handle, path)
    }
    #[doc = " Get the list of no-extract files"]
    #[doc = " @param handle the context handle"]
    #[doc = " @return the char* list of no-extract files"]
    pub unsafe fn alpm_option_get_noextracts(
        &self,
        handle: *mut alpm_handle_t,
    ) -> *mut alpm_list_t {
        (self.alpm_option_get_noextracts)(handle)
    }
    #[doc = " Add a file to the no-extract list"]
    #[doc = " @param handle the context handle"]
    #[doc = " @param path the path to add"]
    #[doc = " @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub unsafe fn alpm_option_add_noextract(
        &self,
        handle: *mut alpm_handle_t,
        path: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int {
        (self.alpm_option_add_noextract)(handle, path)
    }
    #[doc = " Sets the list of no-extract files"]
    #[doc = " @param handle the context handle"]
    #[doc = " @param noextract a char* list of file to not extract."]
    #[doc = " The list will be duped and the original will still need to be freed by the caller."]
    #[doc = " @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub unsafe fn alpm_option_set_noextracts(
        &self,
        handle: *mut alpm_handle_t,
        noextract: *mut alpm_list_t,
    ) -> ::std::os::raw::c_int {
        (self.alpm_option_set_noextracts)(handle, noextract)
    }
    #[doc = " Remove an entry from the no-extract list"]
    #[doc = " @param handle the context handle"]
    #[doc = " @param path the path to remove"]
    #[doc = " @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub unsafe fn alpm_option_remove_noextract(
        &self,
        handle: *mut alpm_handle_t,
        path: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int {
        (self.alpm_option_remove_noextract)(handle, path)
    }
    #[doc = " Test if a path matches any of the globs in the no-extract list"]
    #[doc = " @param handle the context handle"]
    #[doc = " @param path the path to test"]
    #[doc = " @return 0 is the path matches a glob, negative if there is no match and"]
    #[doc = " positive is the  match was inverted"]
    pub unsafe fn alpm_option_match_noextract(
        &self,
        handle: *mut alpm_handle_t,
        path: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int {
        (self.alpm_option_match_noextract)(handle, path)
    }
    #[doc = " Get the list of ignored packages"]
    #[doc = " @param handle the context handle"]
    #[doc = " @return the char* list of ignored packages"]
    pub unsafe fn alpm_option_get_ignorepkgs(
        &self,
        handle: *mut alpm_handle_t,
    ) -> *mut alpm_list_t {
        (self.alpm_option_get_ignorepkgs)(handle)
    }
    #[doc = " Add a file to the ignored package list"]
    #[doc = " @param handle the context handle"]
    #[doc = " @param pkg the package to add"]
    #[doc = " @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub unsafe fn alpm_option_add_ignorepkg(
        &self,
        handle: *mut alpm_handle_t,
        pkg: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int {
        (self.alpm_option_add_ignorepkg)(handle, pkg)
    }
    #[doc = " Sets the list of packages to ignore"]
    #[doc = " @param handle the context handle"]
    #[doc = " @param ignorepkgs a char* list of packages to ignore"]
    #[doc = " The list will be duped and the original will still need to be freed by the caller."]
    #[doc = " @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub unsafe fn alpm_option_set_ignorepkgs(
        &self,
        handle: *mut alpm_handle_t,
        ignorepkgs: *mut alpm_list_t,
    ) -> ::std::os::raw::c_int {
        (self.alpm_option_set_ignorepkgs)(handle, ignorepkgs)
    }
    #[doc = " Remove an entry from the ignorepkg list"]
    #[doc = " @param handle the context handle"]
    #[doc = " @param pkg the package to remove"]
    #[doc = " @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub unsafe fn alpm_option_remove_ignorepkg(
        &self,
        handle: *mut alpm_handle_t,
        pkg: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int {
        (self.alpm_option_remove_ignorepkg)(handle, pkg)
    }
    #[doc = " Get the list of ignored groups"]
    #[doc = " @param handle the context handle"]
    #[doc = " @return the char* list of ignored groups"]
    pub unsafe fn alpm_option_get_ignoregroups(
        &self,
        handle: *mut alpm_handle_t,
    ) -> *mut alpm_list_t {
        (self.alpm_option_get_ignoregroups)(handle)
    }
    #[doc = " Add a file to the ignored group list"]
    #[doc = " @param handle the context handle"]
    #[doc = " @param grp the group to add"]
    #[doc = " @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub unsafe fn alpm_option_add_ignoregroup(
        &self,
        handle: *mut alpm_handle_t,
        grp: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int {
        (self.alpm_option_add_ignoregroup)(handle, grp)
    }
    #[doc = " Sets the list of groups to ignore"]
    #[doc = " @param handle the context handle"]
    #[doc = " @param ignoregrps a char* list of groups to ignore"]
    #[doc = " The list will be duped and the original will still need to be freed by the caller."]
    #[doc = " @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub unsafe fn alpm_option_set_ignoregroups(
        &self,
        handle: *mut alpm_handle_t,
        ignoregrps: *mut alpm_list_t,
    ) -> ::std::os::raw::c_int {
        (self.alpm_option_set_ignoregroups)(handle, ignoregrps)
    }
    #[doc = " Remove an entry from the ignoregroup list"]
    #[doc = " @param handle the context handle"]
    #[doc = " @param grp the group to remove"]
    #[doc = " @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub unsafe fn alpm_option_remove_ignoregroup(
        &self,
        handle: *mut alpm_handle_t,
        grp: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int {
        (self.alpm_option_remove_ignoregroup)(handle, grp)
    }
    #[doc = " Gets the list of dependencies that are assumed to be met"]
    #[doc = " @param handle the context handle"]
    #[doc = " @return a list of alpm_depend_t*"]
    pub unsafe fn alpm_option_get_assumeinstalled(
        &self,
        handle: *mut alpm_handle_t,
    ) -> *mut alpm_list_t {
        (self.alpm_option_get_assumeinstalled)(handle)
    }
    #[doc = " Add a depend to the assumed installed list"]
    #[doc = " @param handle the context handle"]
    #[doc = " @param dep the dependency to add"]
    #[doc = " @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub unsafe fn alpm_option_add_assumeinstalled(
        &self,
        handle: *mut alpm_handle_t,
        dep: *const alpm_depend_t,
    ) -> ::std::os::raw::c_int {
        (self.alpm_option_add_assumeinstalled)(handle, dep)
    }
    #[doc = " Sets the list of dependencies that are assumed to be met"]
    #[doc = " @param handle the context handle"]
    #[doc = " @param deps a list of *alpm_depend_t"]
    #[doc = " The list will be duped and the original will still need to be freed by the caller."]
    #[doc = " @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub unsafe fn alpm_option_set_assumeinstalled(
        &self,
        handle: *mut alpm_handle_t,
        deps: *mut alpm_list_t,
    ) -> ::std::os::raw::c_int {
        (self.alpm_option_set_assumeinstalled)(handle, deps)
    }
    #[doc = " Remove an entry from the assume installed list"]
    #[doc = " @param handle the context handle"]
    #[doc = " @param dep the dep to remove"]
    #[doc = " @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub unsafe fn alpm_option_remove_assumeinstalled(
        &self,
        handle: *mut alpm_handle_t,
        dep: *const alpm_depend_t,
    ) -> ::std::os::raw::c_int {
        (self.alpm_option_remove_assumeinstalled)(handle, dep)
    }
    #[doc = " Returns the allowed package architecture."]
    #[doc = " @param handle the context handle"]
    #[doc = " @return the configured package architectures"]
    pub unsafe fn alpm_option_get_architectures(
        &self,
        handle: *mut alpm_handle_t,
    ) -> *mut alpm_list_t {
        (self.alpm_option_get_architectures)(handle)
    }
    #[doc = " Adds an allowed package architecture."]
    #[doc = " @param handle the context handle"]
    #[doc = " @param arch the architecture to set"]
    pub unsafe fn alpm_option_add_architecture(
        &self,
        handle: *mut alpm_handle_t,
        arch: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int {
        (self.alpm_option_add_architecture)(handle, arch)
    }
    #[doc = " Sets the allowed package architecture."]
    #[doc = " @param handle the context handle"]
    #[doc = " @param arches the architecture to set"]
    pub unsafe fn alpm_option_set_architectures(
        &self,
        handle: *mut alpm_handle_t,
        arches: *mut alpm_list_t,
    ) -> ::std::os::raw::c_int {
        (self.alpm_option_set_architectures)(handle, arches)
    }
    #[doc = " Removes an allowed package architecture."]
    #[doc = " @param handle the context handle"]
    #[doc = " @param arch the architecture to remove"]
    pub unsafe fn alpm_option_remove_architecture(
        &self,
        handle: *mut alpm_handle_t,
        arch: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int {
        (self.alpm_option_remove_architecture)(handle, arch)
    }
    #[doc = " Get whether or not checking for free space before installing packages is enabled."]
    #[doc = " @param handle the context handle"]
    #[doc = " @return 0 if disabled, 1 if enabled"]
    pub unsafe fn alpm_option_get_checkspace(
        &self,
        handle: *mut alpm_handle_t,
    ) -> ::std::os::raw::c_int {
        (self.alpm_option_get_checkspace)(handle)
    }
    #[doc = " Enable/disable checking free space before installing packages."]
    #[doc = " @param handle the context handle"]
    #[doc = " @param checkspace 0 for disabled, 1 for enabled"]
    pub unsafe fn alpm_option_set_checkspace(
        &self,
        handle: *mut alpm_handle_t,
        checkspace: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        (self.alpm_option_set_checkspace)(handle, checkspace)
    }
    #[doc = " Gets the configured database extension."]
    #[doc = " @param handle the context handle"]
    #[doc = " @return the configured database extension"]
    pub unsafe fn alpm_option_get_dbext(
        &self,
        handle: *mut alpm_handle_t,
    ) -> *const ::std::os::raw::c_char {
        (self.alpm_option_get_dbext)(handle)
    }
    #[doc = " Sets the database extension."]
    #[doc = " @param handle the context handle"]
    #[doc = " @param dbext the database extension to use"]
    #[doc = " @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub unsafe fn alpm_option_set_dbext(
        &self,
        handle: *mut alpm_handle_t,
        dbext: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int {
        (self.alpm_option_set_dbext)(handle, dbext)
    }
    #[doc = " Get the default siglevel."]
    #[doc = " @param handle the context handle"]
    #[doc = " @return a \\link alpm_siglevel_t \\endlink bitfield of the siglevel"]
    pub unsafe fn alpm_option_get_default_siglevel(
        &self,
        handle: *mut alpm_handle_t,
    ) -> ::std::os::raw::c_int {
        (self.alpm_option_get_default_siglevel)(handle)
    }
    #[doc = " Set the default siglevel."]
    #[doc = " @param handle the context handle"]
    #[doc = " @param level a \\link alpm_siglevel_t \\endlink bitfield of the level to set"]
    #[doc = " @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub unsafe fn alpm_option_set_default_siglevel(
        &self,
        handle: *mut alpm_handle_t,
        level: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        (self.alpm_option_set_default_siglevel)(handle, level)
    }
    #[doc = " Get the configured local file siglevel."]
    #[doc = " @param handle the context handle"]
    #[doc = " @return a \\link alpm_siglevel_t \\endlink bitfield of the siglevel"]
    pub unsafe fn alpm_option_get_local_file_siglevel(
        &self,
        handle: *mut alpm_handle_t,
    ) -> ::std::os::raw::c_int {
        (self.alpm_option_get_local_file_siglevel)(handle)
    }
    #[doc = " Set the local file siglevel."]
    #[doc = " @param handle the context handle"]
    #[doc = " @param level a \\link alpm_siglevel_t \\endlink bitfield of the level to set"]
    #[doc = " @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub unsafe fn alpm_option_set_local_file_siglevel(
        &self,
        handle: *mut alpm_handle_t,
        level: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        (self.alpm_option_set_local_file_siglevel)(handle, level)
    }
    #[doc = " Get the configured remote file siglevel."]
    #[doc = " @param handle the context handle"]
    #[doc = " @return a \\link alpm_siglevel_t \\endlink bitfield of the siglevel"]
    pub unsafe fn alpm_option_get_remote_file_siglevel(
        &self,
        handle: *mut alpm_handle_t,
    ) -> ::std::os::raw::c_int {
        (self.alpm_option_get_remote_file_siglevel)(handle)
    }
    #[doc = " Set the remote file siglevel."]
    #[doc = " @param handle the context handle"]
    #[doc = " @param level a \\link alpm_siglevel_t \\endlink bitfield of the level to set"]
    #[doc = " @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub unsafe fn alpm_option_set_remote_file_siglevel(
        &self,
        handle: *mut alpm_handle_t,
        level: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        (self.alpm_option_set_remote_file_siglevel)(handle, level)
    }
    #[doc = " Enables/disables the download timeout."]
    #[doc = " @param handle the context handle"]
    #[doc = " @param disable_dl_timeout 0 for enabled, 1 for disabled"]
    #[doc = " @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub unsafe fn alpm_option_set_disable_dl_timeout(
        &self,
        handle: *mut alpm_handle_t,
        disable_dl_timeout: ::std::os::raw::c_ushort,
    ) -> ::std::os::raw::c_int {
        (self.alpm_option_set_disable_dl_timeout)(handle, disable_dl_timeout)
    }
    #[doc = " Gets the number of parallel streams to download database and package files."]
    #[doc = " @param handle the context handle"]
    #[doc = " @return the number of parallel streams to download database and package files"]
    pub unsafe fn alpm_option_get_parallel_downloads(
        &self,
        handle: *mut alpm_handle_t,
    ) -> ::std::os::raw::c_int {
        (self.alpm_option_get_parallel_downloads)(handle)
    }
    #[doc = " Sets number of parallel streams to download database and package files."]
    #[doc = " @param handle the context handle"]
    #[doc = " @param num_streams number of parallel download streams"]
    #[doc = " @return 0 on success, -1 on error"]
    pub unsafe fn alpm_option_set_parallel_downloads(
        &self,
        handle: *mut alpm_handle_t,
        num_streams: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int {
        (self.alpm_option_set_parallel_downloads)(handle, num_streams)
    }
    #[doc = " Create a package from a file."]
    #[doc = " If full is false, the archive is read only until all necessary"]
    #[doc = " metadata is found. If it is true, the entire archive is read, which"]
    #[doc = " serves as a verification of integrity and the filelist can be created."]
    #[doc = " The allocated structure should be freed using alpm_pkg_free()."]
    #[doc = " @param handle the context handle"]
    #[doc = " @param filename location of the package tarball"]
    #[doc = " @param full whether to stop the load after metadata is read or continue"]
    #[doc = " through the full archive"]
    #[doc = " @param level what level of package signature checking to perform on the"]
    #[doc = " package; note that this must be a '.sig' file type verification"]
    #[doc = " @param pkg address of the package pointer"]
    #[doc = " @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub unsafe fn alpm_pkg_load(
        &self,
        handle: *mut alpm_handle_t,
        filename: *const ::std::os::raw::c_char,
        full: ::std::os::raw::c_int,
        level: ::std::os::raw::c_int,
        pkg: *mut *mut alpm_pkg_t,
    ) -> ::std::os::raw::c_int {
        (self.alpm_pkg_load)(handle, filename, full, level, pkg)
    }
    #[doc = " Fetch a list of remote packages."]
    #[doc = " @param handle the context handle"]
    #[doc = " @param urls list of package URLs to download"]
    #[doc = " @param fetched list of filepaths to the fetched packages, each item"]
    #[doc = "    corresponds to one in `urls` list. This is an output parameter,"]
    #[doc = "    the caller should provide a pointer to an empty list"]
    #[doc = "    (*fetched === NULL) and the callee fills the list with data."]
    #[doc = " @return 0 on success or -1 on failure"]
    pub unsafe fn alpm_fetch_pkgurl(
        &self,
        handle: *mut alpm_handle_t,
        urls: *const alpm_list_t,
        fetched: *mut *mut alpm_list_t,
    ) -> ::std::os::raw::c_int {
        (self.alpm_fetch_pkgurl)(handle, urls, fetched)
    }
    #[doc = " Find a package in a list by name."]
    #[doc = " @param haystack a list of alpm_pkg_t"]
    #[doc = " @param needle the package name"]
    #[doc = " @return a pointer to the package if found or NULL"]
    pub unsafe fn alpm_pkg_find(
        &self,
        haystack: *mut alpm_list_t,
        needle: *const ::std::os::raw::c_char,
    ) -> *mut alpm_pkg_t {
        (self.alpm_pkg_find)(haystack, needle)
    }
    #[doc = " Free a package."]
    #[doc = " Only packages loaded with \\link alpm_pkg_load \\endlink can be freed."]
    #[doc = " Packages from databases will be freed by libalpm when they are unregistered."]
    #[doc = " @param pkg package pointer to free"]
    #[doc = " @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub unsafe fn alpm_pkg_free(&self, pkg: *mut alpm_pkg_t) -> ::std::os::raw::c_int {
        (self.alpm_pkg_free)(pkg)
    }
    #[doc = " Check the integrity (with md5) of a package from the sync cache."]
    #[doc = " @param pkg package pointer"]
    #[doc = " @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub unsafe fn alpm_pkg_checkmd5sum(&self, pkg: *mut alpm_pkg_t) -> ::std::os::raw::c_int {
        (self.alpm_pkg_checkmd5sum)(pkg)
    }
    #[doc = " Compare two version strings and determine which one is 'newer'."]
    #[doc = " Returns a value comparable to the way strcmp works. Returns 1"]
    #[doc = " if a is newer than b, 0 if a and b are the same version, or -1"]
    #[doc = " if b is newer than a."]
    #[doc = ""]
    #[doc = " Different epoch values for version strings will override any further"]
    #[doc = " comparison. If no epoch is provided, 0 is assumed."]
    #[doc = ""]
    #[doc = " Keep in mind that the pkgrel is only compared if it is available"]
    #[doc = " on both versions handed to this function. For example, comparing"]
    #[doc = " 1.5-1 and 1.5 will yield 0; comparing 1.5-1 and 1.5-2 will yield"]
    #[doc = " -1 as expected. This is mainly for supporting versioned dependencies"]
    #[doc = " that do not include the pkgrel."]
    pub unsafe fn alpm_pkg_vercmp(
        &self,
        a: *const ::std::os::raw::c_char,
        b: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int {
        (self.alpm_pkg_vercmp)(a, b)
    }
    #[doc = " Computes the list of packages requiring a given package."]
    #[doc = " The return value of this function is a newly allocated"]
    #[doc = " list of package names (char*), it should be freed by the caller."]
    #[doc = " @param pkg a package"]
    #[doc = " @return the list of packages requiring pkg"]
    pub unsafe fn alpm_pkg_compute_requiredby(&self, pkg: *mut alpm_pkg_t) -> *mut alpm_list_t {
        (self.alpm_pkg_compute_requiredby)(pkg)
    }
    #[doc = " Computes the list of packages optionally requiring a given package."]
    #[doc = " The return value of this function is a newly allocated"]
    #[doc = " list of package names (char*), it should be freed by the caller."]
    #[doc = " @param pkg a package"]
    #[doc = " @return the list of packages optionally requiring pkg"]
    pub unsafe fn alpm_pkg_compute_optionalfor(&self, pkg: *mut alpm_pkg_t) -> *mut alpm_list_t {
        (self.alpm_pkg_compute_optionalfor)(pkg)
    }
    #[doc = " Test if a package should be ignored."]
    #[doc = " Checks if the package is ignored via IgnorePkg, or if the package is"]
    #[doc = " in a group ignored via IgnoreGroup."]
    #[doc = " @param handle the context handle"]
    #[doc = " @param pkg the package to test"]
    #[doc = " @return 1 if the package should be ignored, 0 otherwise"]
    pub unsafe fn alpm_pkg_should_ignore(
        &self,
        handle: *mut alpm_handle_t,
        pkg: *mut alpm_pkg_t,
    ) -> ::std::os::raw::c_int {
        (self.alpm_pkg_should_ignore)(handle, pkg)
    }
    #[doc = " Gets the name of the file from which the package was loaded."]
    #[doc = " @param pkg a pointer to package"]
    #[doc = " @return a reference to an internal string"]
    pub unsafe fn alpm_pkg_get_filename(
        &self,
        pkg: *mut alpm_pkg_t,
    ) -> *const ::std::os::raw::c_char {
        (self.alpm_pkg_get_filename)(pkg)
    }
    #[doc = " Returns the package base name."]
    #[doc = " @param pkg a pointer to package"]
    #[doc = " @return a reference to an internal string"]
    pub unsafe fn alpm_pkg_get_base(&self, pkg: *mut alpm_pkg_t) -> *const ::std::os::raw::c_char {
        (self.alpm_pkg_get_base)(pkg)
    }
    #[doc = " Returns the package name."]
    #[doc = " @param pkg a pointer to package"]
    #[doc = " @return a reference to an internal string"]
    pub unsafe fn alpm_pkg_get_name(&self, pkg: *mut alpm_pkg_t) -> *const ::std::os::raw::c_char {
        (self.alpm_pkg_get_name)(pkg)
    }
    #[doc = " Returns the package version as a string."]
    #[doc = " This includes all available epoch, version, and pkgrel components. Use"]
    #[doc = " alpm_pkg_vercmp() to compare version strings if necessary."]
    #[doc = " @param pkg a pointer to package"]
    #[doc = " @return a reference to an internal string"]
    pub unsafe fn alpm_pkg_get_version(
        &self,
        pkg: *mut alpm_pkg_t,
    ) -> *const ::std::os::raw::c_char {
        (self.alpm_pkg_get_version)(pkg)
    }
    #[doc = " Returns the origin of the package."]
    #[doc = " @return an alpm_pkgfrom_t constant, -1 on error"]
    pub unsafe fn alpm_pkg_get_origin(&self, pkg: *mut alpm_pkg_t) -> alpm_pkgfrom_t {
        (self.alpm_pkg_get_origin)(pkg)
    }
    #[doc = " Returns the package description."]
    #[doc = " @param pkg a pointer to package"]
    #[doc = " @return a reference to an internal string"]
    pub unsafe fn alpm_pkg_get_desc(&self, pkg: *mut alpm_pkg_t) -> *const ::std::os::raw::c_char {
        (self.alpm_pkg_get_desc)(pkg)
    }
    #[doc = " Returns the package URL."]
    #[doc = " @param pkg a pointer to package"]
    #[doc = " @return a reference to an internal string"]
    pub unsafe fn alpm_pkg_get_url(&self, pkg: *mut alpm_pkg_t) -> *const ::std::os::raw::c_char {
        (self.alpm_pkg_get_url)(pkg)
    }
    #[doc = " Returns the build timestamp of the package."]
    #[doc = " @param pkg a pointer to package"]
    #[doc = " @return the timestamp of the build time"]
    pub unsafe fn alpm_pkg_get_builddate(&self, pkg: *mut alpm_pkg_t) -> alpm_time_t {
        (self.alpm_pkg_get_builddate)(pkg)
    }
    #[doc = " Returns the install timestamp of the package."]
    #[doc = " @param pkg a pointer to package"]
    #[doc = " @return the timestamp of the install time"]
    pub unsafe fn alpm_pkg_get_installdate(&self, pkg: *mut alpm_pkg_t) -> alpm_time_t {
        (self.alpm_pkg_get_installdate)(pkg)
    }
    #[doc = " Returns the packager's name."]
    #[doc = " @param pkg a pointer to package"]
    #[doc = " @return a reference to an internal string"]
    pub unsafe fn alpm_pkg_get_packager(
        &self,
        pkg: *mut alpm_pkg_t,
    ) -> *const ::std::os::raw::c_char {
        (self.alpm_pkg_get_packager)(pkg)
    }
    #[doc = " Returns the package's MD5 checksum as a string."]
    #[doc = " The returned string is a sequence of 32 lowercase hexadecimal digits."]
    #[doc = " @param pkg a pointer to package"]
    #[doc = " @return a reference to an internal string"]
    pub unsafe fn alpm_pkg_get_md5sum(
        &self,
        pkg: *mut alpm_pkg_t,
    ) -> *const ::std::os::raw::c_char {
        (self.alpm_pkg_get_md5sum)(pkg)
    }
    #[doc = " Returns the package's SHA256 checksum as a string."]
    #[doc = " The returned string is a sequence of 64 lowercase hexadecimal digits."]
    #[doc = " @param pkg a pointer to package"]
    #[doc = " @return a reference to an internal string"]
    pub unsafe fn alpm_pkg_get_sha256sum(
        &self,
        pkg: *mut alpm_pkg_t,
    ) -> *const ::std::os::raw::c_char {
        (self.alpm_pkg_get_sha256sum)(pkg)
    }
    #[doc = " Returns the architecture for which the package was built."]
    #[doc = " @param pkg a pointer to package"]
    #[doc = " @return a reference to an internal string"]
    pub unsafe fn alpm_pkg_get_arch(&self, pkg: *mut alpm_pkg_t) -> *const ::std::os::raw::c_char {
        (self.alpm_pkg_get_arch)(pkg)
    }
    #[doc = " Returns the size of the package. This is only available for sync database"]
    #[doc = " packages and package files, not those loaded from the local database."]
    #[doc = " @param pkg a pointer to package"]
    #[doc = " @return the size of the package in bytes."]
    pub unsafe fn alpm_pkg_get_size(&self, pkg: *mut alpm_pkg_t) -> off_t {
        (self.alpm_pkg_get_size)(pkg)
    }
    #[doc = " Returns the installed size of the package."]
    #[doc = " @param pkg a pointer to package"]
    #[doc = " @return the total size of files installed by the package."]
    pub unsafe fn alpm_pkg_get_isize(&self, pkg: *mut alpm_pkg_t) -> off_t {
        (self.alpm_pkg_get_isize)(pkg)
    }
    #[doc = " Returns the package installation reason."]
    #[doc = " @param pkg a pointer to package"]
    #[doc = " @return an enum member giving the install reason."]
    pub unsafe fn alpm_pkg_get_reason(&self, pkg: *mut alpm_pkg_t) -> alpm_pkgreason_t {
        (self.alpm_pkg_get_reason)(pkg)
    }
    #[doc = " Returns the list of package licenses."]
    #[doc = " @param pkg a pointer to package"]
    #[doc = " @return a pointer to an internal list of strings."]
    pub unsafe fn alpm_pkg_get_licenses(&self, pkg: *mut alpm_pkg_t) -> *mut alpm_list_t {
        (self.alpm_pkg_get_licenses)(pkg)
    }
    #[doc = " Returns the list of package groups."]
    #[doc = " @param pkg a pointer to package"]
    #[doc = " @return a pointer to an internal list of strings."]
    pub unsafe fn alpm_pkg_get_groups(&self, pkg: *mut alpm_pkg_t) -> *mut alpm_list_t {
        (self.alpm_pkg_get_groups)(pkg)
    }
    #[doc = " Returns the list of package dependencies as alpm_depend_t."]
    #[doc = " @param pkg a pointer to package"]
    #[doc = " @return a reference to an internal list of alpm_depend_t structures."]
    pub unsafe fn alpm_pkg_get_depends(&self, pkg: *mut alpm_pkg_t) -> *mut alpm_list_t {
        (self.alpm_pkg_get_depends)(pkg)
    }
    #[doc = " Returns the list of package optional dependencies."]
    #[doc = " @param pkg a pointer to package"]
    #[doc = " @return a reference to an internal list of alpm_depend_t structures."]
    pub unsafe fn alpm_pkg_get_optdepends(&self, pkg: *mut alpm_pkg_t) -> *mut alpm_list_t {
        (self.alpm_pkg_get_optdepends)(pkg)
    }
    #[doc = " Returns a list of package check dependencies"]
    #[doc = " @param pkg a pointer to package"]
    #[doc = " @return a reference to an internal list of alpm_depend_t structures."]
    pub unsafe fn alpm_pkg_get_checkdepends(&self, pkg: *mut alpm_pkg_t) -> *mut alpm_list_t {
        (self.alpm_pkg_get_checkdepends)(pkg)
    }
    #[doc = " Returns a list of package make dependencies"]
    #[doc = " @param pkg a pointer to package"]
    #[doc = " @return a reference to an internal list of alpm_depend_t structures."]
    pub unsafe fn alpm_pkg_get_makedepends(&self, pkg: *mut alpm_pkg_t) -> *mut alpm_list_t {
        (self.alpm_pkg_get_makedepends)(pkg)
    }
    #[doc = " Returns the list of packages conflicting with pkg."]
    #[doc = " @param pkg a pointer to package"]
    #[doc = " @return a reference to an internal list of alpm_depend_t structures."]
    pub unsafe fn alpm_pkg_get_conflicts(&self, pkg: *mut alpm_pkg_t) -> *mut alpm_list_t {
        (self.alpm_pkg_get_conflicts)(pkg)
    }
    #[doc = " Returns the list of packages provided by pkg."]
    #[doc = " @param pkg a pointer to package"]
    #[doc = " @return a reference to an internal list of alpm_depend_t structures."]
    pub unsafe fn alpm_pkg_get_provides(&self, pkg: *mut alpm_pkg_t) -> *mut alpm_list_t {
        (self.alpm_pkg_get_provides)(pkg)
    }
    #[doc = " Returns the list of packages to be replaced by pkg."]
    #[doc = " @param pkg a pointer to package"]
    #[doc = " @return a reference to an internal list of alpm_depend_t structures."]
    pub unsafe fn alpm_pkg_get_replaces(&self, pkg: *mut alpm_pkg_t) -> *mut alpm_list_t {
        (self.alpm_pkg_get_replaces)(pkg)
    }
    #[doc = " Returns the list of files installed by pkg."]
    #[doc = " The filenames are relative to the install root,"]
    #[doc = " and do not include leading slashes."]
    #[doc = " @param pkg a pointer to package"]
    #[doc = " @return a pointer to a filelist object containing a count and an array of"]
    #[doc = " package file objects"]
    pub unsafe fn alpm_pkg_get_files(&self, pkg: *mut alpm_pkg_t) -> *mut alpm_filelist_t {
        (self.alpm_pkg_get_files)(pkg)
    }
    #[doc = " Returns the list of files backed up when installing pkg."]
    #[doc = " @param pkg a pointer to package"]
    #[doc = " @return a reference to a list of alpm_backup_t objects"]
    pub unsafe fn alpm_pkg_get_backup(&self, pkg: *mut alpm_pkg_t) -> *mut alpm_list_t {
        (self.alpm_pkg_get_backup)(pkg)
    }
    #[doc = " Returns the database containing pkg."]
    #[doc = " Returns a pointer to the alpm_db_t structure the package is"]
    #[doc = " originating from, or NULL if the package was loaded from a file."]
    #[doc = " @param pkg a pointer to package"]
    #[doc = " @return a pointer to the DB containing pkg, or NULL."]
    pub unsafe fn alpm_pkg_get_db(&self, pkg: *mut alpm_pkg_t) -> *mut alpm_db_t {
        (self.alpm_pkg_get_db)(pkg)
    }
    #[doc = " Returns the base64 encoded package signature."]
    #[doc = " @param pkg a pointer to package"]
    #[doc = " @return a reference to an internal string"]
    pub unsafe fn alpm_pkg_get_base64_sig(
        &self,
        pkg: *mut alpm_pkg_t,
    ) -> *const ::std::os::raw::c_char {
        (self.alpm_pkg_get_base64_sig)(pkg)
    }
    #[doc = " Extracts package signature either from embedded package signature"]
    #[doc = " or if it is absent then reads data from detached signature file."]
    #[doc = " @param pkg a pointer to package."]
    #[doc = " @param sig output parameter for signature data. Callee function allocates"]
    #[doc = " a buffer needed for the signature data. Caller is responsible for"]
    #[doc = " freeing this buffer."]
    #[doc = " @param sig_len output parameter for the signature data length."]
    #[doc = " @return 0 on success, negative number on error."]
    pub unsafe fn alpm_pkg_get_sig(
        &self,
        pkg: *mut alpm_pkg_t,
        sig: *mut *mut ::std::os::raw::c_uchar,
        sig_len: *mut usize,
    ) -> ::std::os::raw::c_int {
        (self.alpm_pkg_get_sig)(pkg, sig, sig_len)
    }
    #[doc = " Returns the method used to validate a package during install."]
    #[doc = " @param pkg a pointer to package"]
    #[doc = " @return an enum member giving the validation method"]
    pub unsafe fn alpm_pkg_get_validation(&self, pkg: *mut alpm_pkg_t) -> ::std::os::raw::c_int {
        (self.alpm_pkg_get_validation)(pkg)
    }
    #[doc = " Returns whether the package has an install scriptlet."]
    #[doc = " @return 0 if FALSE, TRUE otherwise"]
    pub unsafe fn alpm_pkg_has_scriptlet(&self, pkg: *mut alpm_pkg_t) -> ::std::os::raw::c_int {
        (self.alpm_pkg_has_scriptlet)(pkg)
    }
    #[doc = " Returns the size of the files that will be downloaded to install a"]
    #[doc = " package."]
    #[doc = " @param newpkg the new package to upgrade to"]
    #[doc = " @return the size of the download"]
    pub unsafe fn alpm_pkg_download_size(&self, newpkg: *mut alpm_pkg_t) -> off_t {
        (self.alpm_pkg_download_size)(newpkg)
    }
    #[doc = " Set install reason for a package in the local database."]
    #[doc = " The provided package object must be from the local database or this method"]
    #[doc = " will fail. The write to the local database is performed immediately."]
    #[doc = " @param pkg the package to update"]
    #[doc = " @param reason the new install reason"]
    #[doc = " @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub unsafe fn alpm_pkg_set_reason(
        &self,
        pkg: *mut alpm_pkg_t,
        reason: alpm_pkgreason_t,
    ) -> ::std::os::raw::c_int {
        (self.alpm_pkg_set_reason)(pkg, reason)
    }
    #[doc = " Open a package changelog for reading."]
    #[doc = " Similar to fopen in functionality, except that the returned 'file"]
    #[doc = " stream' could really be from an archive as well as from the database."]
    #[doc = " @param pkg the package to read the changelog of (either file or db)"]
    #[doc = " @return a 'file stream' to the package changelog"]
    pub unsafe fn alpm_pkg_changelog_open(
        &self,
        pkg: *mut alpm_pkg_t,
    ) -> *mut ::std::os::raw::c_void {
        (self.alpm_pkg_changelog_open)(pkg)
    }
    #[doc = " Read data from an open changelog 'file stream'."]
    #[doc = " Similar to fread in functionality, this function takes a buffer and"]
    #[doc = " amount of data to read. If an error occurs pm_errno will be set."]
    #[doc = " @param ptr a buffer to fill with raw changelog data"]
    #[doc = " @param size the size of the buffer"]
    #[doc = " @param pkg the package that the changelog is being read from"]
    #[doc = " @param fp a 'file stream' to the package changelog"]
    #[doc = " @return the number of characters read, or 0 if there is no more data or an"]
    #[doc = " error occurred."]
    pub unsafe fn alpm_pkg_changelog_read(
        &self,
        ptr: *mut ::std::os::raw::c_void,
        size: usize,
        pkg: *const alpm_pkg_t,
        fp: *mut ::std::os::raw::c_void,
    ) -> usize {
        (self.alpm_pkg_changelog_read)(ptr, size, pkg, fp)
    }
    #[doc = " Close a package changelog for reading."]
    #[doc = " @param pkg the package to close the changelog of (either file or db)"]
    #[doc = " @param fp the 'file stream' to the package changelog to close"]
    #[doc = " @return 0 on success, -1 on error"]
    pub unsafe fn alpm_pkg_changelog_close(
        &self,
        pkg: *const alpm_pkg_t,
        fp: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int {
        (self.alpm_pkg_changelog_close)(pkg, fp)
    }
    #[doc = " Open a package mtree file for reading."]
    #[doc = " @param pkg the local package to read the mtree of"]
    #[doc = " @return an archive structure for the package mtree file"]
    pub unsafe fn alpm_pkg_mtree_open(&self, pkg: *mut alpm_pkg_t) -> *mut archive {
        (self.alpm_pkg_mtree_open)(pkg)
    }
    #[doc = " Read next entry from a package mtree file."]
    #[doc = " @param pkg the package that the mtree file is being read from"]
    #[doc = " @param archive the archive structure reading from the mtree file"]
    #[doc = " @param entry an archive_entry to store the entry header information"]
    #[doc = " @return 0 on success, 1 if end of archive is reached, -1 otherwise."]
    pub unsafe fn alpm_pkg_mtree_next(
        &self,
        pkg: *const alpm_pkg_t,
        archive: *mut archive,
        entry: *mut *mut archive_entry,
    ) -> ::std::os::raw::c_int {
        (self.alpm_pkg_mtree_next)(pkg, archive, entry)
    }
    #[doc = " Close a package mtree file."]
    #[doc = " @param pkg the local package to close the mtree of"]
    #[doc = " @param archive the archive to close"]
    pub unsafe fn alpm_pkg_mtree_close(
        &self,
        pkg: *const alpm_pkg_t,
        archive: *mut archive,
    ) -> ::std::os::raw::c_int {
        (self.alpm_pkg_mtree_close)(pkg, archive)
    }
    #[doc = " Returns the bitfield of flags for the current transaction."]
    #[doc = " @param handle the context handle"]
    #[doc = " @return the bitfield of transaction flags"]
    pub unsafe fn alpm_trans_get_flags(&self, handle: *mut alpm_handle_t) -> ::std::os::raw::c_int {
        (self.alpm_trans_get_flags)(handle)
    }
    #[doc = " Returns a list of packages added by the transaction."]
    #[doc = " @param handle the context handle"]
    #[doc = " @return a list of alpm_pkg_t structures"]
    pub unsafe fn alpm_trans_get_add(&self, handle: *mut alpm_handle_t) -> *mut alpm_list_t {
        (self.alpm_trans_get_add)(handle)
    }
    #[doc = " Returns the list of packages removed by the transaction."]
    #[doc = " @param handle the context handle"]
    #[doc = " @return a list of alpm_pkg_t structures"]
    pub unsafe fn alpm_trans_get_remove(&self, handle: *mut alpm_handle_t) -> *mut alpm_list_t {
        (self.alpm_trans_get_remove)(handle)
    }
    #[doc = " Initialize the transaction."]
    #[doc = " @param handle the context handle"]
    #[doc = " @param flags flags of the transaction (like nodeps, etc; see alpm_transflag_t)"]
    #[doc = " @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub unsafe fn alpm_trans_init(
        &self,
        handle: *mut alpm_handle_t,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        (self.alpm_trans_init)(handle, flags)
    }
    #[doc = " Prepare a transaction."]
    #[doc = " @param handle the context handle"]
    #[doc = " @param data the address of an alpm_list where a list"]
    #[doc = " of alpm_depmissing_t objects is dumped (conflicting packages)"]
    #[doc = " @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub unsafe fn alpm_trans_prepare(
        &self,
        handle: *mut alpm_handle_t,
        data: *mut *mut alpm_list_t,
    ) -> ::std::os::raw::c_int {
        (self.alpm_trans_prepare)(handle, data)
    }
    #[doc = " Commit a transaction."]
    #[doc = " @param handle the context handle"]
    #[doc = " @param data the address of an alpm_list where detailed description"]
    #[doc = " of an error can be dumped (i.e. list of conflicting files)"]
    #[doc = " @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub unsafe fn alpm_trans_commit(
        &self,
        handle: *mut alpm_handle_t,
        data: *mut *mut alpm_list_t,
    ) -> ::std::os::raw::c_int {
        (self.alpm_trans_commit)(handle, data)
    }
    #[doc = " Interrupt a transaction."]
    #[doc = " @param handle the context handle"]
    #[doc = " @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub unsafe fn alpm_trans_interrupt(&self, handle: *mut alpm_handle_t) -> ::std::os::raw::c_int {
        (self.alpm_trans_interrupt)(handle)
    }
    #[doc = " Release a transaction."]
    #[doc = " @param handle the context handle"]
    #[doc = " @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub unsafe fn alpm_trans_release(&self, handle: *mut alpm_handle_t) -> ::std::os::raw::c_int {
        (self.alpm_trans_release)(handle)
    }
    #[doc = " Search for packages to upgrade and add them to the transaction."]
    #[doc = " @param handle the context handle"]
    #[doc = " @param enable_downgrade allow downgrading of packages if the remote version is lower"]
    #[doc = " @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub unsafe fn alpm_sync_sysupgrade(
        &self,
        handle: *mut alpm_handle_t,
        enable_downgrade: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        (self.alpm_sync_sysupgrade)(handle, enable_downgrade)
    }
    #[doc = " Add a package to the transaction."]
    #[doc = " If the package was loaded by alpm_pkg_load(), it will be freed upon"]
    #[doc = " \\link alpm_trans_release \\endlink invocation."]
    #[doc = " @param handle the context handle"]
    #[doc = " @param pkg the package to add"]
    #[doc = " @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub unsafe fn alpm_add_pkg(
        &self,
        handle: *mut alpm_handle_t,
        pkg: *mut alpm_pkg_t,
    ) -> ::std::os::raw::c_int {
        (self.alpm_add_pkg)(handle, pkg)
    }
    #[doc = " Add a package removal to the transaction."]
    #[doc = " @param handle the context handle"]
    #[doc = " @param pkg the package to uninstall"]
    #[doc = " @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub unsafe fn alpm_remove_pkg(
        &self,
        handle: *mut alpm_handle_t,
        pkg: *mut alpm_pkg_t,
    ) -> ::std::os::raw::c_int {
        (self.alpm_remove_pkg)(handle, pkg)
    }
    #[doc = " Check for new version of pkg in syncdbs."]
    #[doc = ""]
    #[doc = " If the same package appears multiple dbs only the first will be checked"]
    #[doc = ""]
    #[doc = " This only checks the syncdb for a newer version. It does not access the network at all."]
    #[doc = " See \\link alpm_db_update \\endlink to update a database."]
    pub unsafe fn alpm_sync_get_new_version(
        &self,
        pkg: *mut alpm_pkg_t,
        dbs_sync: *mut alpm_list_t,
    ) -> *mut alpm_pkg_t {
        (self.alpm_sync_get_new_version)(pkg, dbs_sync)
    }
    #[doc = " Get the md5 sum of file."]
    #[doc = " @param filename name of the file"]
    #[doc = " @return the checksum on success, NULL on error"]
    pub unsafe fn alpm_compute_md5sum(
        &self,
        filename: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char {
        (self.alpm_compute_md5sum)(filename)
    }
    #[doc = " Get the sha256 sum of file."]
    #[doc = " @param filename name of the file"]
    #[doc = " @return the checksum on success, NULL on error"]
    pub unsafe fn alpm_compute_sha256sum(
        &self,
        filename: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char {
        (self.alpm_compute_sha256sum)(filename)
    }
    #[doc = " Remove the database lock file"]
    #[doc = " @param handle the context handle"]
    #[doc = " @return 0 on success, -1 on error"]
    #[doc = ""]
    #[doc = " @note Safe to call from inside signal handlers."]
    pub unsafe fn alpm_unlock(&self, handle: *mut alpm_handle_t) -> ::std::os::raw::c_int {
        (self.alpm_unlock)(handle)
    }
    #[doc = " Get the version of library."]
    #[doc = " @return the library version, e.g. \"6.0.4\""]
    pub unsafe fn alpm_version(&self) -> *const ::std::os::raw::c_char {
        (self.alpm_version)()
    }
    #[doc = " Get the capabilities of the library."]
    #[doc = " @return a bitmask of the capabilities"]
    pub unsafe fn alpm_capabilities(&self) -> ::std::os::raw::c_int {
        (self.alpm_capabilities)()
    }
}
