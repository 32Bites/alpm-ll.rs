/* automatically generated by rust-bindgen */

pub type __int64_t = ::std::os::raw::c_long;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __off_t = ::std::os::raw::c_long;
pub type mode_t = __mode_t;
pub type off_t = __off_t;
pub type va_list = __builtin_va_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct archive {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct archive_entry {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __alpm_list_t {
    pub data: *mut ::std::os::raw::c_void,
    pub prev: *mut __alpm_list_t,
    pub next: *mut __alpm_list_t,
}
#[test]
fn bindgen_test_layout___alpm_list_t() {
    assert_eq!(
        ::std::mem::size_of::<__alpm_list_t>(),
        24usize,
        concat!("Size of: ", stringify!(__alpm_list_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__alpm_list_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__alpm_list_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__alpm_list_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__alpm_list_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__alpm_list_t>())).prev as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__alpm_list_t),
            "::",
            stringify!(prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__alpm_list_t>())).next as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__alpm_list_t),
            "::",
            stringify!(next)
        )
    );
}
pub type alpm_list_t = __alpm_list_t;
pub type alpm_list_fn_free =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>;
pub type alpm_list_fn_cmp = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn alpm_list_free(list: *mut alpm_list_t);
}
extern "C" {
    pub fn alpm_list_free_inner(list: *mut alpm_list_t, fn_: alpm_list_fn_free);
}
extern "C" {
    pub fn alpm_list_add(
        list: *mut alpm_list_t,
        data: *mut ::std::os::raw::c_void,
    ) -> *mut alpm_list_t;
}
extern "C" {
    pub fn alpm_list_append(
        list: *mut *mut alpm_list_t,
        data: *mut ::std::os::raw::c_void,
    ) -> *mut alpm_list_t;
}
extern "C" {
    pub fn alpm_list_append_strdup(
        list: *mut *mut alpm_list_t,
        data: *const ::std::os::raw::c_char,
    ) -> *mut alpm_list_t;
}
extern "C" {
    pub fn alpm_list_add_sorted(
        list: *mut alpm_list_t,
        data: *mut ::std::os::raw::c_void,
        fn_: alpm_list_fn_cmp,
    ) -> *mut alpm_list_t;
}
extern "C" {
    pub fn alpm_list_join(first: *mut alpm_list_t, second: *mut alpm_list_t) -> *mut alpm_list_t;
}
extern "C" {
    pub fn alpm_list_mmerge(
        left: *mut alpm_list_t,
        right: *mut alpm_list_t,
        fn_: alpm_list_fn_cmp,
    ) -> *mut alpm_list_t;
}
extern "C" {
    pub fn alpm_list_msort(
        list: *mut alpm_list_t,
        n: usize,
        fn_: alpm_list_fn_cmp,
    ) -> *mut alpm_list_t;
}
extern "C" {
    pub fn alpm_list_remove_item(
        haystack: *mut alpm_list_t,
        item: *mut alpm_list_t,
    ) -> *mut alpm_list_t;
}
extern "C" {
    pub fn alpm_list_remove(
        haystack: *mut alpm_list_t,
        needle: *const ::std::os::raw::c_void,
        fn_: alpm_list_fn_cmp,
        data: *mut *mut ::std::os::raw::c_void,
    ) -> *mut alpm_list_t;
}
extern "C" {
    pub fn alpm_list_remove_str(
        haystack: *mut alpm_list_t,
        needle: *const ::std::os::raw::c_char,
        data: *mut *mut ::std::os::raw::c_char,
    ) -> *mut alpm_list_t;
}
extern "C" {
    pub fn alpm_list_remove_dupes(list: *const alpm_list_t) -> *mut alpm_list_t;
}
extern "C" {
    pub fn alpm_list_strdup(list: *const alpm_list_t) -> *mut alpm_list_t;
}
extern "C" {
    pub fn alpm_list_copy(list: *const alpm_list_t) -> *mut alpm_list_t;
}
extern "C" {
    pub fn alpm_list_copy_data(list: *const alpm_list_t, size: usize) -> *mut alpm_list_t;
}
extern "C" {
    pub fn alpm_list_reverse(list: *mut alpm_list_t) -> *mut alpm_list_t;
}
extern "C" {
    pub fn alpm_list_nth(list: *const alpm_list_t, n: usize) -> *mut alpm_list_t;
}
extern "C" {
    pub fn alpm_list_next(list: *const alpm_list_t) -> *mut alpm_list_t;
}
extern "C" {
    pub fn alpm_list_previous(list: *const alpm_list_t) -> *mut alpm_list_t;
}
extern "C" {
    pub fn alpm_list_last(list: *const alpm_list_t) -> *mut alpm_list_t;
}
extern "C" {
    pub fn alpm_list_count(list: *const alpm_list_t) -> usize;
}
extern "C" {
    pub fn alpm_list_find(
        haystack: *const alpm_list_t,
        needle: *const ::std::os::raw::c_void,
        fn_: alpm_list_fn_cmp,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn alpm_list_find_ptr(
        haystack: *const alpm_list_t,
        needle: *const ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn alpm_list_find_str(
        haystack: *const alpm_list_t,
        needle: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn alpm_list_diff(
        lhs: *const alpm_list_t,
        rhs: *const alpm_list_t,
        fn_: alpm_list_fn_cmp,
    ) -> *mut alpm_list_t;
}
extern "C" {
    pub fn alpm_list_diff_sorted(
        left: *const alpm_list_t,
        right: *const alpm_list_t,
        fn_: alpm_list_fn_cmp,
        onlyleft: *mut *mut alpm_list_t,
        onlyright: *mut *mut alpm_list_t,
    );
}
extern "C" {
    pub fn alpm_list_to_array(
        list: *const alpm_list_t,
        n: usize,
        size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
pub type alpm_handle_t = u8;
pub type alpm_db_t = u8;
pub type alpm_pkg_t = u8;
pub type alpm_trans_t = u8;
#[repr(u32)]
#[doc = " @addtogroup alpm_api_errors Error Codes"]
#[doc = " @{"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _alpm_errno_t {
    ALPM_ERR_OK = 0,
    ALPM_ERR_MEMORY = 1,
    ALPM_ERR_SYSTEM = 2,
    ALPM_ERR_BADPERMS = 3,
    ALPM_ERR_NOT_A_FILE = 4,
    ALPM_ERR_NOT_A_DIR = 5,
    ALPM_ERR_WRONG_ARGS = 6,
    ALPM_ERR_DISK_SPACE = 7,
    ALPM_ERR_HANDLE_NULL = 8,
    ALPM_ERR_HANDLE_NOT_NULL = 9,
    ALPM_ERR_HANDLE_LOCK = 10,
    ALPM_ERR_DB_OPEN = 11,
    ALPM_ERR_DB_CREATE = 12,
    ALPM_ERR_DB_NULL = 13,
    ALPM_ERR_DB_NOT_NULL = 14,
    ALPM_ERR_DB_NOT_FOUND = 15,
    ALPM_ERR_DB_INVALID = 16,
    ALPM_ERR_DB_INVALID_SIG = 17,
    ALPM_ERR_DB_VERSION = 18,
    ALPM_ERR_DB_WRITE = 19,
    ALPM_ERR_DB_REMOVE = 20,
    ALPM_ERR_SERVER_BAD_URL = 21,
    ALPM_ERR_SERVER_NONE = 22,
    ALPM_ERR_TRANS_NOT_NULL = 23,
    ALPM_ERR_TRANS_NULL = 24,
    ALPM_ERR_TRANS_DUP_TARGET = 25,
    ALPM_ERR_TRANS_NOT_INITIALIZED = 26,
    ALPM_ERR_TRANS_NOT_PREPARED = 27,
    ALPM_ERR_TRANS_ABORT = 28,
    ALPM_ERR_TRANS_TYPE = 29,
    ALPM_ERR_TRANS_NOT_LOCKED = 30,
    ALPM_ERR_TRANS_HOOK_FAILED = 31,
    ALPM_ERR_PKG_NOT_FOUND = 32,
    ALPM_ERR_PKG_IGNORED = 33,
    ALPM_ERR_PKG_INVALID = 34,
    ALPM_ERR_PKG_INVALID_CHECKSUM = 35,
    ALPM_ERR_PKG_INVALID_SIG = 36,
    ALPM_ERR_PKG_MISSING_SIG = 37,
    ALPM_ERR_PKG_OPEN = 38,
    ALPM_ERR_PKG_CANT_REMOVE = 39,
    ALPM_ERR_PKG_INVALID_NAME = 40,
    ALPM_ERR_PKG_INVALID_ARCH = 41,
    ALPM_ERR_PKG_REPO_NOT_FOUND = 42,
    ALPM_ERR_SIG_MISSING = 43,
    ALPM_ERR_SIG_INVALID = 44,
    ALPM_ERR_UNSATISFIED_DEPS = 45,
    ALPM_ERR_CONFLICTING_DEPS = 46,
    ALPM_ERR_FILE_CONFLICTS = 47,
    ALPM_ERR_RETRIEVE = 48,
    ALPM_ERR_INVALID_REGEX = 49,
    ALPM_ERR_LIBARCHIVE = 50,
    ALPM_ERR_LIBCURL = 51,
    ALPM_ERR_EXTERNAL_DOWNLOAD = 52,
    ALPM_ERR_GPGME = 53,
    ALPM_ERR_MISSING_CAPABILITY_SIGNATURES = 54,
}
pub use self::_alpm_errno_t as alpm_errno_t;
extern "C" {
    #[doc = " Returns the current error code from the handle."]
    pub fn alpm_errno(handle: *mut alpm_handle_t) -> alpm_errno_t;
}
extern "C" {
    #[doc = " Returns the string corresponding to an error number."]
    pub fn alpm_strerror(err: alpm_errno_t) -> *const ::std::os::raw::c_char;
}
#[doc = " @addtogroup alpm_api Public API"]
#[doc = " The libalpm Public API"]
#[doc = " @{"]
pub type alpm_time_t = i64;
#[repr(u32)]
#[doc = " Package install reasons."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _alpm_pkgreason_t {
    #[doc = " Explicitly requested by the user."]
    ALPM_PKG_REASON_EXPLICIT = 0,
    #[doc = " Installed as a dependency for another package."]
    ALPM_PKG_REASON_DEPEND = 1,
}
pub use self::_alpm_pkgreason_t as alpm_pkgreason_t;
#[repr(u32)]
#[doc = " Location a package object was loaded from."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _alpm_pkgfrom_t {
    ALPM_PKG_FROM_FILE = 1,
    ALPM_PKG_FROM_LOCALDB = 2,
    ALPM_PKG_FROM_SYNCDB = 3,
}
pub use self::_alpm_pkgfrom_t as alpm_pkgfrom_t;
pub mod _alpm_pkgvalidation_t {
    #[doc = " Method used to validate a package."]
    pub type Type = u32;
    pub const ALPM_PKG_VALIDATION_UNKNOWN: Type = 0;
    pub const ALPM_PKG_VALIDATION_NONE: Type = 1;
    pub const ALPM_PKG_VALIDATION_MD5SUM: Type = 2;
    pub const ALPM_PKG_VALIDATION_SHA256SUM: Type = 4;
    pub const ALPM_PKG_VALIDATION_SIGNATURE: Type = 8;
}
pub use self::_alpm_pkgvalidation_t::Type as alpm_pkgvalidation_t;
#[repr(u32)]
#[doc = " Types of version constraints in dependency specs."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _alpm_depmod_t {
    #[doc = " No version constraint"]
    ALPM_DEP_MOD_ANY = 1,
    #[doc = " Test version equality (package=x.y.z)"]
    ALPM_DEP_MOD_EQ = 2,
    #[doc = " Test for at least a version (package>=x.y.z)"]
    ALPM_DEP_MOD_GE = 3,
    #[doc = " Test for at most a version (package<=x.y.z)"]
    ALPM_DEP_MOD_LE = 4,
    #[doc = " Test for greater than some version (package>x.y.z)"]
    ALPM_DEP_MOD_GT = 5,
    #[doc = " Test for less than some version (package<x.y.z)"]
    ALPM_DEP_MOD_LT = 6,
}
pub use self::_alpm_depmod_t as alpm_depmod_t;
#[repr(u32)]
#[doc = " File conflict type."]
#[doc = " Whether the conflict results from a file existing on the filesystem, or with"]
#[doc = " another target in the transaction."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _alpm_fileconflicttype_t {
    ALPM_FILECONFLICT_TARGET = 1,
    ALPM_FILECONFLICT_FILESYSTEM = 2,
}
pub use self::_alpm_fileconflicttype_t as alpm_fileconflicttype_t;
pub mod _alpm_siglevel_t {
    #[doc = " PGP signature verification options"]
    pub type Type = u32;
    pub const ALPM_SIG_PACKAGE: Type = 1;
    pub const ALPM_SIG_PACKAGE_OPTIONAL: Type = 2;
    pub const ALPM_SIG_PACKAGE_MARGINAL_OK: Type = 4;
    pub const ALPM_SIG_PACKAGE_UNKNOWN_OK: Type = 8;
    pub const ALPM_SIG_DATABASE: Type = 1024;
    pub const ALPM_SIG_DATABASE_OPTIONAL: Type = 2048;
    pub const ALPM_SIG_DATABASE_MARGINAL_OK: Type = 4096;
    pub const ALPM_SIG_DATABASE_UNKNOWN_OK: Type = 8192;
    pub const ALPM_SIG_USE_DEFAULT: Type = 1073741824;
}
pub use self::_alpm_siglevel_t::Type as alpm_siglevel_t;
#[repr(u32)]
#[doc = " PGP signature verification status return codes"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _alpm_sigstatus_t {
    ALPM_SIGSTATUS_VALID = 0,
    ALPM_SIGSTATUS_KEY_EXPIRED = 1,
    ALPM_SIGSTATUS_SIG_EXPIRED = 2,
    ALPM_SIGSTATUS_KEY_UNKNOWN = 3,
    ALPM_SIGSTATUS_KEY_DISABLED = 4,
    ALPM_SIGSTATUS_INVALID = 5,
}
pub use self::_alpm_sigstatus_t as alpm_sigstatus_t;
#[repr(u32)]
#[doc = " PGP signature verification status return codes"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _alpm_sigvalidity_t {
    ALPM_SIGVALIDITY_FULL = 0,
    ALPM_SIGVALIDITY_MARGINAL = 1,
    ALPM_SIGVALIDITY_NEVER = 2,
    ALPM_SIGVALIDITY_UNKNOWN = 3,
}
pub use self::_alpm_sigvalidity_t as alpm_sigvalidity_t;
#[doc = " Dependency"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _alpm_depend_t {
    pub name: *mut ::std::os::raw::c_char,
    pub version: *mut ::std::os::raw::c_char,
    pub desc: *mut ::std::os::raw::c_char,
    pub name_hash: ::std::os::raw::c_ulong,
    pub mod_: alpm_depmod_t,
}
#[test]
fn bindgen_test_layout__alpm_depend_t() {
    assert_eq!(
        ::std::mem::size_of::<_alpm_depend_t>(),
        40usize,
        concat!("Size of: ", stringify!(_alpm_depend_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_alpm_depend_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_alpm_depend_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_alpm_depend_t>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_alpm_depend_t),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_alpm_depend_t>())).version as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_alpm_depend_t),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_alpm_depend_t>())).desc as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_alpm_depend_t),
            "::",
            stringify!(desc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_alpm_depend_t>())).name_hash as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_alpm_depend_t),
            "::",
            stringify!(name_hash)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_alpm_depend_t>())).mod_ as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_alpm_depend_t),
            "::",
            stringify!(mod_)
        )
    );
}
pub type alpm_depend_t = _alpm_depend_t;
#[doc = " Missing dependency"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _alpm_depmissing_t {
    pub target: *mut ::std::os::raw::c_char,
    pub depend: *mut alpm_depend_t,
    pub causingpkg: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__alpm_depmissing_t() {
    assert_eq!(
        ::std::mem::size_of::<_alpm_depmissing_t>(),
        24usize,
        concat!("Size of: ", stringify!(_alpm_depmissing_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_alpm_depmissing_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_alpm_depmissing_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_alpm_depmissing_t>())).target as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_alpm_depmissing_t),
            "::",
            stringify!(target)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_alpm_depmissing_t>())).depend as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_alpm_depmissing_t),
            "::",
            stringify!(depend)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_alpm_depmissing_t>())).causingpkg as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_alpm_depmissing_t),
            "::",
            stringify!(causingpkg)
        )
    );
}
pub type alpm_depmissing_t = _alpm_depmissing_t;
#[doc = " Conflict"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _alpm_conflict_t {
    pub package1_hash: ::std::os::raw::c_ulong,
    pub package2_hash: ::std::os::raw::c_ulong,
    pub package1: *mut ::std::os::raw::c_char,
    pub package2: *mut ::std::os::raw::c_char,
    pub reason: *mut alpm_depend_t,
}
#[test]
fn bindgen_test_layout__alpm_conflict_t() {
    assert_eq!(
        ::std::mem::size_of::<_alpm_conflict_t>(),
        40usize,
        concat!("Size of: ", stringify!(_alpm_conflict_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_alpm_conflict_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_alpm_conflict_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_alpm_conflict_t>())).package1_hash as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_alpm_conflict_t),
            "::",
            stringify!(package1_hash)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_alpm_conflict_t>())).package2_hash as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_alpm_conflict_t),
            "::",
            stringify!(package2_hash)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_alpm_conflict_t>())).package1 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_alpm_conflict_t),
            "::",
            stringify!(package1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_alpm_conflict_t>())).package2 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_alpm_conflict_t),
            "::",
            stringify!(package2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_alpm_conflict_t>())).reason as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_alpm_conflict_t),
            "::",
            stringify!(reason)
        )
    );
}
pub type alpm_conflict_t = _alpm_conflict_t;
#[doc = " File conflict"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _alpm_fileconflict_t {
    pub target: *mut ::std::os::raw::c_char,
    pub type_: alpm_fileconflicttype_t,
    pub file: *mut ::std::os::raw::c_char,
    pub ctarget: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__alpm_fileconflict_t() {
    assert_eq!(
        ::std::mem::size_of::<_alpm_fileconflict_t>(),
        32usize,
        concat!("Size of: ", stringify!(_alpm_fileconflict_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_alpm_fileconflict_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_alpm_fileconflict_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_alpm_fileconflict_t>())).target as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_alpm_fileconflict_t),
            "::",
            stringify!(target)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_alpm_fileconflict_t>())).type_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_alpm_fileconflict_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_alpm_fileconflict_t>())).file as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_alpm_fileconflict_t),
            "::",
            stringify!(file)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_alpm_fileconflict_t>())).ctarget as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_alpm_fileconflict_t),
            "::",
            stringify!(ctarget)
        )
    );
}
pub type alpm_fileconflict_t = _alpm_fileconflict_t;
#[doc = " Package group"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _alpm_group_t {
    #[doc = " group name"]
    pub name: *mut ::std::os::raw::c_char,
    #[doc = " list of alpm_pkg_t packages"]
    pub packages: *mut alpm_list_t,
}
#[test]
fn bindgen_test_layout__alpm_group_t() {
    assert_eq!(
        ::std::mem::size_of::<_alpm_group_t>(),
        16usize,
        concat!("Size of: ", stringify!(_alpm_group_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_alpm_group_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_alpm_group_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_alpm_group_t>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_alpm_group_t),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_alpm_group_t>())).packages as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_alpm_group_t),
            "::",
            stringify!(packages)
        )
    );
}
pub type alpm_group_t = _alpm_group_t;
#[doc = " File in a package"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _alpm_file_t {
    pub name: *mut ::std::os::raw::c_char,
    pub size: off_t,
    pub mode: mode_t,
}
#[test]
fn bindgen_test_layout__alpm_file_t() {
    assert_eq!(
        ::std::mem::size_of::<_alpm_file_t>(),
        24usize,
        concat!("Size of: ", stringify!(_alpm_file_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_alpm_file_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_alpm_file_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_alpm_file_t>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_alpm_file_t),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_alpm_file_t>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_alpm_file_t),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_alpm_file_t>())).mode as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_alpm_file_t),
            "::",
            stringify!(mode)
        )
    );
}
pub type alpm_file_t = _alpm_file_t;
#[doc = " Package filelist container"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _alpm_filelist_t {
    pub count: usize,
    pub files: *mut alpm_file_t,
}
#[test]
fn bindgen_test_layout__alpm_filelist_t() {
    assert_eq!(
        ::std::mem::size_of::<_alpm_filelist_t>(),
        16usize,
        concat!("Size of: ", stringify!(_alpm_filelist_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_alpm_filelist_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_alpm_filelist_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_alpm_filelist_t>())).count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_alpm_filelist_t),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_alpm_filelist_t>())).files as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_alpm_filelist_t),
            "::",
            stringify!(files)
        )
    );
}
pub type alpm_filelist_t = _alpm_filelist_t;
#[doc = " Local package or package file backup entry"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _alpm_backup_t {
    pub name: *mut ::std::os::raw::c_char,
    pub hash: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__alpm_backup_t() {
    assert_eq!(
        ::std::mem::size_of::<_alpm_backup_t>(),
        16usize,
        concat!("Size of: ", stringify!(_alpm_backup_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_alpm_backup_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_alpm_backup_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_alpm_backup_t>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_alpm_backup_t),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_alpm_backup_t>())).hash as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_alpm_backup_t),
            "::",
            stringify!(hash)
        )
    );
}
pub type alpm_backup_t = _alpm_backup_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _alpm_pgpkey_t {
    pub data: *mut ::std::os::raw::c_void,
    pub fingerprint: *mut ::std::os::raw::c_char,
    pub uid: *mut ::std::os::raw::c_char,
    pub name: *mut ::std::os::raw::c_char,
    pub email: *mut ::std::os::raw::c_char,
    pub created: alpm_time_t,
    pub expires: alpm_time_t,
    pub length: ::std::os::raw::c_uint,
    pub revoked: ::std::os::raw::c_uint,
    pub pubkey_algo: ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__alpm_pgpkey_t() {
    assert_eq!(
        ::std::mem::size_of::<_alpm_pgpkey_t>(),
        72usize,
        concat!("Size of: ", stringify!(_alpm_pgpkey_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_alpm_pgpkey_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_alpm_pgpkey_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_alpm_pgpkey_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_alpm_pgpkey_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_alpm_pgpkey_t>())).fingerprint as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_alpm_pgpkey_t),
            "::",
            stringify!(fingerprint)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_alpm_pgpkey_t>())).uid as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_alpm_pgpkey_t),
            "::",
            stringify!(uid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_alpm_pgpkey_t>())).name as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_alpm_pgpkey_t),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_alpm_pgpkey_t>())).email as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_alpm_pgpkey_t),
            "::",
            stringify!(email)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_alpm_pgpkey_t>())).created as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_alpm_pgpkey_t),
            "::",
            stringify!(created)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_alpm_pgpkey_t>())).expires as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_alpm_pgpkey_t),
            "::",
            stringify!(expires)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_alpm_pgpkey_t>())).length as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_alpm_pgpkey_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_alpm_pgpkey_t>())).revoked as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_alpm_pgpkey_t),
            "::",
            stringify!(revoked)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_alpm_pgpkey_t>())).pubkey_algo as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_alpm_pgpkey_t),
            "::",
            stringify!(pubkey_algo)
        )
    );
}
pub type alpm_pgpkey_t = _alpm_pgpkey_t;
#[doc = " Signature result. Contains the key, status, and validity of a given"]
#[doc = " signature."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _alpm_sigresult_t {
    pub key: alpm_pgpkey_t,
    pub status: alpm_sigstatus_t,
    pub validity: alpm_sigvalidity_t,
}
#[test]
fn bindgen_test_layout__alpm_sigresult_t() {
    assert_eq!(
        ::std::mem::size_of::<_alpm_sigresult_t>(),
        80usize,
        concat!("Size of: ", stringify!(_alpm_sigresult_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_alpm_sigresult_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_alpm_sigresult_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_alpm_sigresult_t>())).key as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_alpm_sigresult_t),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_alpm_sigresult_t>())).status as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_alpm_sigresult_t),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_alpm_sigresult_t>())).validity as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(_alpm_sigresult_t),
            "::",
            stringify!(validity)
        )
    );
}
pub type alpm_sigresult_t = _alpm_sigresult_t;
#[doc = " Signature list. Contains the number of signatures found and a pointer to an"]
#[doc = " array of results. The array is of size count."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _alpm_siglist_t {
    pub count: usize,
    pub results: *mut alpm_sigresult_t,
}
#[test]
fn bindgen_test_layout__alpm_siglist_t() {
    assert_eq!(
        ::std::mem::size_of::<_alpm_siglist_t>(),
        16usize,
        concat!("Size of: ", stringify!(_alpm_siglist_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_alpm_siglist_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_alpm_siglist_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_alpm_siglist_t>())).count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_alpm_siglist_t),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_alpm_siglist_t>())).results as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_alpm_siglist_t),
            "::",
            stringify!(results)
        )
    );
}
pub type alpm_siglist_t = _alpm_siglist_t;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _alpm_hook_when_t {
    ALPM_HOOK_PRE_TRANSACTION = 1,
    ALPM_HOOK_POST_TRANSACTION = 2,
}
pub use self::_alpm_hook_when_t as alpm_hook_when_t;
pub mod _alpm_loglevel_t {
    #[doc = " Logging Levels"]
    pub type Type = u32;
    pub const ALPM_LOG_ERROR: Type = 1;
    pub const ALPM_LOG_WARNING: Type = 2;
    pub const ALPM_LOG_DEBUG: Type = 4;
    pub const ALPM_LOG_FUNCTION: Type = 8;
}
pub use self::_alpm_loglevel_t::Type as alpm_loglevel_t;
pub type alpm_cb_log = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: alpm_loglevel_t,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ),
>;
extern "C" {
    pub fn alpm_logaction(
        handle: *mut alpm_handle_t,
        prefix: *const ::std::os::raw::c_char,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
#[repr(u32)]
#[doc = " Type of events."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _alpm_event_type_t {
    #[doc = " Dependencies will be computed for a package."]
    ALPM_EVENT_CHECKDEPS_START = 1,
    #[doc = " Dependencies were computed for a package."]
    ALPM_EVENT_CHECKDEPS_DONE = 2,
    #[doc = " File conflicts will be computed for a package."]
    ALPM_EVENT_FILECONFLICTS_START = 3,
    #[doc = " File conflicts were computed for a package."]
    ALPM_EVENT_FILECONFLICTS_DONE = 4,
    #[doc = " Dependencies will be resolved for target package."]
    ALPM_EVENT_RESOLVEDEPS_START = 5,
    #[doc = " Dependencies were resolved for target package."]
    ALPM_EVENT_RESOLVEDEPS_DONE = 6,
    #[doc = " Inter-conflicts will be checked for target package."]
    ALPM_EVENT_INTERCONFLICTS_START = 7,
    #[doc = " Inter-conflicts were checked for target package."]
    ALPM_EVENT_INTERCONFLICTS_DONE = 8,
    #[doc = " Processing the package transaction is starting."]
    ALPM_EVENT_TRANSACTION_START = 9,
    #[doc = " Processing the package transaction is finished."]
    ALPM_EVENT_TRANSACTION_DONE = 10,
    #[doc = " Package will be installed/upgraded/downgraded/re-installed/removed; See"]
    #[doc = " alpm_event_package_operation_t for arguments."]
    ALPM_EVENT_PACKAGE_OPERATION_START = 11,
    #[doc = " Package was installed/upgraded/downgraded/re-installed/removed; See"]
    #[doc = " alpm_event_package_operation_t for arguments."]
    ALPM_EVENT_PACKAGE_OPERATION_DONE = 12,
    #[doc = " Target package's integrity will be checked."]
    ALPM_EVENT_INTEGRITY_START = 13,
    #[doc = " Target package's integrity was checked."]
    ALPM_EVENT_INTEGRITY_DONE = 14,
    #[doc = " Target package will be loaded."]
    ALPM_EVENT_LOAD_START = 15,
    #[doc = " Target package is finished loading."]
    ALPM_EVENT_LOAD_DONE = 16,
    #[doc = " Scriptlet has printed information; See alpm_event_scriptlet_info_t for"]
    #[doc = " arguments."]
    ALPM_EVENT_SCRIPTLET_INFO = 17,
    #[doc = " Files will be downloaded from a repository."]
    ALPM_EVENT_RETRIEVE_START = 18,
    #[doc = " Files were downloaded from a repository."]
    ALPM_EVENT_RETRIEVE_DONE = 19,
    #[doc = " Not all files were successfully downloaded from a repository."]
    ALPM_EVENT_RETRIEVE_FAILED = 20,
    #[doc = " A file will be downloaded from a repository; See alpm_event_pkgdownload_t"]
    #[doc = " for arguments"]
    ALPM_EVENT_PKGDOWNLOAD_START = 21,
    #[doc = " A file was downloaded from a repository; See alpm_event_pkgdownload_t"]
    #[doc = " for arguments"]
    ALPM_EVENT_PKGDOWNLOAD_DONE = 22,
    #[doc = " A file failed to be downloaded from a repository; See"]
    #[doc = " alpm_event_pkgdownload_t for arguments"]
    ALPM_EVENT_PKGDOWNLOAD_FAILED = 23,
    #[doc = " Disk space usage will be computed for a package."]
    ALPM_EVENT_DISKSPACE_START = 24,
    #[doc = " Disk space usage was computed for a package."]
    ALPM_EVENT_DISKSPACE_DONE = 25,
    #[doc = " An optdepend for another package is being removed; See"]
    #[doc = " alpm_event_optdep_removal_t for arguments."]
    ALPM_EVENT_OPTDEP_REMOVAL = 26,
    #[doc = " A configured repository database is missing; See"]
    #[doc = " alpm_event_database_missing_t for arguments."]
    ALPM_EVENT_DATABASE_MISSING = 27,
    #[doc = " Checking keys used to create signatures are in keyring."]
    ALPM_EVENT_KEYRING_START = 28,
    #[doc = " Keyring checking is finished."]
    ALPM_EVENT_KEYRING_DONE = 29,
    #[doc = " Downloading missing keys into keyring."]
    ALPM_EVENT_KEY_DOWNLOAD_START = 30,
    #[doc = " Key downloading is finished."]
    ALPM_EVENT_KEY_DOWNLOAD_DONE = 31,
    #[doc = " A .pacnew file was created; See alpm_event_pacnew_created_t for arguments."]
    ALPM_EVENT_PACNEW_CREATED = 32,
    #[doc = " A .pacsave file was created; See alpm_event_pacsave_created_t for"]
    #[doc = " arguments"]
    ALPM_EVENT_PACSAVE_CREATED = 33,
    #[doc = " Processing hooks will be started."]
    ALPM_EVENT_HOOK_START = 34,
    #[doc = " Processing hooks is finished."]
    ALPM_EVENT_HOOK_DONE = 35,
    #[doc = " A hook is starting"]
    ALPM_EVENT_HOOK_RUN_START = 36,
    #[doc = " A hook has finished running"]
    ALPM_EVENT_HOOK_RUN_DONE = 37,
}
pub use self::_alpm_event_type_t as alpm_event_type_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _alpm_event_any_t {
    #[doc = " Type of event."]
    pub type_: alpm_event_type_t,
}
#[test]
fn bindgen_test_layout__alpm_event_any_t() {
    assert_eq!(
        ::std::mem::size_of::<_alpm_event_any_t>(),
        4usize,
        concat!("Size of: ", stringify!(_alpm_event_any_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_alpm_event_any_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_alpm_event_any_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_alpm_event_any_t>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_alpm_event_any_t),
            "::",
            stringify!(type_)
        )
    );
}
pub type alpm_event_any_t = _alpm_event_any_t;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _alpm_package_operation_t {
    #[doc = " Package (to be) installed. (No oldpkg)"]
    ALPM_PACKAGE_INSTALL = 1,
    #[doc = " Package (to be) upgraded"]
    ALPM_PACKAGE_UPGRADE = 2,
    #[doc = " Package (to be) re-installed."]
    ALPM_PACKAGE_REINSTALL = 3,
    #[doc = " Package (to be) downgraded."]
    ALPM_PACKAGE_DOWNGRADE = 4,
    #[doc = " Package (to be) removed. (No newpkg)"]
    ALPM_PACKAGE_REMOVE = 5,
}
pub use self::_alpm_package_operation_t as alpm_package_operation_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _alpm_event_package_operation_t {
    #[doc = " Type of event."]
    pub type_: alpm_event_type_t,
    #[doc = " Type of operation."]
    pub operation: alpm_package_operation_t,
    #[doc = " Old package."]
    pub oldpkg: *mut alpm_pkg_t,
    #[doc = " New package."]
    pub newpkg: *mut alpm_pkg_t,
}
#[test]
fn bindgen_test_layout__alpm_event_package_operation_t() {
    assert_eq!(
        ::std::mem::size_of::<_alpm_event_package_operation_t>(),
        24usize,
        concat!("Size of: ", stringify!(_alpm_event_package_operation_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_alpm_event_package_operation_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_alpm_event_package_operation_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_alpm_event_package_operation_t>())).type_ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_alpm_event_package_operation_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_alpm_event_package_operation_t>())).operation as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_alpm_event_package_operation_t),
            "::",
            stringify!(operation)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_alpm_event_package_operation_t>())).oldpkg as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_alpm_event_package_operation_t),
            "::",
            stringify!(oldpkg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_alpm_event_package_operation_t>())).newpkg as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_alpm_event_package_operation_t),
            "::",
            stringify!(newpkg)
        )
    );
}
pub type alpm_event_package_operation_t = _alpm_event_package_operation_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _alpm_event_optdep_removal_t {
    #[doc = " Type of event."]
    pub type_: alpm_event_type_t,
    #[doc = " Package with the optdep."]
    pub pkg: *mut alpm_pkg_t,
    #[doc = " Optdep being removed."]
    pub optdep: *mut alpm_depend_t,
}
#[test]
fn bindgen_test_layout__alpm_event_optdep_removal_t() {
    assert_eq!(
        ::std::mem::size_of::<_alpm_event_optdep_removal_t>(),
        24usize,
        concat!("Size of: ", stringify!(_alpm_event_optdep_removal_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_alpm_event_optdep_removal_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_alpm_event_optdep_removal_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_alpm_event_optdep_removal_t>())).type_ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_alpm_event_optdep_removal_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_alpm_event_optdep_removal_t>())).pkg as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_alpm_event_optdep_removal_t),
            "::",
            stringify!(pkg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_alpm_event_optdep_removal_t>())).optdep as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_alpm_event_optdep_removal_t),
            "::",
            stringify!(optdep)
        )
    );
}
pub type alpm_event_optdep_removal_t = _alpm_event_optdep_removal_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _alpm_event_scriptlet_info_t {
    #[doc = " Type of event."]
    pub type_: alpm_event_type_t,
    #[doc = " Line of scriptlet output."]
    pub line: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__alpm_event_scriptlet_info_t() {
    assert_eq!(
        ::std::mem::size_of::<_alpm_event_scriptlet_info_t>(),
        16usize,
        concat!("Size of: ", stringify!(_alpm_event_scriptlet_info_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_alpm_event_scriptlet_info_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_alpm_event_scriptlet_info_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_alpm_event_scriptlet_info_t>())).type_ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_alpm_event_scriptlet_info_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_alpm_event_scriptlet_info_t>())).line as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_alpm_event_scriptlet_info_t),
            "::",
            stringify!(line)
        )
    );
}
pub type alpm_event_scriptlet_info_t = _alpm_event_scriptlet_info_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _alpm_event_database_missing_t {
    #[doc = " Type of event."]
    pub type_: alpm_event_type_t,
    #[doc = " Name of the database."]
    pub dbname: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__alpm_event_database_missing_t() {
    assert_eq!(
        ::std::mem::size_of::<_alpm_event_database_missing_t>(),
        16usize,
        concat!("Size of: ", stringify!(_alpm_event_database_missing_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_alpm_event_database_missing_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_alpm_event_database_missing_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_alpm_event_database_missing_t>())).type_ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_alpm_event_database_missing_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_alpm_event_database_missing_t>())).dbname as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_alpm_event_database_missing_t),
            "::",
            stringify!(dbname)
        )
    );
}
pub type alpm_event_database_missing_t = _alpm_event_database_missing_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _alpm_event_pkgdownload_t {
    #[doc = " Type of event."]
    pub type_: alpm_event_type_t,
    #[doc = " Name of the file"]
    pub file: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__alpm_event_pkgdownload_t() {
    assert_eq!(
        ::std::mem::size_of::<_alpm_event_pkgdownload_t>(),
        16usize,
        concat!("Size of: ", stringify!(_alpm_event_pkgdownload_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_alpm_event_pkgdownload_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_alpm_event_pkgdownload_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_alpm_event_pkgdownload_t>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_alpm_event_pkgdownload_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_alpm_event_pkgdownload_t>())).file as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_alpm_event_pkgdownload_t),
            "::",
            stringify!(file)
        )
    );
}
pub type alpm_event_pkgdownload_t = _alpm_event_pkgdownload_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _alpm_event_pacnew_created_t {
    #[doc = " Type of event."]
    pub type_: alpm_event_type_t,
    #[doc = " Whether the creation was result of a NoUpgrade or not"]
    pub from_noupgrade: ::std::os::raw::c_int,
    #[doc = " Old package."]
    pub oldpkg: *mut alpm_pkg_t,
    #[doc = " New Package."]
    pub newpkg: *mut alpm_pkg_t,
    #[doc = " Filename of the file without the .pacnew suffix"]
    pub file: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__alpm_event_pacnew_created_t() {
    assert_eq!(
        ::std::mem::size_of::<_alpm_event_pacnew_created_t>(),
        32usize,
        concat!("Size of: ", stringify!(_alpm_event_pacnew_created_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_alpm_event_pacnew_created_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_alpm_event_pacnew_created_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_alpm_event_pacnew_created_t>())).type_ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_alpm_event_pacnew_created_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_alpm_event_pacnew_created_t>())).from_noupgrade as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_alpm_event_pacnew_created_t),
            "::",
            stringify!(from_noupgrade)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_alpm_event_pacnew_created_t>())).oldpkg as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_alpm_event_pacnew_created_t),
            "::",
            stringify!(oldpkg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_alpm_event_pacnew_created_t>())).newpkg as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_alpm_event_pacnew_created_t),
            "::",
            stringify!(newpkg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_alpm_event_pacnew_created_t>())).file as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_alpm_event_pacnew_created_t),
            "::",
            stringify!(file)
        )
    );
}
pub type alpm_event_pacnew_created_t = _alpm_event_pacnew_created_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _alpm_event_pacsave_created_t {
    #[doc = " Type of event."]
    pub type_: alpm_event_type_t,
    #[doc = " Old package."]
    pub oldpkg: *mut alpm_pkg_t,
    #[doc = " Filename of the file without the .pacsave suffix."]
    pub file: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__alpm_event_pacsave_created_t() {
    assert_eq!(
        ::std::mem::size_of::<_alpm_event_pacsave_created_t>(),
        24usize,
        concat!("Size of: ", stringify!(_alpm_event_pacsave_created_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_alpm_event_pacsave_created_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_alpm_event_pacsave_created_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_alpm_event_pacsave_created_t>())).type_ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_alpm_event_pacsave_created_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_alpm_event_pacsave_created_t>())).oldpkg as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_alpm_event_pacsave_created_t),
            "::",
            stringify!(oldpkg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_alpm_event_pacsave_created_t>())).file as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_alpm_event_pacsave_created_t),
            "::",
            stringify!(file)
        )
    );
}
pub type alpm_event_pacsave_created_t = _alpm_event_pacsave_created_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _alpm_event_hook_t {
    #[doc = " Type of event."]
    pub type_: alpm_event_type_t,
    #[doc = " Type of hooks."]
    pub when: alpm_hook_when_t,
}
#[test]
fn bindgen_test_layout__alpm_event_hook_t() {
    assert_eq!(
        ::std::mem::size_of::<_alpm_event_hook_t>(),
        8usize,
        concat!("Size of: ", stringify!(_alpm_event_hook_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_alpm_event_hook_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_alpm_event_hook_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_alpm_event_hook_t>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_alpm_event_hook_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_alpm_event_hook_t>())).when as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_alpm_event_hook_t),
            "::",
            stringify!(when)
        )
    );
}
pub type alpm_event_hook_t = _alpm_event_hook_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _alpm_event_hook_run_t {
    #[doc = " Type of event."]
    pub type_: alpm_event_type_t,
    #[doc = " Name of hook"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = " Description of hook to be outputted"]
    pub desc: *const ::std::os::raw::c_char,
    #[doc = " position of hook being run"]
    pub position: usize,
    #[doc = " total hooks being run"]
    pub total: usize,
}
#[test]
fn bindgen_test_layout__alpm_event_hook_run_t() {
    assert_eq!(
        ::std::mem::size_of::<_alpm_event_hook_run_t>(),
        40usize,
        concat!("Size of: ", stringify!(_alpm_event_hook_run_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_alpm_event_hook_run_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_alpm_event_hook_run_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_alpm_event_hook_run_t>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_alpm_event_hook_run_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_alpm_event_hook_run_t>())).name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_alpm_event_hook_run_t),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_alpm_event_hook_run_t>())).desc as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_alpm_event_hook_run_t),
            "::",
            stringify!(desc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_alpm_event_hook_run_t>())).position as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_alpm_event_hook_run_t),
            "::",
            stringify!(position)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_alpm_event_hook_run_t>())).total as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_alpm_event_hook_run_t),
            "::",
            stringify!(total)
        )
    );
}
pub type alpm_event_hook_run_t = _alpm_event_hook_run_t;
#[doc = " Events."]
#[doc = " This is an union passed to the callback, that allows the frontend to know"]
#[doc = " which type of event was triggered (via type). It is then possible to"]
#[doc = " typecast the pointer to the right structure, or use the union field, in order"]
#[doc = " to access event-specific data."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _alpm_event_t {
    pub type_: alpm_event_type_t,
    pub any: alpm_event_any_t,
    pub package_operation: alpm_event_package_operation_t,
    pub optdep_removal: alpm_event_optdep_removal_t,
    pub scriptlet_info: alpm_event_scriptlet_info_t,
    pub database_missing: alpm_event_database_missing_t,
    pub pkgdownload: alpm_event_pkgdownload_t,
    pub pacnew_created: alpm_event_pacnew_created_t,
    pub pacsave_created: alpm_event_pacsave_created_t,
    pub hook: alpm_event_hook_t,
    pub hook_run: alpm_event_hook_run_t,
    _bindgen_union_align: [u64; 5usize],
}
#[test]
fn bindgen_test_layout__alpm_event_t() {
    assert_eq!(
        ::std::mem::size_of::<_alpm_event_t>(),
        40usize,
        concat!("Size of: ", stringify!(_alpm_event_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_alpm_event_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_alpm_event_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_alpm_event_t>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_alpm_event_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_alpm_event_t>())).any as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_alpm_event_t),
            "::",
            stringify!(any)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_alpm_event_t>())).package_operation as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_alpm_event_t),
            "::",
            stringify!(package_operation)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_alpm_event_t>())).optdep_removal as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_alpm_event_t),
            "::",
            stringify!(optdep_removal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_alpm_event_t>())).scriptlet_info as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_alpm_event_t),
            "::",
            stringify!(scriptlet_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_alpm_event_t>())).database_missing as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_alpm_event_t),
            "::",
            stringify!(database_missing)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_alpm_event_t>())).pkgdownload as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_alpm_event_t),
            "::",
            stringify!(pkgdownload)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_alpm_event_t>())).pacnew_created as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_alpm_event_t),
            "::",
            stringify!(pacnew_created)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_alpm_event_t>())).pacsave_created as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_alpm_event_t),
            "::",
            stringify!(pacsave_created)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_alpm_event_t>())).hook as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_alpm_event_t),
            "::",
            stringify!(hook)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_alpm_event_t>())).hook_run as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_alpm_event_t),
            "::",
            stringify!(hook_run)
        )
    );
}
pub type alpm_event_t = _alpm_event_t;
#[doc = " Event callback."]
pub type alpm_cb_event = ::std::option::Option<unsafe extern "C" fn(arg1: *mut alpm_event_t)>;
pub mod _alpm_question_type_t {
    #[doc = " Type of questions."]
    #[doc = " Unlike the events or progress enumerations, this enum has bitmask values"]
    #[doc = " so a frontend can use a bitmask map to supply preselected answers to the"]
    #[doc = " different types of questions."]
    pub type Type = u32;
    pub const ALPM_QUESTION_INSTALL_IGNOREPKG: Type = 1;
    pub const ALPM_QUESTION_REPLACE_PKG: Type = 2;
    pub const ALPM_QUESTION_CONFLICT_PKG: Type = 4;
    pub const ALPM_QUESTION_CORRUPTED_PKG: Type = 8;
    pub const ALPM_QUESTION_REMOVE_PKGS: Type = 16;
    pub const ALPM_QUESTION_SELECT_PROVIDER: Type = 32;
    pub const ALPM_QUESTION_IMPORT_KEY: Type = 64;
}
pub use self::_alpm_question_type_t::Type as alpm_question_type_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _alpm_question_any_t {
    #[doc = " Type of question."]
    pub type_: alpm_question_type_t,
    #[doc = " Answer."]
    pub answer: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__alpm_question_any_t() {
    assert_eq!(
        ::std::mem::size_of::<_alpm_question_any_t>(),
        8usize,
        concat!("Size of: ", stringify!(_alpm_question_any_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_alpm_question_any_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_alpm_question_any_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_alpm_question_any_t>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_alpm_question_any_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_alpm_question_any_t>())).answer as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_alpm_question_any_t),
            "::",
            stringify!(answer)
        )
    );
}
pub type alpm_question_any_t = _alpm_question_any_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _alpm_question_install_ignorepkg_t {
    #[doc = " Type of question."]
    pub type_: alpm_question_type_t,
    #[doc = " Answer: whether or not to install pkg anyway."]
    pub install: ::std::os::raw::c_int,
    pub pkg: *mut alpm_pkg_t,
}
#[test]
fn bindgen_test_layout__alpm_question_install_ignorepkg_t() {
    assert_eq!(
        ::std::mem::size_of::<_alpm_question_install_ignorepkg_t>(),
        16usize,
        concat!("Size of: ", stringify!(_alpm_question_install_ignorepkg_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_alpm_question_install_ignorepkg_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_alpm_question_install_ignorepkg_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_alpm_question_install_ignorepkg_t>())).type_ as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_alpm_question_install_ignorepkg_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_alpm_question_install_ignorepkg_t>())).install as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_alpm_question_install_ignorepkg_t),
            "::",
            stringify!(install)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_alpm_question_install_ignorepkg_t>())).pkg as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_alpm_question_install_ignorepkg_t),
            "::",
            stringify!(pkg)
        )
    );
}
pub type alpm_question_install_ignorepkg_t = _alpm_question_install_ignorepkg_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _alpm_question_replace_t {
    #[doc = " Type of question."]
    pub type_: alpm_question_type_t,
    #[doc = " Answer: whether or not to replace oldpkg with newpkg."]
    pub replace: ::std::os::raw::c_int,
    pub oldpkg: *mut alpm_pkg_t,
    pub newpkg: *mut alpm_pkg_t,
    pub newdb: *mut alpm_db_t,
}
#[test]
fn bindgen_test_layout__alpm_question_replace_t() {
    assert_eq!(
        ::std::mem::size_of::<_alpm_question_replace_t>(),
        32usize,
        concat!("Size of: ", stringify!(_alpm_question_replace_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_alpm_question_replace_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_alpm_question_replace_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_alpm_question_replace_t>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_alpm_question_replace_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_alpm_question_replace_t>())).replace as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_alpm_question_replace_t),
            "::",
            stringify!(replace)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_alpm_question_replace_t>())).oldpkg as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_alpm_question_replace_t),
            "::",
            stringify!(oldpkg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_alpm_question_replace_t>())).newpkg as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_alpm_question_replace_t),
            "::",
            stringify!(newpkg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_alpm_question_replace_t>())).newdb as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_alpm_question_replace_t),
            "::",
            stringify!(newdb)
        )
    );
}
pub type alpm_question_replace_t = _alpm_question_replace_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _alpm_question_conflict_t {
    #[doc = " Type of question."]
    pub type_: alpm_question_type_t,
    #[doc = " Answer: whether or not to remove conflict->package2."]
    pub remove: ::std::os::raw::c_int,
    #[doc = " Conflict info."]
    pub conflict: *mut alpm_conflict_t,
}
#[test]
fn bindgen_test_layout__alpm_question_conflict_t() {
    assert_eq!(
        ::std::mem::size_of::<_alpm_question_conflict_t>(),
        16usize,
        concat!("Size of: ", stringify!(_alpm_question_conflict_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_alpm_question_conflict_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_alpm_question_conflict_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_alpm_question_conflict_t>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_alpm_question_conflict_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_alpm_question_conflict_t>())).remove as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_alpm_question_conflict_t),
            "::",
            stringify!(remove)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_alpm_question_conflict_t>())).conflict as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_alpm_question_conflict_t),
            "::",
            stringify!(conflict)
        )
    );
}
pub type alpm_question_conflict_t = _alpm_question_conflict_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _alpm_question_corrupted_t {
    #[doc = " Type of question."]
    pub type_: alpm_question_type_t,
    #[doc = " Answer: whether or not to remove filepath."]
    pub remove: ::std::os::raw::c_int,
    #[doc = " Filename to remove"]
    pub filepath: *const ::std::os::raw::c_char,
    #[doc = " Error code indicating the reason for package invalidity"]
    pub reason: alpm_errno_t,
}
#[test]
fn bindgen_test_layout__alpm_question_corrupted_t() {
    assert_eq!(
        ::std::mem::size_of::<_alpm_question_corrupted_t>(),
        24usize,
        concat!("Size of: ", stringify!(_alpm_question_corrupted_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_alpm_question_corrupted_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_alpm_question_corrupted_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_alpm_question_corrupted_t>())).type_ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_alpm_question_corrupted_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_alpm_question_corrupted_t>())).remove as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_alpm_question_corrupted_t),
            "::",
            stringify!(remove)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_alpm_question_corrupted_t>())).filepath as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_alpm_question_corrupted_t),
            "::",
            stringify!(filepath)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_alpm_question_corrupted_t>())).reason as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_alpm_question_corrupted_t),
            "::",
            stringify!(reason)
        )
    );
}
pub type alpm_question_corrupted_t = _alpm_question_corrupted_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _alpm_question_remove_pkgs_t {
    #[doc = " Type of question."]
    pub type_: alpm_question_type_t,
    #[doc = " Answer: whether or not to skip packages."]
    pub skip: ::std::os::raw::c_int,
    #[doc = " List of alpm_pkg_t* with unresolved dependencies."]
    pub packages: *mut alpm_list_t,
}
#[test]
fn bindgen_test_layout__alpm_question_remove_pkgs_t() {
    assert_eq!(
        ::std::mem::size_of::<_alpm_question_remove_pkgs_t>(),
        16usize,
        concat!("Size of: ", stringify!(_alpm_question_remove_pkgs_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_alpm_question_remove_pkgs_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_alpm_question_remove_pkgs_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_alpm_question_remove_pkgs_t>())).type_ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_alpm_question_remove_pkgs_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_alpm_question_remove_pkgs_t>())).skip as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_alpm_question_remove_pkgs_t),
            "::",
            stringify!(skip)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_alpm_question_remove_pkgs_t>())).packages as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_alpm_question_remove_pkgs_t),
            "::",
            stringify!(packages)
        )
    );
}
pub type alpm_question_remove_pkgs_t = _alpm_question_remove_pkgs_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _alpm_question_select_provider_t {
    #[doc = " Type of question."]
    pub type_: alpm_question_type_t,
    #[doc = " Answer: which provider to use (index from providers)."]
    pub use_index: ::std::os::raw::c_int,
    #[doc = " List of alpm_pkg_t* as possible providers."]
    pub providers: *mut alpm_list_t,
    #[doc = " What providers provide for."]
    pub depend: *mut alpm_depend_t,
}
#[test]
fn bindgen_test_layout__alpm_question_select_provider_t() {
    assert_eq!(
        ::std::mem::size_of::<_alpm_question_select_provider_t>(),
        24usize,
        concat!("Size of: ", stringify!(_alpm_question_select_provider_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_alpm_question_select_provider_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_alpm_question_select_provider_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_alpm_question_select_provider_t>())).type_ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_alpm_question_select_provider_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_alpm_question_select_provider_t>())).use_index as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_alpm_question_select_provider_t),
            "::",
            stringify!(use_index)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_alpm_question_select_provider_t>())).providers as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_alpm_question_select_provider_t),
            "::",
            stringify!(providers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_alpm_question_select_provider_t>())).depend as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_alpm_question_select_provider_t),
            "::",
            stringify!(depend)
        )
    );
}
pub type alpm_question_select_provider_t = _alpm_question_select_provider_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _alpm_question_import_key_t {
    #[doc = " Type of question."]
    pub type_: alpm_question_type_t,
    #[doc = " Answer: whether or not to import key."]
    pub import: ::std::os::raw::c_int,
    #[doc = " The key to import."]
    pub key: *mut alpm_pgpkey_t,
}
#[test]
fn bindgen_test_layout__alpm_question_import_key_t() {
    assert_eq!(
        ::std::mem::size_of::<_alpm_question_import_key_t>(),
        16usize,
        concat!("Size of: ", stringify!(_alpm_question_import_key_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_alpm_question_import_key_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_alpm_question_import_key_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_alpm_question_import_key_t>())).type_ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_alpm_question_import_key_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_alpm_question_import_key_t>())).import as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_alpm_question_import_key_t),
            "::",
            stringify!(import)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_alpm_question_import_key_t>())).key as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_alpm_question_import_key_t),
            "::",
            stringify!(key)
        )
    );
}
pub type alpm_question_import_key_t = _alpm_question_import_key_t;
#[doc = " Questions."]
#[doc = " This is an union passed to the callback, that allows the frontend to know"]
#[doc = " which type of question was triggered (via type). It is then possible to"]
#[doc = " typecast the pointer to the right structure, or use the union field, in order"]
#[doc = " to access question-specific data."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _alpm_question_t {
    pub type_: alpm_question_type_t,
    pub any: alpm_question_any_t,
    pub install_ignorepkg: alpm_question_install_ignorepkg_t,
    pub replace: alpm_question_replace_t,
    pub conflict: alpm_question_conflict_t,
    pub corrupted: alpm_question_corrupted_t,
    pub remove_pkgs: alpm_question_remove_pkgs_t,
    pub select_provider: alpm_question_select_provider_t,
    pub import_key: alpm_question_import_key_t,
    _bindgen_union_align: [u64; 4usize],
}
#[test]
fn bindgen_test_layout__alpm_question_t() {
    assert_eq!(
        ::std::mem::size_of::<_alpm_question_t>(),
        32usize,
        concat!("Size of: ", stringify!(_alpm_question_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_alpm_question_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_alpm_question_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_alpm_question_t>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_alpm_question_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_alpm_question_t>())).any as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_alpm_question_t),
            "::",
            stringify!(any)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_alpm_question_t>())).install_ignorepkg as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_alpm_question_t),
            "::",
            stringify!(install_ignorepkg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_alpm_question_t>())).replace as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_alpm_question_t),
            "::",
            stringify!(replace)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_alpm_question_t>())).conflict as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_alpm_question_t),
            "::",
            stringify!(conflict)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_alpm_question_t>())).corrupted as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_alpm_question_t),
            "::",
            stringify!(corrupted)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_alpm_question_t>())).remove_pkgs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_alpm_question_t),
            "::",
            stringify!(remove_pkgs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_alpm_question_t>())).select_provider as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_alpm_question_t),
            "::",
            stringify!(select_provider)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_alpm_question_t>())).import_key as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_alpm_question_t),
            "::",
            stringify!(import_key)
        )
    );
}
pub type alpm_question_t = _alpm_question_t;
#[doc = " Question callback"]
pub type alpm_cb_question = ::std::option::Option<unsafe extern "C" fn(arg1: *mut alpm_question_t)>;
#[repr(u32)]
#[doc = " Progress"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _alpm_progress_t {
    ALPM_PROGRESS_ADD_START = 0,
    ALPM_PROGRESS_UPGRADE_START = 1,
    ALPM_PROGRESS_DOWNGRADE_START = 2,
    ALPM_PROGRESS_REINSTALL_START = 3,
    ALPM_PROGRESS_REMOVE_START = 4,
    ALPM_PROGRESS_CONFLICTS_START = 5,
    ALPM_PROGRESS_DISKSPACE_START = 6,
    ALPM_PROGRESS_INTEGRITY_START = 7,
    ALPM_PROGRESS_LOAD_START = 8,
    ALPM_PROGRESS_KEYRING_START = 9,
}
pub use self::_alpm_progress_t as alpm_progress_t;
#[doc = " Progress callback"]
pub type alpm_cb_progress = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: alpm_progress_t,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: usize,
        arg5: usize,
    ),
>;
#[doc = " Type of download progress callbacks."]
#[doc = " @param filename the name of the file being downloaded"]
#[doc = " @param xfered the number of transferred bytes"]
#[doc = " @param total the total number of bytes to transfer"]
pub type alpm_cb_download = ::std::option::Option<
    unsafe extern "C" fn(filename: *const ::std::os::raw::c_char, xfered: off_t, total: off_t),
>;
pub type alpm_cb_totaldl = ::std::option::Option<unsafe extern "C" fn(total: off_t)>;
#[doc = " A callback for downloading files"]
#[doc = " @param url the URL of the file to be downloaded"]
#[doc = " @param localpath the directory to which the file should be downloaded"]
#[doc = " @param force whether to force an update, even if the file is the same"]
#[doc = " @return 0 on success, 1 if the file exists and is identical, -1 on"]
#[doc = " error."]
pub type alpm_cb_fetch = ::std::option::Option<
    unsafe extern "C" fn(
        url: *const ::std::os::raw::c_char,
        localpath: *const ::std::os::raw::c_char,
        force: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    #[doc = " Fetch a remote pkg."]
    #[doc = " @param handle the context handle"]
    #[doc = " @param url URL of the package to download"]
    #[doc = " @return the downloaded filepath on success, NULL on error"]
    pub fn alpm_fetch_pkgurl(
        handle: *mut alpm_handle_t,
        url: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns the callback used for logging."]
    pub fn alpm_option_get_logcb(handle: *mut alpm_handle_t) -> alpm_cb_log;
}
extern "C" {
    #[doc = " Sets the callback used for logging."]
    pub fn alpm_option_set_logcb(
        handle: *mut alpm_handle_t,
        cb: alpm_cb_log,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the callback used to report download progress."]
    pub fn alpm_option_get_dlcb(handle: *mut alpm_handle_t) -> alpm_cb_download;
}
extern "C" {
    #[doc = " Sets the callback used to report download progress."]
    pub fn alpm_option_set_dlcb(
        handle: *mut alpm_handle_t,
        cb: alpm_cb_download,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the downloading callback."]
    pub fn alpm_option_get_fetchcb(handle: *mut alpm_handle_t) -> alpm_cb_fetch;
}
extern "C" {
    #[doc = " Sets the downloading callback."]
    pub fn alpm_option_set_fetchcb(
        handle: *mut alpm_handle_t,
        cb: alpm_cb_fetch,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the callback used to report total download size."]
    pub fn alpm_option_get_totaldlcb(handle: *mut alpm_handle_t) -> alpm_cb_totaldl;
}
extern "C" {
    #[doc = " Sets the callback used to report total download size."]
    pub fn alpm_option_set_totaldlcb(
        handle: *mut alpm_handle_t,
        cb: alpm_cb_totaldl,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the callback used for events."]
    pub fn alpm_option_get_eventcb(handle: *mut alpm_handle_t) -> alpm_cb_event;
}
extern "C" {
    #[doc = " Sets the callback used for events."]
    pub fn alpm_option_set_eventcb(
        handle: *mut alpm_handle_t,
        cb: alpm_cb_event,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the callback used for questions."]
    pub fn alpm_option_get_questioncb(handle: *mut alpm_handle_t) -> alpm_cb_question;
}
extern "C" {
    #[doc = " Sets the callback used for questions."]
    pub fn alpm_option_set_questioncb(
        handle: *mut alpm_handle_t,
        cb: alpm_cb_question,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the callback used for operation progress."]
    pub fn alpm_option_get_progresscb(handle: *mut alpm_handle_t) -> alpm_cb_progress;
}
extern "C" {
    #[doc = " Sets the callback used for operation progress."]
    pub fn alpm_option_set_progresscb(
        handle: *mut alpm_handle_t,
        cb: alpm_cb_progress,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the root of the destination filesystem. Read-only."]
    pub fn alpm_option_get_root(handle: *mut alpm_handle_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns the path to the database directory. Read-only."]
    pub fn alpm_option_get_dbpath(handle: *mut alpm_handle_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get the name of the database lock file. Read-only."]
    pub fn alpm_option_get_lockfile(handle: *mut alpm_handle_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @name Accessors to the list of package cache directories."]
    #[doc = " @{"]
    pub fn alpm_option_get_cachedirs(handle: *mut alpm_handle_t) -> *mut alpm_list_t;
}
extern "C" {
    pub fn alpm_option_set_cachedirs(
        handle: *mut alpm_handle_t,
        cachedirs: *mut alpm_list_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn alpm_option_add_cachedir(
        handle: *mut alpm_handle_t,
        cachedir: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn alpm_option_remove_cachedir(
        handle: *mut alpm_handle_t,
        cachedir: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @name Accessors to the list of package hook directories."]
    #[doc = " @{"]
    pub fn alpm_option_get_hookdirs(handle: *mut alpm_handle_t) -> *mut alpm_list_t;
}
extern "C" {
    pub fn alpm_option_set_hookdirs(
        handle: *mut alpm_handle_t,
        hookdirs: *mut alpm_list_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn alpm_option_add_hookdir(
        handle: *mut alpm_handle_t,
        hookdir: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn alpm_option_remove_hookdir(
        handle: *mut alpm_handle_t,
        hookdir: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @}"]
    pub fn alpm_option_get_overwrite_files(handle: *mut alpm_handle_t) -> *mut alpm_list_t;
}
extern "C" {
    pub fn alpm_option_set_overwrite_files(
        handle: *mut alpm_handle_t,
        globs: *mut alpm_list_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn alpm_option_add_overwrite_file(
        handle: *mut alpm_handle_t,
        glob: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn alpm_option_remove_overwrite_file(
        handle: *mut alpm_handle_t,
        glob: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the logfile name."]
    pub fn alpm_option_get_logfile(handle: *mut alpm_handle_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Sets the logfile name."]
    pub fn alpm_option_set_logfile(
        handle: *mut alpm_handle_t,
        logfile: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the path to libalpm's GnuPG home directory."]
    pub fn alpm_option_get_gpgdir(handle: *mut alpm_handle_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Sets the path to libalpm's GnuPG home directory."]
    pub fn alpm_option_set_gpgdir(
        handle: *mut alpm_handle_t,
        gpgdir: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns whether to use syslog (0 is FALSE, TRUE otherwise)."]
    pub fn alpm_option_get_usesyslog(handle: *mut alpm_handle_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets whether to use syslog (0 is FALSE, TRUE otherwise)."]
    pub fn alpm_option_set_usesyslog(
        handle: *mut alpm_handle_t,
        usesyslog: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @name Accessors to the list of no-upgrade files."]
    #[doc = " These functions modify the list of files which should"]
    #[doc = " not be updated by package installation."]
    #[doc = " @{"]
    pub fn alpm_option_get_noupgrades(handle: *mut alpm_handle_t) -> *mut alpm_list_t;
}
extern "C" {
    pub fn alpm_option_add_noupgrade(
        handle: *mut alpm_handle_t,
        path: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn alpm_option_set_noupgrades(
        handle: *mut alpm_handle_t,
        noupgrade: *mut alpm_list_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn alpm_option_remove_noupgrade(
        handle: *mut alpm_handle_t,
        path: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn alpm_option_match_noupgrade(
        handle: *mut alpm_handle_t,
        path: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @name Accessors to the list of no-extract files."]
    #[doc = " These functions modify the list of filenames which should"]
    #[doc = " be skipped packages which should"]
    #[doc = " not be upgraded by a sysupgrade operation."]
    #[doc = " @{"]
    pub fn alpm_option_get_noextracts(handle: *mut alpm_handle_t) -> *mut alpm_list_t;
}
extern "C" {
    pub fn alpm_option_add_noextract(
        handle: *mut alpm_handle_t,
        path: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn alpm_option_set_noextracts(
        handle: *mut alpm_handle_t,
        noextract: *mut alpm_list_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn alpm_option_remove_noextract(
        handle: *mut alpm_handle_t,
        path: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn alpm_option_match_noextract(
        handle: *mut alpm_handle_t,
        path: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @name Accessors to the list of ignored packages."]
    #[doc = " These functions modify the list of packages that"]
    #[doc = " should be ignored by a sysupgrade."]
    #[doc = " @{"]
    pub fn alpm_option_get_ignorepkgs(handle: *mut alpm_handle_t) -> *mut alpm_list_t;
}
extern "C" {
    pub fn alpm_option_add_ignorepkg(
        handle: *mut alpm_handle_t,
        pkg: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn alpm_option_set_ignorepkgs(
        handle: *mut alpm_handle_t,
        ignorepkgs: *mut alpm_list_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn alpm_option_remove_ignorepkg(
        handle: *mut alpm_handle_t,
        pkg: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @name Accessors to the list of ignored groups."]
    #[doc = " These functions modify the list of groups whose packages"]
    #[doc = " should be ignored by a sysupgrade."]
    #[doc = " @{"]
    pub fn alpm_option_get_ignoregroups(handle: *mut alpm_handle_t) -> *mut alpm_list_t;
}
extern "C" {
    pub fn alpm_option_add_ignoregroup(
        handle: *mut alpm_handle_t,
        grp: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn alpm_option_set_ignoregroups(
        handle: *mut alpm_handle_t,
        ignoregrps: *mut alpm_list_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn alpm_option_remove_ignoregroup(
        handle: *mut alpm_handle_t,
        grp: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @name Accessors to the list of ignored dependencies."]
    #[doc = " These functions modify the list of dependencies that"]
    #[doc = " should be ignored by a sysupgrade."]
    #[doc = " @{"]
    pub fn alpm_option_get_assumeinstalled(handle: *mut alpm_handle_t) -> *mut alpm_list_t;
}
extern "C" {
    pub fn alpm_option_add_assumeinstalled(
        handle: *mut alpm_handle_t,
        dep: *const alpm_depend_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn alpm_option_set_assumeinstalled(
        handle: *mut alpm_handle_t,
        deps: *mut alpm_list_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn alpm_option_remove_assumeinstalled(
        handle: *mut alpm_handle_t,
        dep: *const alpm_depend_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the targeted architecture."]
    pub fn alpm_option_get_arch(handle: *mut alpm_handle_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Sets the targeted architecture."]
    pub fn alpm_option_set_arch(
        handle: *mut alpm_handle_t,
        arch: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn alpm_option_get_checkspace(handle: *mut alpm_handle_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn alpm_option_set_checkspace(
        handle: *mut alpm_handle_t,
        checkspace: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn alpm_option_get_dbext(handle: *mut alpm_handle_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn alpm_option_set_dbext(
        handle: *mut alpm_handle_t,
        dbext: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn alpm_option_get_default_siglevel(handle: *mut alpm_handle_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn alpm_option_set_default_siglevel(
        handle: *mut alpm_handle_t,
        level: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn alpm_option_get_local_file_siglevel(handle: *mut alpm_handle_t)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn alpm_option_set_local_file_siglevel(
        handle: *mut alpm_handle_t,
        level: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn alpm_option_get_remote_file_siglevel(
        handle: *mut alpm_handle_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn alpm_option_set_remote_file_siglevel(
        handle: *mut alpm_handle_t,
        level: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn alpm_option_set_disable_dl_timeout(
        handle: *mut alpm_handle_t,
        disable_dl_timeout: ::std::os::raw::c_ushort,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the database of locally installed packages."]
    #[doc = " The returned pointer points to an internal structure"]
    #[doc = " of libalpm which should only be manipulated through"]
    #[doc = " libalpm functions."]
    #[doc = " @return a reference to the local database"]
    pub fn alpm_get_localdb(handle: *mut alpm_handle_t) -> *mut alpm_db_t;
}
extern "C" {
    #[doc = " Get the list of sync databases."]
    #[doc = " Returns a list of alpm_db_t structures, one for each registered"]
    #[doc = " sync database."]
    #[doc = " @param handle the context handle"]
    #[doc = " @return a reference to an internal list of alpm_db_t structures"]
    pub fn alpm_get_syncdbs(handle: *mut alpm_handle_t) -> *mut alpm_list_t;
}
extern "C" {
    #[doc = " Register a sync database of packages."]
    #[doc = " @param handle the context handle"]
    #[doc = " @param treename the name of the sync repository"]
    #[doc = " @param level what level of signature checking to perform on the"]
    #[doc = " database; note that this must be a '.sig' file type verification"]
    #[doc = " @return an alpm_db_t* on success (the value), NULL on error"]
    pub fn alpm_register_syncdb(
        handle: *mut alpm_handle_t,
        treename: *const ::std::os::raw::c_char,
        level: ::std::os::raw::c_int,
    ) -> *mut alpm_db_t;
}
extern "C" {
    #[doc = " Unregister all package databases."]
    #[doc = " @param handle the context handle"]
    #[doc = " @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub fn alpm_unregister_all_syncdbs(handle: *mut alpm_handle_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Unregister a package database."]
    #[doc = " @param db pointer to the package database to unregister"]
    #[doc = " @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub fn alpm_db_unregister(db: *mut alpm_db_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the name of a package database."]
    #[doc = " @param db pointer to the package database"]
    #[doc = " @return the name of the package database, NULL on error"]
    pub fn alpm_db_get_name(db: *const alpm_db_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get the signature verification level for a database."]
    #[doc = " Will return the default verification level if this database is set up"]
    #[doc = " with ALPM_SIG_USE_DEFAULT."]
    #[doc = " @param db pointer to the package database"]
    #[doc = " @return the signature verification level"]
    pub fn alpm_db_get_siglevel(db: *mut alpm_db_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Check the validity of a database."]
    #[doc = " This is most useful for sync databases and verifying signature status."]
    #[doc = " If invalid, the handle error code will be set accordingly."]
    #[doc = " @param db pointer to the package database"]
    #[doc = " @return 0 if valid, -1 if invalid (pm_errno is set accordingly)"]
    pub fn alpm_db_get_valid(db: *mut alpm_db_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @name Accessors to the list of servers for a database."]
    #[doc = " @{"]
    pub fn alpm_db_get_servers(db: *const alpm_db_t) -> *mut alpm_list_t;
}
extern "C" {
    pub fn alpm_db_set_servers(
        db: *mut alpm_db_t,
        servers: *mut alpm_list_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn alpm_db_add_server(
        db: *mut alpm_db_t,
        url: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn alpm_db_remove_server(
        db: *mut alpm_db_t,
        url: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @}"]
    pub fn alpm_db_update(
        force: ::std::os::raw::c_int,
        db: *mut alpm_db_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get a package entry from a package database."]
    #[doc = " @param db pointer to the package database to get the package from"]
    #[doc = " @param name of the package"]
    #[doc = " @return the package entry on success, NULL on error"]
    pub fn alpm_db_get_pkg(
        db: *mut alpm_db_t,
        name: *const ::std::os::raw::c_char,
    ) -> *mut alpm_pkg_t;
}
extern "C" {
    #[doc = " Get the package cache of a package database."]
    #[doc = " @param db pointer to the package database to get the package from"]
    #[doc = " @return the list of packages on success, NULL on error"]
    pub fn alpm_db_get_pkgcache(db: *mut alpm_db_t) -> *mut alpm_list_t;
}
extern "C" {
    #[doc = " Get a group entry from a package database."]
    #[doc = " @param db pointer to the package database to get the group from"]
    #[doc = " @param name of the group"]
    #[doc = " @return the groups entry on success, NULL on error"]
    pub fn alpm_db_get_group(
        db: *mut alpm_db_t,
        name: *const ::std::os::raw::c_char,
    ) -> *mut alpm_group_t;
}
extern "C" {
    #[doc = " Get the group cache of a package database."]
    #[doc = " @param db pointer to the package database to get the group from"]
    #[doc = " @return the list of groups on success, NULL on error"]
    pub fn alpm_db_get_groupcache(db: *mut alpm_db_t) -> *mut alpm_list_t;
}
extern "C" {
    #[doc = " Searches a database with regular expressions."]
    #[doc = " @param db pointer to the package database to search in"]
    #[doc = " @param needles a list of regular expressions to search for"]
    #[doc = " @param ret the list of packages matching all regular expressions"]
    #[doc = " @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub fn alpm_db_search(
        db: *mut alpm_db_t,
        needles: *const alpm_list_t,
        ret: *mut *mut alpm_list_t,
    ) -> ::std::os::raw::c_int;
}
pub mod _alpm_db_usage_t {
    pub type Type = u32;
    pub const ALPM_DB_USAGE_SYNC: Type = 1;
    pub const ALPM_DB_USAGE_SEARCH: Type = 2;
    pub const ALPM_DB_USAGE_INSTALL: Type = 4;
    pub const ALPM_DB_USAGE_UPGRADE: Type = 8;
    pub const ALPM_DB_USAGE_ALL: Type = 15;
}
pub use self::_alpm_db_usage_t::Type as alpm_db_usage_t;
extern "C" {
    #[doc = " Sets the usage of a database."]
    #[doc = " @param db pointer to the package database to set the status for"]
    #[doc = " @param usage a bitmask of alpm_db_usage_t values"]
    #[doc = " @return 0 on success, or -1 on error"]
    pub fn alpm_db_set_usage(
        db: *mut alpm_db_t,
        usage: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Gets the usage of a database."]
    #[doc = " @param db pointer to the package database to get the status of"]
    #[doc = " @param usage pointer to an alpm_db_usage_t to store db's status"]
    #[doc = " @return 0 on success, or -1 on error"]
    pub fn alpm_db_get_usage(
        db: *mut alpm_db_t,
        usage: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Create a package from a file."]
    #[doc = " If full is false, the archive is read only until all necessary"]
    #[doc = " metadata is found. If it is true, the entire archive is read, which"]
    #[doc = " serves as a verification of integrity and the filelist can be created."]
    #[doc = " The allocated structure should be freed using alpm_pkg_free()."]
    #[doc = " @param handle the context handle"]
    #[doc = " @param filename location of the package tarball"]
    #[doc = " @param full whether to stop the load after metadata is read or continue"]
    #[doc = " through the full archive"]
    #[doc = " @param level what level of package signature checking to perform on the"]
    #[doc = " package; note that this must be a '.sig' file type verification"]
    #[doc = " @param pkg address of the package pointer"]
    #[doc = " @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub fn alpm_pkg_load(
        handle: *mut alpm_handle_t,
        filename: *const ::std::os::raw::c_char,
        full: ::std::os::raw::c_int,
        level: ::std::os::raw::c_int,
        pkg: *mut *mut alpm_pkg_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Find a package in a list by name."]
    #[doc = " @param haystack a list of alpm_pkg_t"]
    #[doc = " @param needle the package name"]
    #[doc = " @return a pointer to the package if found or NULL"]
    pub fn alpm_pkg_find(
        haystack: *mut alpm_list_t,
        needle: *const ::std::os::raw::c_char,
    ) -> *mut alpm_pkg_t;
}
extern "C" {
    #[doc = " Free a package."]
    #[doc = " @param pkg package pointer to free"]
    #[doc = " @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub fn alpm_pkg_free(pkg: *mut alpm_pkg_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Check the integrity (with md5) of a package from the sync cache."]
    #[doc = " @param pkg package pointer"]
    #[doc = " @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub fn alpm_pkg_checkmd5sum(pkg: *mut alpm_pkg_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Compare two version strings and determine which one is 'newer'."]
    pub fn alpm_pkg_vercmp(
        a: *const ::std::os::raw::c_char,
        b: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Computes the list of packages requiring a given package."]
    #[doc = " The return value of this function is a newly allocated"]
    #[doc = " list of package names (char*), it should be freed by the caller."]
    #[doc = " @param pkg a package"]
    #[doc = " @return the list of packages requiring pkg"]
    pub fn alpm_pkg_compute_requiredby(pkg: *mut alpm_pkg_t) -> *mut alpm_list_t;
}
extern "C" {
    #[doc = " Computes the list of packages optionally requiring a given package."]
    #[doc = " The return value of this function is a newly allocated"]
    #[doc = " list of package names (char*), it should be freed by the caller."]
    #[doc = " @param pkg a package"]
    #[doc = " @return the list of packages optionally requiring pkg"]
    pub fn alpm_pkg_compute_optionalfor(pkg: *mut alpm_pkg_t) -> *mut alpm_list_t;
}
extern "C" {
    #[doc = " Test if a package should be ignored."]
    #[doc = " Checks if the package is ignored via IgnorePkg, or if the package is"]
    #[doc = " in a group ignored via IgnoreGroup."]
    #[doc = " @param handle the context handle"]
    #[doc = " @param pkg the package to test"]
    #[doc = " @return 1 if the package should be ignored, 0 otherwise"]
    pub fn alpm_pkg_should_ignore(
        handle: *mut alpm_handle_t,
        pkg: *mut alpm_pkg_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Gets the name of the file from which the package was loaded."]
    #[doc = " @param pkg a pointer to package"]
    #[doc = " @return a reference to an internal string"]
    pub fn alpm_pkg_get_filename(pkg: *mut alpm_pkg_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns the package base name."]
    #[doc = " @param pkg a pointer to package"]
    #[doc = " @return a reference to an internal string"]
    pub fn alpm_pkg_get_base(pkg: *mut alpm_pkg_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns the package name."]
    #[doc = " @param pkg a pointer to package"]
    #[doc = " @return a reference to an internal string"]
    pub fn alpm_pkg_get_name(pkg: *mut alpm_pkg_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns the package version as a string."]
    #[doc = " This includes all available epoch, version, and pkgrel components. Use"]
    #[doc = " alpm_pkg_vercmp() to compare version strings if necessary."]
    #[doc = " @param pkg a pointer to package"]
    #[doc = " @return a reference to an internal string"]
    pub fn alpm_pkg_get_version(pkg: *mut alpm_pkg_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns the origin of the package."]
    #[doc = " @return an alpm_pkgfrom_t constant, -1 on error"]
    pub fn alpm_pkg_get_origin(pkg: *mut alpm_pkg_t) -> alpm_pkgfrom_t;
}
extern "C" {
    #[doc = " Returns the package description."]
    #[doc = " @param pkg a pointer to package"]
    #[doc = " @return a reference to an internal string"]
    pub fn alpm_pkg_get_desc(pkg: *mut alpm_pkg_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns the package URL."]
    #[doc = " @param pkg a pointer to package"]
    #[doc = " @return a reference to an internal string"]
    pub fn alpm_pkg_get_url(pkg: *mut alpm_pkg_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns the build timestamp of the package."]
    #[doc = " @param pkg a pointer to package"]
    #[doc = " @return the timestamp of the build time"]
    pub fn alpm_pkg_get_builddate(pkg: *mut alpm_pkg_t) -> alpm_time_t;
}
extern "C" {
    #[doc = " Returns the install timestamp of the package."]
    #[doc = " @param pkg a pointer to package"]
    #[doc = " @return the timestamp of the install time"]
    pub fn alpm_pkg_get_installdate(pkg: *mut alpm_pkg_t) -> alpm_time_t;
}
extern "C" {
    #[doc = " Returns the packager's name."]
    #[doc = " @param pkg a pointer to package"]
    #[doc = " @return a reference to an internal string"]
    pub fn alpm_pkg_get_packager(pkg: *mut alpm_pkg_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns the package's MD5 checksum as a string."]
    #[doc = " The returned string is a sequence of 32 lowercase hexadecimal digits."]
    #[doc = " @param pkg a pointer to package"]
    #[doc = " @return a reference to an internal string"]
    pub fn alpm_pkg_get_md5sum(pkg: *mut alpm_pkg_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns the package's SHA256 checksum as a string."]
    #[doc = " The returned string is a sequence of 64 lowercase hexadecimal digits."]
    #[doc = " @param pkg a pointer to package"]
    #[doc = " @return a reference to an internal string"]
    pub fn alpm_pkg_get_sha256sum(pkg: *mut alpm_pkg_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns the architecture for which the package was built."]
    #[doc = " @param pkg a pointer to package"]
    #[doc = " @return a reference to an internal string"]
    pub fn alpm_pkg_get_arch(pkg: *mut alpm_pkg_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns the size of the package. This is only available for sync database"]
    #[doc = " packages and package files, not those loaded from the local database."]
    #[doc = " @param pkg a pointer to package"]
    #[doc = " @return the size of the package in bytes."]
    pub fn alpm_pkg_get_size(pkg: *mut alpm_pkg_t) -> off_t;
}
extern "C" {
    #[doc = " Returns the installed size of the package."]
    #[doc = " @param pkg a pointer to package"]
    #[doc = " @return the total size of files installed by the package."]
    pub fn alpm_pkg_get_isize(pkg: *mut alpm_pkg_t) -> off_t;
}
extern "C" {
    #[doc = " Returns the package installation reason."]
    #[doc = " @param pkg a pointer to package"]
    #[doc = " @return an enum member giving the install reason."]
    pub fn alpm_pkg_get_reason(pkg: *mut alpm_pkg_t) -> alpm_pkgreason_t;
}
extern "C" {
    #[doc = " Returns the list of package licenses."]
    #[doc = " @param pkg a pointer to package"]
    #[doc = " @return a pointer to an internal list of strings."]
    pub fn alpm_pkg_get_licenses(pkg: *mut alpm_pkg_t) -> *mut alpm_list_t;
}
extern "C" {
    #[doc = " Returns the list of package groups."]
    #[doc = " @param pkg a pointer to package"]
    #[doc = " @return a pointer to an internal list of strings."]
    pub fn alpm_pkg_get_groups(pkg: *mut alpm_pkg_t) -> *mut alpm_list_t;
}
extern "C" {
    #[doc = " Returns the list of package dependencies as alpm_depend_t."]
    #[doc = " @param pkg a pointer to package"]
    #[doc = " @return a reference to an internal list of alpm_depend_t structures."]
    pub fn alpm_pkg_get_depends(pkg: *mut alpm_pkg_t) -> *mut alpm_list_t;
}
extern "C" {
    #[doc = " Returns the list of package optional dependencies."]
    #[doc = " @param pkg a pointer to package"]
    #[doc = " @return a reference to an internal list of alpm_depend_t structures."]
    pub fn alpm_pkg_get_optdepends(pkg: *mut alpm_pkg_t) -> *mut alpm_list_t;
}
extern "C" {
    #[doc = " Returns a list of package check dependencies"]
    #[doc = " @param pkg a pointer to package"]
    #[doc = " @return a reference to an internal list of alpm_depend_t structures."]
    pub fn alpm_pkg_get_checkdepends(pkg: *mut alpm_pkg_t) -> *mut alpm_list_t;
}
extern "C" {
    #[doc = " Returns a list of package make dependencies"]
    #[doc = " @param pkg a pointer to package"]
    #[doc = " @return a reference to an internal list of alpm_depend_t structures."]
    pub fn alpm_pkg_get_makedepends(pkg: *mut alpm_pkg_t) -> *mut alpm_list_t;
}
extern "C" {
    #[doc = " Returns the list of packages conflicting with pkg."]
    #[doc = " @param pkg a pointer to package"]
    #[doc = " @return a reference to an internal list of alpm_depend_t structures."]
    pub fn alpm_pkg_get_conflicts(pkg: *mut alpm_pkg_t) -> *mut alpm_list_t;
}
extern "C" {
    #[doc = " Returns the list of packages provided by pkg."]
    #[doc = " @param pkg a pointer to package"]
    #[doc = " @return a reference to an internal list of alpm_depend_t structures."]
    pub fn alpm_pkg_get_provides(pkg: *mut alpm_pkg_t) -> *mut alpm_list_t;
}
extern "C" {
    #[doc = " Returns the list of packages to be replaced by pkg."]
    #[doc = " @param pkg a pointer to package"]
    #[doc = " @return a reference to an internal list of alpm_depend_t structures."]
    pub fn alpm_pkg_get_replaces(pkg: *mut alpm_pkg_t) -> *mut alpm_list_t;
}
extern "C" {
    #[doc = " Returns the list of files installed by pkg."]
    #[doc = " The filenames are relative to the install root,"]
    #[doc = " and do not include leading slashes."]
    #[doc = " @param pkg a pointer to package"]
    #[doc = " @return a pointer to a filelist object containing a count and an array of"]
    #[doc = " package file objects"]
    pub fn alpm_pkg_get_files(pkg: *mut alpm_pkg_t) -> *mut alpm_filelist_t;
}
extern "C" {
    #[doc = " Returns the list of files backed up when installing pkg."]
    #[doc = " @param pkg a pointer to package"]
    #[doc = " @return a reference to a list of alpm_backup_t objects"]
    pub fn alpm_pkg_get_backup(pkg: *mut alpm_pkg_t) -> *mut alpm_list_t;
}
extern "C" {
    #[doc = " Returns the database containing pkg."]
    #[doc = " Returns a pointer to the alpm_db_t structure the package is"]
    #[doc = " originating from, or NULL if the package was loaded from a file."]
    #[doc = " @param pkg a pointer to package"]
    #[doc = " @return a pointer to the DB containing pkg, or NULL."]
    pub fn alpm_pkg_get_db(pkg: *mut alpm_pkg_t) -> *mut alpm_db_t;
}
extern "C" {
    #[doc = " Returns the base64 encoded package signature."]
    #[doc = " @param pkg a pointer to package"]
    #[doc = " @return a reference to an internal string"]
    pub fn alpm_pkg_get_base64_sig(pkg: *mut alpm_pkg_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns the method used to validate a package during install."]
    #[doc = " @param pkg a pointer to package"]
    #[doc = " @return an enum member giving the validation method"]
    pub fn alpm_pkg_get_validation(pkg: *mut alpm_pkg_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Open a package changelog for reading."]
    #[doc = " Similar to fopen in functionality, except that the returned 'file"]
    #[doc = " stream' could really be from an archive as well as from the database."]
    #[doc = " @param pkg the package to read the changelog of (either file or db)"]
    #[doc = " @return a 'file stream' to the package changelog"]
    pub fn alpm_pkg_changelog_open(pkg: *mut alpm_pkg_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Read data from an open changelog 'file stream'."]
    #[doc = " Similar to fread in functionality, this function takes a buffer and"]
    #[doc = " amount of data to read. If an error occurs pm_errno will be set."]
    #[doc = " @param ptr a buffer to fill with raw changelog data"]
    #[doc = " @param size the size of the buffer"]
    #[doc = " @param pkg the package that the changelog is being read from"]
    #[doc = " @param fp a 'file stream' to the package changelog"]
    #[doc = " @return the number of characters read, or 0 if there is no more data or an"]
    #[doc = " error occurred."]
    pub fn alpm_pkg_changelog_read(
        ptr: *mut ::std::os::raw::c_void,
        size: usize,
        pkg: *const alpm_pkg_t,
        fp: *mut ::std::os::raw::c_void,
    ) -> usize;
}
extern "C" {
    pub fn alpm_pkg_changelog_close(
        pkg: *const alpm_pkg_t,
        fp: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Open a package mtree file for reading."]
    #[doc = " @param pkg the local package to read the changelog of"]
    #[doc = " @return a archive structure for the package mtree file"]
    pub fn alpm_pkg_mtree_open(pkg: *mut alpm_pkg_t) -> *mut archive;
}
extern "C" {
    #[doc = " Read next entry from a package mtree file."]
    #[doc = " @param pkg the package that the mtree file is being read from"]
    #[doc = " @param archive the archive structure reading from the mtree file"]
    #[doc = " @param entry an archive_entry to store the entry header information"]
    #[doc = " @return 0 if end of archive is reached, non-zero otherwise."]
    pub fn alpm_pkg_mtree_next(
        pkg: *const alpm_pkg_t,
        archive: *mut archive,
        entry: *mut *mut archive_entry,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn alpm_pkg_mtree_close(
        pkg: *const alpm_pkg_t,
        archive: *mut archive,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns whether the package has an install scriptlet."]
    #[doc = " @return 0 if FALSE, TRUE otherwise"]
    pub fn alpm_pkg_has_scriptlet(pkg: *mut alpm_pkg_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the size of download."]
    #[doc = " Returns the size of the files that will be downloaded to install a"]
    #[doc = " package."]
    #[doc = " @param newpkg the new package to upgrade to"]
    #[doc = " @return the size of the download"]
    pub fn alpm_pkg_download_size(newpkg: *mut alpm_pkg_t) -> off_t;
}
extern "C" {
    #[doc = " Set install reason for a package in the local database."]
    #[doc = " The provided package object must be from the local database or this method"]
    #[doc = " will fail. The write to the local database is performed immediately."]
    #[doc = " @param pkg the package to update"]
    #[doc = " @param reason the new install reason"]
    #[doc = " @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub fn alpm_pkg_set_reason(
        pkg: *mut alpm_pkg_t,
        reason: alpm_pkgreason_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Determines whether a package filelist contains a given path."]
    #[doc = " The provided path should be relative to the install root with no leading"]
    #[doc = " slashes, e.g. \"etc/localtime\". When searching for directories, the path must"]
    #[doc = " have a trailing slash."]
    #[doc = " @param filelist a pointer to a package filelist"]
    #[doc = " @param path the path to search for in the package"]
    #[doc = " @return a pointer to the matching file or NULL if not found"]
    pub fn alpm_filelist_contains(
        filelist: *mut alpm_filelist_t,
        path: *const ::std::os::raw::c_char,
    ) -> *mut alpm_file_t;
}
extern "C" {
    pub fn alpm_pkg_check_pgp_signature(
        pkg: *mut alpm_pkg_t,
        siglist: *mut alpm_siglist_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn alpm_db_check_pgp_signature(
        db: *mut alpm_db_t,
        siglist: *mut alpm_siglist_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn alpm_siglist_cleanup(siglist: *mut alpm_siglist_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn alpm_decode_signature(
        base64_data: *const ::std::os::raw::c_char,
        data: *mut *mut ::std::os::raw::c_uchar,
        data_len: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn alpm_extract_keyid(
        handle: *mut alpm_handle_t,
        identifier: *const ::std::os::raw::c_char,
        sig: *const ::std::os::raw::c_uchar,
        len: usize,
        keys: *mut *mut alpm_list_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn alpm_find_group_pkgs(
        dbs: *mut alpm_list_t,
        name: *const ::std::os::raw::c_char,
    ) -> *mut alpm_list_t;
}
extern "C" {
    pub fn alpm_sync_get_new_version(
        pkg: *mut alpm_pkg_t,
        dbs_sync: *mut alpm_list_t,
    ) -> *mut alpm_pkg_t;
}
pub mod _alpm_transflag_t {
    #[doc = " Transaction flags"]
    pub type Type = u32;
    #[doc = " Ignore dependency checks."]
    pub const ALPM_TRANS_FLAG_NODEPS: Type = 1;
    #[doc = " Delete files even if they are tagged as backup."]
    pub const ALPM_TRANS_FLAG_NOSAVE: Type = 4;
    #[doc = " Ignore version numbers when checking dependencies."]
    pub const ALPM_TRANS_FLAG_NODEPVERSION: Type = 8;
    #[doc = " Remove also any packages depending on a package being removed."]
    pub const ALPM_TRANS_FLAG_CASCADE: Type = 16;
    #[doc = " Remove packages and their unneeded deps (not explicitly installed)."]
    pub const ALPM_TRANS_FLAG_RECURSE: Type = 32;
    #[doc = " Modify database but do not commit changes to the filesystem."]
    pub const ALPM_TRANS_FLAG_DBONLY: Type = 64;
    #[doc = " Use ALPM_PKG_REASON_DEPEND when installing packages."]
    pub const ALPM_TRANS_FLAG_ALLDEPS: Type = 256;
    #[doc = " Only download packages and do not actually install."]
    pub const ALPM_TRANS_FLAG_DOWNLOADONLY: Type = 512;
    #[doc = " Do not execute install scriptlets after installing."]
    pub const ALPM_TRANS_FLAG_NOSCRIPTLET: Type = 1024;
    #[doc = " Ignore dependency conflicts."]
    pub const ALPM_TRANS_FLAG_NOCONFLICTS: Type = 2048;
    #[doc = " Do not install a package if it is already installed and up to date."]
    pub const ALPM_TRANS_FLAG_NEEDED: Type = 8192;
    #[doc = " Use ALPM_PKG_REASON_EXPLICIT when installing packages."]
    pub const ALPM_TRANS_FLAG_ALLEXPLICIT: Type = 16384;
    #[doc = " Do not remove a package if it is needed by another one."]
    pub const ALPM_TRANS_FLAG_UNNEEDED: Type = 32768;
    #[doc = " Remove also explicitly installed unneeded deps (use with ALPM_TRANS_FLAG_RECURSE)."]
    pub const ALPM_TRANS_FLAG_RECURSEALL: Type = 65536;
    #[doc = " Do not lock the database during the operation."]
    pub const ALPM_TRANS_FLAG_NOLOCK: Type = 131072;
}
pub use self::_alpm_transflag_t::Type as alpm_transflag_t;
extern "C" {
    #[doc = " Returns the bitfield of flags for the current transaction."]
    #[doc = " @param handle the context handle"]
    #[doc = " @return the bitfield of transaction flags"]
    pub fn alpm_trans_get_flags(handle: *mut alpm_handle_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns a list of packages added by the transaction."]
    #[doc = " @param handle the context handle"]
    #[doc = " @return a list of alpm_pkg_t structures"]
    pub fn alpm_trans_get_add(handle: *mut alpm_handle_t) -> *mut alpm_list_t;
}
extern "C" {
    #[doc = " Returns the list of packages removed by the transaction."]
    #[doc = " @param handle the context handle"]
    #[doc = " @return a list of alpm_pkg_t structures"]
    pub fn alpm_trans_get_remove(handle: *mut alpm_handle_t) -> *mut alpm_list_t;
}
extern "C" {
    #[doc = " Initialize the transaction."]
    #[doc = " @param handle the context handle"]
    #[doc = " @param flags flags of the transaction (like nodeps, etc; see alpm_transflag_t)"]
    #[doc = " @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub fn alpm_trans_init(
        handle: *mut alpm_handle_t,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Prepare a transaction."]
    #[doc = " @param handle the context handle"]
    #[doc = " @param data the address of an alpm_list where a list"]
    #[doc = " of alpm_depmissing_t objects is dumped (conflicting packages)"]
    #[doc = " @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub fn alpm_trans_prepare(
        handle: *mut alpm_handle_t,
        data: *mut *mut alpm_list_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Commit a transaction."]
    #[doc = " @param handle the context handle"]
    #[doc = " @param data the address of an alpm_list where detailed description"]
    #[doc = " of an error can be dumped (i.e. list of conflicting files)"]
    #[doc = " @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub fn alpm_trans_commit(
        handle: *mut alpm_handle_t,
        data: *mut *mut alpm_list_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Interrupt a transaction."]
    #[doc = " @param handle the context handle"]
    #[doc = " @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub fn alpm_trans_interrupt(handle: *mut alpm_handle_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Release a transaction."]
    #[doc = " @param handle the context handle"]
    #[doc = " @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub fn alpm_trans_release(handle: *mut alpm_handle_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Search for packages to upgrade and add them to the transaction."]
    #[doc = " @param handle the context handle"]
    #[doc = " @param enable_downgrade allow downgrading of packages if the remote version is lower"]
    #[doc = " @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub fn alpm_sync_sysupgrade(
        handle: *mut alpm_handle_t,
        enable_downgrade: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Add a package to the transaction."]
    #[doc = " If the package was loaded by alpm_pkg_load(), it will be freed upon"]
    #[doc = " alpm_trans_release() invocation."]
    #[doc = " @param handle the context handle"]
    #[doc = " @param pkg the package to add"]
    #[doc = " @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub fn alpm_add_pkg(handle: *mut alpm_handle_t, pkg: *mut alpm_pkg_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Add a package removal action to the transaction."]
    #[doc = " @param handle the context handle"]
    #[doc = " @param pkg the package to uninstall"]
    #[doc = " @return 0 on success, -1 on error (pm_errno is set accordingly)"]
    pub fn alpm_remove_pkg(
        handle: *mut alpm_handle_t,
        pkg: *mut alpm_pkg_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @addtogroup alpm_api_depends Dependency Functions"]
    #[doc = " Functions dealing with libalpm representation of dependency"]
    #[doc = " information."]
    #[doc = " @{"]
    pub fn alpm_checkdeps(
        handle: *mut alpm_handle_t,
        pkglist: *mut alpm_list_t,
        remove: *mut alpm_list_t,
        upgrade: *mut alpm_list_t,
        reversedeps: ::std::os::raw::c_int,
    ) -> *mut alpm_list_t;
}
extern "C" {
    pub fn alpm_find_satisfier(
        pkgs: *mut alpm_list_t,
        depstring: *const ::std::os::raw::c_char,
    ) -> *mut alpm_pkg_t;
}
extern "C" {
    pub fn alpm_find_dbs_satisfier(
        handle: *mut alpm_handle_t,
        dbs: *mut alpm_list_t,
        depstring: *const ::std::os::raw::c_char,
    ) -> *mut alpm_pkg_t;
}
extern "C" {
    pub fn alpm_checkconflicts(
        handle: *mut alpm_handle_t,
        pkglist: *mut alpm_list_t,
    ) -> *mut alpm_list_t;
}
extern "C" {
    #[doc = " Returns a newly allocated string representing the dependency information."]
    #[doc = " @param dep a dependency info structure"]
    #[doc = " @return a formatted string, e.g. \"glibc>=2.12\""]
    pub fn alpm_dep_compute_string(dep: *const alpm_depend_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Return a newly allocated dependency information parsed from a string"]
    #[doc = " @param depstring a formatted string, e.g. \"glibc=2.12\""]
    #[doc = " @return a dependency info structure"]
    pub fn alpm_dep_from_string(depstring: *const ::std::os::raw::c_char) -> *mut alpm_depend_t;
}
extern "C" {
    #[doc = " Free a dependency info structure"]
    #[doc = " @param dep struct to free"]
    pub fn alpm_dep_free(dep: *mut alpm_depend_t);
}
extern "C" {
    #[doc = " @}"]
    pub fn alpm_compute_md5sum(
        filename: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn alpm_compute_sha256sum(
        filename: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn alpm_initialize(
        root: *const ::std::os::raw::c_char,
        dbpath: *const ::std::os::raw::c_char,
        err: *mut alpm_errno_t,
    ) -> *mut alpm_handle_t;
}
extern "C" {
    pub fn alpm_release(handle: *mut alpm_handle_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn alpm_unlock(handle: *mut alpm_handle_t) -> ::std::os::raw::c_int;
}
pub mod alpm_caps {
    pub type Type = u32;
    pub const ALPM_CAPABILITY_NLS: Type = 1;
    pub const ALPM_CAPABILITY_DOWNLOADER: Type = 2;
    pub const ALPM_CAPABILITY_SIGNATURES: Type = 4;
}
extern "C" {
    pub fn alpm_version() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn alpm_capabilities() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn alpm_fileconflict_free(conflict: *mut alpm_fileconflict_t);
}
extern "C" {
    pub fn alpm_depmissing_free(miss: *mut alpm_depmissing_t);
}
extern "C" {
    pub fn alpm_conflict_free(conflict: *mut alpm_conflict_t);
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
